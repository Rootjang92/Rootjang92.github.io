<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rootjang&#39;s IT Blog</title>
  
  <subtitle>Geunho&#39;s IT Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rootjang92.github.io/"/>
  <updated>2018-09-14T02:45:19.000Z</updated>
  <id>http://rootjang92.github.io/</id>
  
  <author>
    <name>Geun ho</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>텍스트 관련 css</title>
    <link href="http://rootjang92.github.io/2018/09/14/csstext/"/>
    <id>http://rootjang92.github.io/2018/09/14/csstext/</id>
    <published>2018-09-14T01:35:18.000Z</published>
    <updated>2018-09-14T02:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Text-관련-css"><a href="#Text-관련-css" class="headerlink" title="Text 관련 css"></a>Text 관련 css</h1><p>오늘은 텍스트에 적용되는 스타일에 대해 알아보자. 우리가 웹 사이트를 보다 보면 가장 많은 요소 중 하나가 텍스트이다. 글꼴, 줄, 정렬 등 텍스트에도 많은 스타일 요소가 있다.</p><h2 id="글꼴"><a href="#글꼴" class="headerlink" title="글꼴"></a>글꼴</h2><ul><li>font-family : 글꼴 지정하기 스타일</li></ul><p>font-family는 body, p ,hn 태그 등 텍스트를 사용하는 요소들에게 사용하는 글꼴 지정 태그이다.</p><pre><code>font-family: 글꼴이름;</code></pre><p>굴림이나 맑은 고딕 등의 이름을 넣으면 된다. 글꼴에서 중요한 것은 글꼴 자체를 시스템에 설치하여야 한다는 것이다. 기본 글꼴은 물론 적용이 되지만 그렇지 않을 경우에는 적용되지 않는다.</p><ul><li>@font-face : 웹 폰트 사용하기</li></ul><p>css3는 웹 폰트를 표준으로 채택하여 굳이 다운로드 받을 필요 없이 사용할 수 있다.</p><pre><code>&lt;style&gt;@import url(&apos;url주소&apos;); // 소스 붙여넣기.ng-font {  font-family:&apos;Nanum Gothic&apos;, 돋움; // 웹 폰트 적용(구글 나눔 고딕)}&lt;/style&gt;&lt;p class=&quot;ng-font&quot;&gt;ddd&lt;/p&gt;</code></pre><p>이런 식으로 사용하면 된다.</p><a href="https://fonts.google.com/earlyaccess" target="_blank" rel="noopener">구글폰트</a><ul><li>글꼴 저작권에 주의하여야 한다.</li></ul><p>만약 글꼴 파일을 업로드 해서 사용한다면 @font-face를 사용해서 하면 된다.</p><pre><code>@font-face {  font-family: 글꼴 이름;  src:url(글꼴파일경로) format(파일 유형);}</code></pre><ul><li>font-size : 글자 크기 조절</li></ul><p>font-size는 글꼴을 조정하는 스타일인데 크기에는 절대 크기, 상대 크기, 백분율, 크기를 정할 수 있다.</p><ol><li>절대 크기</li></ol><p>xx-small, xx-large, large 등으로 지정하는 데 거의 사용하지 않는다.(주관적인 의견입니다.)</p><ol start="2"><li>상대 크기</li></ol><p>부모 요소의 크기를 기준으로 크거나 작게 표시할 수 있다. larger | smaller</p><ol start="3"><li>크기</li></ol><p>글자 크기를 직접 지정한다.</p><ol start="4"><li>백분율</li></ol><p>글자 크기를 %로 지정한다.</p><p>글자 크기의 단위에는 em, ex, px, pt가 있다. font-size에서 가장 많이 사용하는 것은 px이다. 픽셀 단위를 사용할 경우 폰트 크기가 고정되어 모바일 등에서 볼 때에도 크기가 고정된다. 여러 웹 표준성을 고려한다면 em단위를 쓰는 것이 가장 좋긴 하다.</p><p>부모 요소에서 지정한 폰트의 너비를 1em으로 정해놓고 상대적으로 계산하는 방법이다. 기본적으로는 body태그의 16px이 1em으로 지정된다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/saod98h4/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>font-weight : 글자 굵기</li></ul><p>normal은 기본 글자 굵기 이다. 그 외에 bold | lighter | bolder (굵게 | 더 가늘게 | 원래 굵기보다 더 굵게), 100~900 (400이 normal, 700은 bold)가 있다.</p><ul><li>font-variant : 작은 대문자 표시</li></ul><p>소문자를 작은 대문자로 표시할 수 있다. 글을 꾸밀 때 유요하지만 잘 사용하지는 않는다.</p><ul><li>font-style : 글자 스타일 지정하기</li></ul><p>이탤릭체 여부를 결정한다. 속성에는 italic, oblique가 있다.</p><ul><li>font : 글꼴 속성 묶어서 사용하기</li></ul><p>font라는 스타일을 적용해서 위에 설명한 속성들을 한 번에 사용할 수 있다. 그 외에도 caption, icon, menu, message-box, small-caption, status-bar 등 각 상황에 맞는 글꼴을 표시할 수 있다.</p><p>주의할 점은 font-size와 line-height의 차이이다. 둘은 슬래시를 통해 묶어서 사용할 수 있지만, 백분율로 표시했을 때 font-size는 부모요소를 기준으로 line-height는 현재 요소의 글자 크기를 기준으로 한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/dk5nra3o/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><a href="https://www.w3.org/TR/css-fonts-3" target="_blank" rel="noopener">그 외 다양한 폰트 스타일</a><h2 id="텍스트-스타일"><a href="#텍스트-스타일" class="headerlink" title="텍스트 스타일"></a>텍스트 스타일</h2><ul><li>color : 글자 색 지정하기</li></ul><p>색상은 16진수, rgb, rgba, hsl, hsla, 색상 이름으로 지정할 수 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/8f3tj6hw/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>text-decoration : 텍스트에 줄 표시하기/없애기</li></ul><p>텍스트에 줄을 표시하거나 없앨 수 있다. 속성으로는 underline(밑줄), overline(영역 위에 선), line-through(취소 선)이 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/tLqbzco8/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>text-transform : 대 소문자 변환하기</li></ul><p>텍스트의 영문자를 대소문자로 변환시킬 수 있다. 속성으로는 capitalize(첫 글자를 대문자로), uppercase(모든 글자를 대문자로), lowercase(모든 글자를 소문자로), full-width(가능한 모든 문자를 전각문자로) 가 있다.</p><ul><li>text-shadow : 그림자 효과주기</li></ul><p>텍스트에 그림자 효과를 주는 태그이다.</p><pre><code>text-shadow : none | &lt;가로거리&gt; &lt;세로거리&gt; &lt;번짐정도&gt; &lt;색상&gt;</code></pre><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/2s8qLfy1/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>white-space  : 공백 처리하기</li></ul><p>white-space는 공백을 처리하는 속성이다. 속성 값에는 normal, nowrap(공백 그대로계속 한 줄 표시), pre(공백 하나로한줄 표시), pre-line(공백 하나로자동 줄바꿈), pre-wrap(공백 그대로 자동 줄바꿈)이 있다.</p><pre><code>td {  white-space: nowrap;}</code></pre><p>이럴 경우 td 속성의 모든 공백을 한 칸으로 인식하고 줄을 바꾸지 않는다.</p><ul><li>letter-spacing, word-spacing : 텍스트 간격 조절</li></ul><p>letter-spacing은 글자 사이 간격 조절, word-spacing은 단어와 단어 사이의 간격을 조절한다. 보통 letter-spacing 속성으로 자간을 조정한다.</p><h2 id="문단-스타일"><a href="#문단-스타일" class="headerlink" title="문단 스타일"></a>문단 스타일</h2><ul><li>direction : 글자 방향 지정하기</li></ul><p>텍스트를 어느 방향부터 써 나갈 것인지 정하는 속성이다 속성값으로 ltr, rtl이 있다. ltr은 기본 값이다.</p><ul><li>text-align 속성 : 텍스트 정렬하기</li></ul><p>왼쪽 정렬, 가운데 정렬 등 텍스트를 정렬할 때 사용하는 속성이다. 속성 값으로는 start(줄의 시작 위치에 맞춰 문단 정렬), end(텍스트 줄 끝 위치에 맞추어 문단 정렬), left, right, center, justify(양쪽에 맞추어), match-parent(부모 요소에 따라)가 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/hwcaj053/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>text-justify : 정렬 시 공백 조절</li></ul><p>text-align의 속성값이 justify일 경우, 글자 간격이 어색해질 수 있기 때문에 이를 조정하는 속성이다. 속성값으로는 auto, none, inter-word(단어 사이 공백 조절), distribute(인접한 글자 사이 공백을 같게)가 있다.</p><ul><li>text-indent : 텍스트 들여쓰기</li></ul><p>px나 백분율로 조정한다. 백분율은 부모 요소를 기준으로 크기를 지정한다.</p><ul><li>line-height: 줄 간격 조정하기</li></ul><p>역시 숫자, 실제 크기, 백분율로 표시한다. 계산법은 글자 크기가 12px일 때, 줄 간격을 2.0으로 지정하면 실제 줄 간격은  24px이 된다.</p><ul><li>text-overflow : 넘치는 텍스트 표시하기</li></ul><p>넘치는 컨텐츠를 어떻게 처리할 지 정하는 속성이다. 속성값에는 clip(자르기), ellipsis(말 줄임표 사용하기)가 있다. 단, 해당 요소의 overflow속성값이 hidden, scroll, auto이면서 white-space의 속성값이 nowrap일 경우만 적용된다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/8krz23gu/1/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="목록-스타일"><a href="#목록-스타일" class="headerlink" title="목록 스타일"></a>목록 스타일</h2><ul><li>list-style-type : 목록의 불릿과 번호 스타일 지정</li></ul><p>목록 앞에 불릿이나 번호 스타일을 지정할 수 있다. 속성 값으로는 순서 없는 목록에는 disc(원), circle(빈 원), square(사각형),none(불릿 없애기)가 있고 순서가 있는 목록에서 숫자를 바꾸고 싶은 경우 decimal, decimal-leading-zero등 여러가지 속성이 있다.</p><ul><li>list-style-image : 불릿 대신 이미지 넣기</li></ul><p>특정 이미지 속성이 있다면 불릿을 원하는 이미지로 바꿀 수 있다.</p><pre><code>list-style-image:url(&apos;url주소&apos;);</code></pre><ul><li>list-style-position : 목록에 들여 쓰기 효과내기</li></ul><p>목록을 들여쓰기 할 수 있다. 속성값으로는 inside(불릿이나 숫자를 안쪽으로), outside(내어쓰기)가 있다.</p><ul><li>list-style : 위 속성 한번에 묶어 쓰기</li></ul><p>다음 시간에는 색상과 배경에 적용하는 스타일에 대해 알아보겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Text-관련-css&quot;&gt;&lt;a href=&quot;#Text-관련-css&quot; class=&quot;headerlink&quot; title=&quot;Text 관련 css&quot;&gt;&lt;/a&gt;Text 관련 css&lt;/h1&gt;&lt;p&gt;오늘은 텍스트에 적용되는 스타일에 대해 알아보자. 우리가 웹 
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS3" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS3/"/>
    
    
      <category term="css,css3,css text" scheme="http://rootjang92.github.io/tags/css-css3-css-text/"/>
    
  </entry>
  
  <entry>
    <title>클로저에 대하여</title>
    <link href="http://rootjang92.github.io/2018/09/14/closure/"/>
    <id>http://rootjang92.github.io/2018/09/14/closure/</id>
    <published>2018-09-14T01:35:10.000Z</published>
    <updated>2018-09-14T08:20:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h1><p>앞에서 살펴봤던 실행 컨텍스트에서 클로저에 대해 잠깐 언급했다. 실행 컨텍스트가 소멸하여도 그 환경은 남아 외부에서 참조가 가능하다고 했었지만, 사실 말도 너무 어렵고 이해하기가 어렵다.(저도 그랬습니다… 아직도 완벽하다고 보긴 어렵기도 하고…)</p><pre><code>function outFun() {  var x = 1;  var inFun = function() {    console.log(x);  };  return inFun;};var inner = outFun();inner();</code></pre><p>이 함수를 살펴보자. 함수 outFun()은 내부함수 inFun을 반환하고 소멸했다. 마지막에 함수 outFun()을 할당해준 변수를 소환해도 변수 x에는 접근할 수 없을 것 같지만 결과는 1이 나온다.<br>이처럼 자신을 포함하고 있는 외부함수가 내부함수보다 더 오래 유지되는 경우(그 환경이) 내부함수가 노출되더라도 외부함수의 지역 변에 접근할 수 있는 것을 <strong>클로저(Closure)</strong> 라고 한다.</p><p>다른 정의로는 내부함수가 그 렉시컬 환경(선언 됐을 때 환경)의 스코프를 기억하여 자신의 선언됐을 때 환경 밖에서 호출되어도 그 환경에 접근할 수 있는 함수를 말한다. 즉 <strong>자신의 태어났을 때의 환경을 기억하는 함수</strong>라고 할 수 있다.</p><p><img src="https://poiemaweb.com/img/closure.png" alt="실행컨텍스트"></p><p>내부함수가 유효한 상태에서 외부함수가 종료되어 외부함수의 실행 컨텍스트가 반환되어도, 외부함수 실행 컨텍스트 내의 활성 객체는 내부함수가 참조하는 한 내부함수가 스코프체인을 통해 참조할 수 있다는 것을 의미한다.<br><strong>내부함수가 하나 이상 존재하는 경우 계속 유지된다.</strong> 이 때 내부함수는 외부함수의 실제 변수에 접근한다.</p><h2 id="클로저-활용하기"><a href="#클로저-활용하기" class="headerlink" title="클로저 활용하기"></a>클로저 활용하기</h2><ol><li>전역 변수 억제</li></ol><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/f2twcqpr/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>단 이 코드의 문제는 함수 increase 함수가 호출되기 전 counter의 값이 반드시 0이여야 한다는 것이다. 그렇다고 변수 counter를 increase 함수 안에 넣는다면 함수가 호출될 때마다 값이 초기화가 된다.</p><p>이 코드를 클로저를 활용해 문제를 해결하면</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/1w4q0tru/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>즉시실행함수는 한 번만 실행되기 때문에 counter가 초기화 될 일이 없다. 또한 increaser에 담겨있는 함수가 외부함수 변수 counter에 접근할 수 있다는 것이다. 또한 변수 counter는 private 변수이므로 외부에서의 변경을 신경쓸 필요가 없다. 여기서의 counter가 바로 <strong>자유변수</strong>이다.</p><ol start="2"><li>특정 함수에 사용자가 정의한 객체 메서드 연결</li></ol><p>예제를 살펴보면</p><pre><code>function HelloFunc(func) {  this.greeting = &apos;Helle&apos;;}HelloFunc.prototype.call = function(func) {  func ? func(this.greeting) : this.func(this.greeting);}var user = function(greeting) {  console.log(greeting); // Hello}var objHello = new HelloFunc();objHello.func = user;objHello.call();</code></pre><p>func 프로퍼티에 참조되는 함수를 call() 함수로 호출하여 func 프로퍼티에 자신이 정의한 함수를 참조시켜 호출할 수 있다.<br>다만 greeting만을 인자로 넣어 사용하기 때문에 한 개의 인자를 받는 함수를 정의할 수 밖에 없기 때문에</p><pre><code>function saySomething(obj, methodName, name) {  return (function(greeting) {    return obj[methodName](greeting,name);  });}function newObj(obj, name) {  obj.func = saySomething(this, &quot;who&quot;, name);  return obj;}newObj.prototype.who = function(greeting, name) {  console.log(greeting + &quot; &quot; + (name || &quot;everyone&quot;) );}var obj1 = new newObj(objHello, &quot;Jang&quot;);obj1.call();console.log(obj1);</code></pre><p>첫 번째로  obj.func가 실행되어 saySomething() 함수에서 반환되는 함수를 참조한다. 결국 obj1은 objHello 객체에서 func 프로퍼티에 참조된 함수만 바뀐 객체가 되기 때문에 call 함수를 사용할 수 있다.</p><p>출력결과</p><blockquote><p>Helle<br>Helle Jang<br>HelloFunc { greeting: ‘Helle’, func: [Function] }</p></blockquote><p>또한 obj1.call()로 인해 실행되는 것은 실제로 newObj.prototype.who()가 된다. who를 HelloFunc에 연결할 수 있고 클로저는 saySomething()에서 반환되면 function(greeting) {}이 되어 자유변수 obj, methodName, name을 참조하게 된다.</p><ol start="3"><li><p>함수 캡슐화<br>다음 예제를 통해 자기소개를 출력해보자.</p><p> var getCompleted = (function() {<br>   var buffAr = [</p><pre><code>&apos;I am &apos;,&apos;&apos;,&apos;I live in &apos;,&apos;&apos;,&apos;. I\&apos;m &apos;,&apos;&apos;,&apos; years old.&apos;,</code></pre><p>   ];<br>   return (function(name, city, age) {</p><pre><code>buffAr[1] = name;buffAr[3] = city;buffAr[5] = age;return buffAr.join(&apos;&apos;);</code></pre><p>   });<br> })();</p><p> var str = getCompleted(‘Jang’, ‘Incheon’, 27);<br> console.log(str);</p></li></ol><p>변수 getComplted에 익명 함수를 즉시 실행함수로 실행시켜서 반환되는 함수를 할당하는 것이다. 여기서 반환되는 함수가 클로저가 되서 자유변수 buffAr을 스코프체인에서 참조할 수 있다.</p><ol start="4"><li>setTimeout()</li></ol><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/1mkwqr95/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>첫번째로 함수 fade가 document.body를 인자로 전달받아서 호출한다. 그 후 함수 fade의 지역변수인 level이 1로 초기화가 되어 있다. step은 내부함수, 외부 함수 fade의 지역변수 level을 사용하고 level은 자유 변수다.<br>setTimeout() 호출 후에는 fade 함수는 종료되지만, 100ms 이후에 함수 step이 호출된다.<br>step은 지역 변수 hex를 갖고 16진수 문자열이다. fade의 배경색을 변경할 수 있다.<br>그 후 변수 level이 15보다 작은지 확인한다. 그 후 level = 1을 증가시켜 작업을 반복한다.</p><ol start="5"><li>실수</li></ol><p>클로저의 프로퍼티값이 쓰기 가능하면 여러번 호출로 값이 항상 변할 수 있다.</p><pre><code>function outerFun(argNum) {  var num = argNum;  return function(x) {    num += x;    console.log(&apos;num : &apos; + num);  }}var exam = outerFun(40);exam(5); // 45exam(-5); //40</code></pre><p>exam을 호출할 때마다 num의 값이 변한다.</p><p>하나의 클로저가 여러 함수 객체의 스코프 체인에 들어있는 경우.</p><pre><code>function func() {  var x = 1;  return {    func1 : function(){ console.log(++x); },    func2 : function(){ console.log(-x); }  };};var exam = func();exam.func1(); // 2exam.func2(); // -2</code></pre><p>함수 호출 때마다 값이 변하므로 주의.</p><p>루프 안 클로저 활용.</p><pre><code>var arr = [];for(var i = 0; i &lt; 5; i++) {  arr[i] = function() {    return i;  };}for (var j=0; j &lt; arr.length; j++) {  console.log(arr[j]());} // 55555</code></pre><p>배열 arr 안에 5개의 함수가 할당되지만 변수 i가 전역변수이기 때문에 이미 길이가 5가 된 상태이기 때문이다.<br>이를 해결하기 위해서</p><pre><code>var arr = [];for (var i = 0; i &lt; 5; i++) {  arr[i] = (function (id) {    return function() {      return id;    };  }(i));}for (var j=0; j &lt; arr.length; j++) {  console.log(arr[j]());} // 01234</code></pre><p>이런 식으로 즉시 실행 함수를 사용하여 매개변수 id를 자유변수를 만들어 반환하면 id의 값이 유지된다.</p><p>물론 ES6의 let 키워드를 사용하면 말끔히 해결된다.(일시적 사각지대가 생기기 때문에.)</p><p>다음 시간에는 객체지향 프로그래밍의 개념에 대해 알아보겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;클로저&quot;&gt;&lt;a href=&quot;#클로저&quot; class=&quot;headerlink&quot; title=&quot;클로저&quot;&gt;&lt;/a&gt;클로저&lt;/h1&gt;&lt;p&gt;앞에서 살펴봤던 실행 컨텍스트에서 클로저에 대해 잠깐 언급했다. 실행 컨텍스트가 소멸하여도 그 환경은 남아 외부에서 참
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="Javascript, js, es5, closure, js closure" scheme="http://rootjang92.github.io/tags/Javascript-js-es5-closure-js-closure/"/>
    
  </entry>
  
  <entry>
    <title>실행 컨텍스트와 스코프</title>
    <link href="http://rootjang92.github.io/2018/09/12/executioncontext/"/>
    <id>http://rootjang92.github.io/2018/09/12/executioncontext/</id>
    <published>2018-09-12T07:33:21.000Z</published>
    <updated>2018-09-14T01:34:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="실행-컨텍스트와-스코프"><a href="#실행-컨텍스트와-스코프" class="headerlink" title="실행 컨텍스트와 스코프"></a>실행 컨텍스트와 스코프</h1><h2 id="실행-컨텍스트란"><a href="#실행-컨텍스트란" class="headerlink" title="실행 컨텍스트란?"></a>실행 컨텍스트란?</h2><p>ECMAScript의 정의를 살펴보면 <strong>실행 가능한 코드를 형상화하고 구분하는 추상적인 개념</strong>이라고 설명하고 있다.<br>즉 실행 가능한 자바스크립트 코드 블록이 실행되는 환경이라고 할 수 있다. 실행 가능한 코드에는 전역 코드, eval() 코드, 함수 코드가 있다.</p><p>우리는 오늘 한가지 예제를 통해 콜 스택부터 실행 컨텍스트, 스코프가 어떻게 설계되는 지에 대해 살펴보도록 하겠다.</p><a href="https://poiemaweb.com/js-execution-context" target="_blank" rel="noopener">참조사이트</a><pre><code>var x = &apos;xxx&apos;;function foo () {  var y = &apos;yyy&apos;;  function bar () {    var z = &apos;zzz&apos;;    console.log(x + y + z);  }  bar();}foo();</code></pre><p>이 코드에서는 스택이 쌓이고 소멸하게 된다.</p><p><img src="https://poiemaweb.com/img/ec_1.png" alt="stack"></p><ol><li>실행 가능한 코드가 새로운 실행 컨텍스트 스택으로 생성된다. 이때는 후입선출(LIFO)로 진행된다.</li><li>전역 실행 컨텍스트는 처음에 만들어져 컨텍스트가 끝날 때까지 유지된다</li><li>함수 호출 시 스택이 쌓인다.</li><li>함수 호출이 끝나면 실행 컨텍스트를 파기하고 직전 실행 컨텍스트의 컨트롤을 반환한다.</li></ol><h2 id="실행-컨텍스트-생성과정"><a href="#실행-컨텍스트-생성과정" class="headerlink" title="실행 컨텍스트 생성과정"></a>실행 컨텍스트 생성과정</h2><ol><li>전역 컨텍스트의 경우<br>전역에 선언된 전역변수와 전역 함수를 객체로 갖는다.</li></ol><p><img src="https://poiemaweb.com/img/ec-vo-global.png" alt="go"></p><ol start="2"><li>함수 컨텍스트의 경우<br>활성 객체를 가리키며 매개변수와 인수들의 정보를 가지고 있는 arguments객체가 추가된다.</li></ol><p><img src="https://poiemaweb.com/img/ec-vo-foo.png" alt="ao"></p><p>순서로는 우선 활성 객체를 생성한다. 그 후 arguments 객체를 생성한다. 이 떄 활성객체는 arguments 프로퍼티로 arguments 객체를 참조하게 된다. 그 후 스코프의 정보를 생성한다. 연결 리스트와 유사한 형태로 만들어지며 [[scope]] 프로퍼티로 참조된다. 그 후 변수를 생성한다. 주의할 점은 생성과 초기화만 진행할 뿐, 실행되기 전까지는 할당이 이루어지지 않는다는 것이다. 마지막으로 this를 할당하는 데 함수 호출 패턴에 따라 this가 참조하는 객체가 정해진다.</p><ul><li>전역 코드 진입</li></ul><p>전역 객체가 생성되면 전역 코드로 컨트롤이 진입하여 전역 실행 컨텍스트가 생성되고 실행 컨텍스트가 쌓인다.</p><p><img src="https://poiemaweb.com/img/ec_4.png" alt="전역코드"></p><ul><li>스코프 체인 생성 및 초기화</li></ul><p>이 때 스코프체인은 전역 객체 레퍼런스를 포함한다.</p><p><img src="https://poiemaweb.com/img/ec_5.png" alt="스코프체인"></p><ul><li>변수 객체화</li></ul><p><img src="https://poiemaweb.com/img/ec_6.png" alt="변수 객체화"></p><p>여기선 매개변수가 변수 객체의 프로퍼티로 인수가 값으로 설정된다. 그 후 코드 내 함수 선을 대상으로 변수 객체가 프로퍼티로, 생성된 함수 객체가 값으로 설정되며 함수 호이스팅이 발생한다. 그 다음 대상 코드 대상으로 변수 명이 변수 객체의 프로퍼티로 undefined가 값으로 설정된다. 이를 변수 호이스팅이라고 한다.</p><p>이후 위 코드의 함수 foo가 처리된다. 함수 foo가 프로퍼티로 생성된 함수 객체가 값으로 지정된다. 이 때 생성된 함수 객체는 [[scope]] 프로퍼티를 가진다. 이 때 [[scope]] 프로퍼티는 자신의 실행환경을 가지고 자신을 포함하는 외부 함수와 실행 환과 전역 객체를 가리킨다. 또한 자신을 포함하는 외부 함수의 실행 컨텍스트가 소멸하여도 [[scope]] 프로퍼티가 가리키는 외부함수 실행환경을 참조할 수 있는데 이것이 클로저다.</p><p>이후 변수 x를 처리하는데 var 변수는 선언과 초기화가 한 번에 이루어진다. 그 후 this value를 정한다. 이전에는 this가 전역 객체를 가리키다가, 함수 호출 패턴에 이해 this가 정해진다.</p><p><img src="https://poiemaweb.com/img/ec_9.png" alt="this까지"></p><p><a href="href=https://rootjang92.github.io/2018/09/10/jsfuncthis/}>https://rootjang92.github.io/2018/09/10/jsfuncthis/}</a></p>" title="<p>주의할 점은 아직 <strong>코드가 실행되지 않았다</strong>는 것이다.</p> <h2 id=코드-실행><a href=#코드-실행 class=headerlink title=코드 실행></a>코드 실행</h2><p>코드가 실행되면 우선 변수의 값을 할당하게 된다. 우선 전역 객체에 변수 x의 값이 할당되고 그 후 함수 foo가 실행된다.<br>그러면 다시 함수 foo의 스코프체인을 생성하고 초기화한다. 그 구조를 살펴보면 함수 foo를 실행한 직후 실행 컨텍스트의 스코프체인은 활성 객체(지금은 함수 foo)를 살피고 그 후 전역 객체를 살펴본다.</p> <p><img src=https://poiemaweb.com/img/ec_13.png alt=코드실행></p> <p>이를 통해 생성된 활성 객체가 변수 객체로서 변수 인스턴스화를 실행한다. 그 후에 과정은 위와 같으니 그림으로 대신하겠다.</p> <p><img src=https://poiemaweb.com/img/ec_16.png alt=foo><br>내부함수의 경우 this는 전역 객체를 가리킨다.</p> <p>이제 foo 함수를 실행되면, 변수 y의 값이 할당된다.<br>함수 bar의 과정도 위와 동일하다.</p> <ol> <li>스코프 체인의 생성과 초기화, 2. Variable Instantiation 실행, 3. this value 결정</li> </ol> <p><img src=https://poiemaweb.com/img/ec_19.png alt=최종></p> <h2 id=다른-예제><a href=#다른-예제 class=headerlink title=다른 예제></a>다른 예제</h2><p>다른 예제를 살펴보자<br>(참고 : 인사이드 자바스크립트)</p> <pre><code>var value = &quot;value1&quot;;function printValue() {  return value;}function printFunc(func) {  var value = &quot;value2&quot;;  console.log(func());}printFunc(printValue);</code></pre><p>항상 실행 컨텍스트를 생각해야 한다. 전역 실행 컨텍스트가 만들어지는 데 그 안에 동등한 함수 printValue와 printFunc가 존재한다.</p> <p>두 함수가 실행될 때의 [[scope]] 프로퍼티를 살펴보면 각각의 변수 객체를 만들고 그것을 참조하게 된다.</p> <p>printFunc를 실행하면 value: “value2”로 변수 객체가 생성된다. 또한 printValue의 변수 객체는 전역 객체에서 찾게 되므로 따로 변수 객체가 만들어지지 않는다.</p> <p>다음 시간에는 클로저에 대해 살펴보도록 하겠습니다.</p>">함수 호출 패턴 <a< a=""></a<></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;실행-컨텍스트와-스코프&quot;&gt;&lt;a href=&quot;#실행-컨텍스트와-스코프&quot; class=&quot;headerlink&quot; title=&quot;실행 컨텍스트와 스코프&quot;&gt;&lt;/a&gt;실행 컨텍스트와 스코프&lt;/h1&gt;&lt;h2 id=&quot;실행-컨텍스트란&quot;&gt;&lt;a href=&quot;#실행-컨텍
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="js, javascript, execution context, scope" scheme="http://rootjang92.github.io/tags/js-javascript-execution-context-scope/"/>
    
  </entry>
  
  <entry>
    <title>CSS의 기초 살펴보기</title>
    <link href="http://rootjang92.github.io/2018/09/12/cssbasic/"/>
    <id>http://rootjang92.github.io/2018/09/12/cssbasic/</id>
    <published>2018-09-12T02:04:28.000Z</published>
    <updated>2018-09-12T03:20:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="왜-css인가"><a href="#왜-css인가" class="headerlink" title="왜 css인가?"></a>왜 css인가?</h1><p>웹 문서에 텍스트만 있다면 어떤 느낌일 것 같은가? 물론 기존 html로 기초적인 스타일링은 할 수 있지만 지금은 2018년, 4차 산업 혁명 시대 아니겠는가? css는 우리가 보는 view라는 웹 문서를 꾸미는 언어라고 보면 된다.<br>css의 가장 큰 장점은 웹 문서를 건드리지 않고 단순히 <strong>디자인만 바꿀 수 있다.</strong>라는 정말 큰 장점이 있다.</p><a href="http://www.csszengarden.com" target="_blank" rel="noopener">참고할 만한 사이트</a><p>또한 웹 문서는 브라우저 기반이기 때문에 브라우저에 따라, 사용하는 기종에 따라 그 모습이 바뀐다.</p><ul><li>스타일 형식은?</li></ul><p>ex)<br>p{text-align: center;}</p><p>p태그의 글자를 가운데로 옮기는 css 문법이다. 여기서 p는 <strong>selector(선택자)</strong>, text-align은 <strong>Property(스타일 속성)</strong> center는 <strong>Property Value(속성 값)</strong> 이라고 한다.</p><ul><li>주석</li></ul><p>주석은 참 중요하지 않아보이지만 굉장히 중요하다. 물론 주석없이 바로바로 해석되는 게 정말 가독성이 좋은 코드라고 할 수 있지만, 모두가 그럴 순 없기에 <strong>이 코드가 어떻게 사용되었다.</strong>라는 걸 설명해 주는 것이 좋다. css의 주석은 /<em> </em>/ 사이에 텍스트를 작성한다.</p><ul><li>내부 스타일과 외부 스타일</li></ul><p>css는 html문서 안에서 작성할 수도 있다. 이를 내부 스타일 시트라고 하는데 보통 head태그 안에 title밑, style ~ /style 태그 사이에 작성한다. 반면 외부 스타일 시트는 css 파일을 따로 작성하여 html 문서에서 link태그를 사용하여 연결한다.</p><pre><code>&lt;link href=&quot;파일 경로&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</code></pre><p>보통 외부에 css 파일을 만들어 사용하는 것이 좋은데 필요한 경우에 따라 만들어 놓은 css를 가져다 사용할 수 있기 때문이다.</p><p>또한 html 태그안에 인라인 스타일로 작성할 수도 있다.</p><pre><code>&lt;p style=&quot;color:blue&quot;&gt;</code></pre><p>이런식으로 말이다.</p><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>스타일 속성을 작용하는 요소가 바로 선택자이다. 태그 하나에 지정할 수도, 여러개에 지정할 수도 있다.</p><ul><li>전체 선택자</li></ul><p>모든 요소에 적용할 때 사용하는 것이 전체 선택자 이다. 전체 선택자는 *를 사용한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/bnL3c5p9/1/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>태그 선택자</li></ul><p>해당 요소에 스타일을 적용할 때 사용한다. 해당 태그가 사용된 모든 요소에 적용된다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/r9k2v5ha/1/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>클래스 선택자</li></ul><p>해당 태그에 클래스를 지정하여 그 클래스가 지정된 요소에만 스타일이 적용되게 할 때 사용한다. 사용할 때에는 ‘.’을 사용한다. 특히 클래스는 중복이 가능하기 때문에 태그를 적요하고 싶은 태그만 골라 클래스를 적용하여 스타일을 적용할 수 있다. 다른 경우도 있다. 예를 들어 h2.bluetext라고 사용한다면 h2에 있는 bluetext 클래스에만 스타일이 적용된다. 참고로 부분적으로 적용하고 싶을 때에는 span 태그를 사용하면 된다.</p><ul><li>id 선택자</li></ul><p>클래스와 마찬가지로 특정 부분에 스타일을 적용하고 싶을 때 사용하지만, id는 중복이 허용되지 않는다. 또 다른점은 id는 #을 사용한다는 것이다.</p><ul><li>그룹 선택자</li></ul><p>따로따로 선언할 필요 없이 같은 스타일을 적용할 때에는 쉼표로 구분해주면 된다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/9kwurca7/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="Cascading"><a href="#Cascading" class="headerlink" title="Cascading"></a>Cascading</h2><p>캐스캐이딩의 의미는 선택자에 적용된 많은 스타일 중 어떤 스타일을 나타낼지를 결정한다는 의미이다. 스타일 간의 충돌을 막기 위해 무엇이 우선시 되어야 할 지 정하는 것이다. 그를 위해선</p><ol><li>스타일 우선순위</li><li>스타일 상속</li></ol><p>이 두가지 원칙에 대해서 알아야 한다.</p><ul><li>스타일 우선순위란?</li></ul><p>캐스캐이딩에 있어서 정말 중요한 개념이라고 할 수 있다. ‘어떤 스타일을 먼저 적용할까’를 결정하기 때문이다.<br>첫 번째로 중요도를 살펴봐야 한다.</p><ul><li>중요도</li></ul><ol><li>사용자 스타일 시트가 최우선이다.</li><li>!important (다른 어떤 것보다 최우선 되는 스타일)</li><li>기본 브라우저 스타일 시트</li></ol><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/5yhwnxdq/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>명시도</li></ul><p>명시도는 스타일의 적용 범위에 따라 우선순위를 정함을 말한다. 가장 중요한 것부터 말하자면</p><ol><li>인라인 스타일</li><li>id 스타일</li><li>클래스 스타일</li><li>태그 스타일</li></ol><p>의 순서로 중요도가 적용된다.</p><ul><li>소스 순서</li></ul><p>앞에 설명했던 중요도와 명시도가 같다면 먼저 온 스타일을 나중에 온 스타일이 겹친다. 위 예제에서 !important가 없다면 글자는 파란색이 될 것이다.</p><h2 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h2><p>스타일은 상속된다. 웹 문서에 사용되는 태그들은 서로 포함관계에 있다. 그 중에서는 부모요소 자식요소의 관계도 포함되어 있다.<br>자식 요소에 따로 스타일을 지정하지 않으면 부모 요소에 있는 스타일 속성이 전달된다. 이를 스타일 상속이라고 한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/abthmcod/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>부모 요소의 배경 이미지, 배경 색 등은 상속되지 않는다. 즉 부모 요소의 모든 스타일 요소가 상속되는 것은 아니다.</p><h2 id="CSS-Module"><a href="#CSS-Module" class="headerlink" title="CSS Module"></a>CSS Module</h2><a href="https://www.w3.org/Style/CSS" target="_blank" rel="noopener">css3참조하기</a><p>여러가지 css 규약이나 상태등을 볼 수 있다.</p><ul><li>prefix</li></ul><p>css 모듈에는 규약이 많고 아직 미완성 상태이기 떄문에 모든 브라우저에서 똑같이 적용되지 않는 경우도 있다. 또한 버전에 따라서도 지원이 되고 안되고의 차이가 있기 때문에 브라우저 접두사를 붙여서 사용한다. 이를 <strong>prefix</strong>라고 한다.</p><p>-webkit- (사파리, 크롬), -moz-(모질라, 파이어폭스), -o-(오페라), -ms-(IE)</p><pre><code>-webkit-column-count:3;</code></pre><p>앞에 접두사를 붙이고 속성을 사용하면 된다.</p><p>근데 귀찮다.(매우매우) 그래서 유용한 사이트를 소개하자면</p><a href="http://leaverou.github.io/prefixfree/" target="_blank" rel="noopener">prefix-free</a><p>에서 Only 2kb gzipped에서 js 파일을 받아 폴더에 넣어 script태그로 연결해주면 된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;왜-css인가&quot;&gt;&lt;a href=&quot;#왜-css인가&quot; class=&quot;headerlink&quot; title=&quot;왜 css인가?&quot;&gt;&lt;/a&gt;왜 css인가?&lt;/h1&gt;&lt;p&gt;웹 문서에 텍스트만 있다면 어떤 느낌일 것 같은가? 물론 기존 html로 기초적인 스타
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS3" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS3/"/>
    
    
      <category term="css,css3,css basic" scheme="http://rootjang92.github.io/tags/css-css3-css-basic/"/>
    
  </entry>
  
  <entry>
    <title>Todo app 만들기</title>
    <link href="http://rootjang92.github.io/2018/09/12/todo/"/>
    <id>http://rootjang92.github.io/2018/09/12/todo/</id>
    <published>2018-09-12T01:55:37.000Z</published>
    <updated>2018-09-12T01:58:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Todo-프로젝트-만들기"><a href="#Todo-프로젝트-만들기" class="headerlink" title="Todo 프로젝트 만들기."></a>Todo 프로젝트 만들기.</h1><p>이 프로젝트는 ES5와 ES6를 이용하여 만들었습니다. 그 외 Angular를 활용한 코드도 깃허브에 있으니 참조하여 보시면 감사하겠습니다.</p><div class="video-container"><iframe src="//www.youtube.com/embed/roupTOK6ZYo" frameborder="0" allowfullscreen></iframe></div><a href="https://github.com/Rootjang92/todos" target="_blank" rel="noopener">깃허브페이지</a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Todo-프로젝트-만들기&quot;&gt;&lt;a href=&quot;#Todo-프로젝트-만들기&quot; class=&quot;headerlink&quot; title=&quot;Todo 프로젝트 만들기.&quot;&gt;&lt;/a&gt;Todo 프로젝트 만들기.&lt;/h1&gt;&lt;p&gt;이 프로젝트는 ES5와 ES6를 이용하여 만
      
    
    </summary>
    
      <category term="Project" scheme="http://rootjang92.github.io/categories/Project/"/>
    
      <category term="todo" scheme="http://rootjang92.github.io/categories/Project/todo/"/>
    
    
      <category term="todo,todolist,front-end" scheme="http://rootjang92.github.io/tags/todo-todolist-front-end/"/>
    
  </entry>
  
  <entry>
    <title>프로토타입 체이닝</title>
    <link href="http://rootjang92.github.io/2018/09/11/jsprotochain/"/>
    <id>http://rootjang92.github.io/2018/09/11/jsprotochain/</id>
    <published>2018-09-11T05:40:20.000Z</published>
    <updated>2018-09-11T06:54:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="프로토타입-체이닝"><a href="#프로토타입-체이닝" class="headerlink" title="프로토타입 체이닝"></a>프로토타입 체이닝</h1><p>자바스크립트는 <strong>프로토타입 기반 객체지향 언어</strong>이다. 자바스크립트를 이해하기 위해서 무조건 알아가야 할 개념 중 하나가 이 프로토타입이다.<br>그래서 오늘은 상속의 개념을 구현하는 프로토타입과 프로토타입 체이닝에 대해 글을 써보려고 한다.</p><p>가장 중요한 건 <strong>자신을 생성한 생성자 함수의 prototype 프로퍼티가 가리키는 프로토타입 객체를 자신의 부모로 설정하는 [[prototype]]링크로 연결한다.</strong> 이다.</p><pre><code>function Person(name) {  this.name = name;}var foo = new Person(&apos;Jang&apos;);console.dir(Person);console.dir(foo);</code></pre><p>이 코드는 그림 한장으로 설명할 수 있다.</p><p><img src="https://poiemaweb.com/img/constructor_function_prototype_chaining.png" alt="프로토타입"></p><p>결국 prototype 프로퍼티나 [[prototype]]은 같은 객체를 가리키고 있다는 걸 알 수 있다.<br>즉, 객체를 생성하는 건 생성자 함수가 하지만 그 부모 역할을 하는 건 생성자의 prototype 프로퍼티가 가리키는 <strong>프로토타입 객체</strong>이다.</p><h2 id="객체-리터럴로-생성된-객체의-프로토타입-체이닝"><a href="#객체-리터럴로-생성된-객체의-프로토타입-체이닝" class="headerlink" title="객체 리터럴로 생성된 객체의 프로토타입 체이닝"></a>객체 리터럴로 생성된 객체의 프로토타입 체이닝</h2><p>프로토타입 체이닝이란 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티를 사용할 수 있는 것을 말한다.</p><pre><code>var myObj = {  name: &apos;Jang&apos;,  sayName: function() {    console.log(&apos;My name is &apos; + this.name);  }};myObj.sayName();console.log(myObj.hasOwnProperty(&apos;name&apos;));console.log(myObj.hasOwnProperty(&apos;nickName&apos;));myObj.sayNickname();</code></pre><p>출력결과</p><blockquote><p>My name is Jang<br>true<br>false<br>TypeError: myObj.sayNickname is not a function</p></blockquote><p>hasOwnProperty() 메서드는 호출한 객체에 인자로 넘긴 문자열 으림의 프로퍼티나 메서드가 있는지 체크하는 API 함수이다.<br>myObj에는 name 프로퍼티가 있기 때문에 true가 출력되었다. 하지만 myObj에서 hasOwnProperty()를 사용할 수 있는 이유는 [[prototype]] 링크로 연결된 Object.prototype 객체에 hasOwnProperty() 메서드가 존재하기 때문이다.</p><p>결국 프로토타입 체이닝은 해당 객체에 접근하려는 프로퍼티나 메서드가 없다면 <strong>[[prototype]]링크를 따라서 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티를 차례대로 검색하는 것</strong>을 말한다.</p><h2 id="생성자-함수로-생성된-객체의-프로토타입-체이닝"><a href="#생성자-함수로-생성된-객체의-프로토타입-체이닝" class="headerlink" title="생성자 함수로 생성된 객체의 프로토타입 체이닝"></a>생성자 함수로 생성된 객체의 프로토타입 체이닝</h2><pre><code>function Person(name, age, hobby) {  this.name = name;  this.age = age;  this.hobby = hobby;}var foo = new Person(&apos;Jang&apos;, 27, &apos;Soccer&apos;);console.log(foo.hasOwnProperty(&apos;name&apos;));console.dir(Person.prototype);</code></pre><p>출력결과</p><blockquote><p>true<br>Person {}(Object)</p></blockquote><p>Person() 함수가 생성한 foo 객체의 프로토타입 객체는 Person.prototype이 된다. 하지만 Person.prototype에는 hasOwnProperty 메서드가 없다. 하지만 결과값은 true가 나오는데 그 이유는 프로토타입 체이닝의 종점인 Object.prototype 객체에 존재하기 떄문이다.<br>Person.prototype 역시 객체이기 때문에 <strong>Object.prototype을 프로토타입 객체로 가진다.</strong></p><p><img src="https://poiemaweb.com/img/constructor_function_prototype_chaining.png" alt="프로토타입체이닝"></p><h2 id="기본-데이터-타입-확장"><a href="#기본-데이터-타입-확장" class="headerlink" title="기본 데이터 타입 확장"></a>기본 데이터 타입 확장</h2><p>숫자, 문자열, 배열 등이 사용하는 표준 메서드는 그들의 프로토타입에 정의되어 있다. 또한 기본 내장 프로토타입도 Object.prototype을 자신의 프로토타입으로 가지고 있다.(알면 알수록 놀랍습니다…) 또한 자바스크립트는 표준 빌트인 프로토타입 객체에도 사용자가 직접 정의한 메서드를 추가할 수 있다.</p><pre><code>String.prototype.testMethod = function() {  console.log(&apos;Testing method in String.prototype.testMethod()&apos;);};var str = &quot;this is test&quot;;str.testMethod();console.dir(String.prototype);</code></pre><p>출력 결과</p><blockquote><p>Testing method in String.prototype.testMethod()<br>{ [String: ‘’] testMethod: [Function] }</p></blockquote><p>구글 크롬의 브라우저 출력화면을 보면 다양한 메서드가 쭉 나오는데 testMethod가 추가된 것을 볼 수 있을 것이다.(꼭 해보시길!)</p><h2 id="프로토타입-메서드와-this"><a href="#프로토타입-메서드와-this" class="headerlink" title="프로토타입 메서드와 this"></a>프로토타입 메서드와 this</h2><p>앞에서 봤던 <a href="https://rootjang92.github.io/2018/09/10/jsfuncthis">객체의 메서드를 호출할 때 this바인딩</a><br>의 규칙과 같다. 그 메서드를 호출한 객체에 바인딩 된다.</p><h2 id="디폴트-프로토타입"><a href="#디폴트-프로토타입" class="headerlink" title="디폴트 프로토타입"></a>디폴트 프로토타입</h2><p>디폴트 프로토타입은 한 마디로 함수가 생성될 때 같이 생성된다. 자바스크립트에서는 이러한 디폴트 프로토타입을 다른 일반 객체로 변환할 수 있다.<br>단, 변경된 시점에서 생성된 객체들은 변경된 프로토타입 객체로 [[prototype]] 링크를 연결한다.</p><pre><code>function Person(name) {  this.name = name;}console.log(Person.prototype.constructor); // 1var foo = new Person(&apos;Jang&apos;);console.log(foo.country); // 2Person.prototype = {  country : &apos;Republic of Korea&apos;};console.log(Person.prototype.constructor); //3var bar = new Person(&apos;Lee&apos;);console.log(foo.country); //4console.log(bar.country); //5console.log(foo.constructor); //6console.log(bar.constructor); //7</code></pre><p>출력결과</p><blockquote><p>[Function: Person] // 1<br>undefined // 2<br>[Function: Object] // 3<br>undefined // 4<br>Republic of Korea // 5<br>[Function: Person] // 6<br>[Function: Object] // 7</p></blockquote><p>2번을 살펴보자 foo 객체에는 country 프로퍼티가 없고 Person.prototype객체도 마찬가지이다. 체이닝이 일어나도 결국 undefined<br>3번을 살펴보자 country라는 프로퍼티를 가진 객체로 변화시켰다. 그 결과로 이 객체에는 constructor가 존재하지 않는다. 일반 객체로 변화했기 때문이다. 일반 객체는 Object.prototype 객체로 프로토타입 체이닝이 발생하고 그 결과 그 constructor는 Object로 출력된다.<br>또한 생성된 bar 프로퍼티도 새로 변경된 프로토타입 객체를 가리킨다. 그렇기 때문에 서로 다른 결과값이 발생하는 것이다.</p><p><img src="https://poiemaweb.com/img/changing_prototype.png" alt="디폴트"></p><h2 id="주의할-점"><a href="#주의할-점" class="headerlink" title="주의할 점"></a>주의할 점</h2><p>프로토타입은 특정 프로퍼티를 <strong>읽거나</strong>, <strong>메서드를 실행할 때</strong> 발생한다. 다른 객체에 있는 특정 프로퍼티를 쓰려고 할 때에는 프로토타입 체이닝이 동작하지 않고 동적으로 프로퍼티를 생성한다.</p><pre><code>function Person(name) {  this.name = name;}Person.prototype.country = &apos;Republic of Korea&apos;;var foo = new Person(&apos;foo&apos;);var bar = new Person(&apos;bar&apos;);console.log(foo.country);console.log(bar.country);foo.country = &apos;USA&apos;;console.log(foo.country);console.log(bar.country);</code></pre><p>출력결과</p><blockquote><p>Republic of Korea<br>Republic of Korea<br>USA<br>Republic of Korea</p></blockquote><p>foo.country 값에 ‘USA’를 지정하면 foo 객체 자체에 country 프로퍼티가 동적으로 생성된다. 그래서 bar 객체는 프로토타입 체이닝을 거쳐 ‘Republic of korea’가 출력된다.</p><p>다음 시간에는 실행 컨텍스트와 클로저에 대해 알아보겠습니다!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;프로토타입-체이닝&quot;&gt;&lt;a href=&quot;#프로토타입-체이닝&quot; class=&quot;headerlink&quot; title=&quot;프로토타입 체이닝&quot;&gt;&lt;/a&gt;프로토타입 체이닝&lt;/h1&gt;&lt;p&gt;자바스크립트는 &lt;strong&gt;프로토타입 기반 객체지향 언어&lt;/strong&gt;이
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="Javascript, JS prototype, prototype chain" scheme="http://rootjang92.github.io/tags/Javascript-JS-prototype-prototype-chain/"/>
    
  </entry>
  
  <entry>
    <title>Input 태그</title>
    <link href="http://rootjang92.github.io/2018/09/10/htmlinput/"/>
    <id>http://rootjang92.github.io/2018/09/10/htmlinput/</id>
    <published>2018-09-10T06:30:48.000Z</published>
    <updated>2018-09-11T05:39:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="태그"><a href="#태그" class="headerlink" title=" 태그"></a><input> 태그</h1><h2 id="Input-태그란"><a href="#Input-태그란" class="headerlink" title="Input 태그란?"></a>Input 태그란?</h2><p>Input 태그는 기본적으로 입력 항목을 만드는 태그다.<br>체크박스 등의 클릭하는 버튼도 input 태그를 활용해 만든다.<br>원래는 form 태그 안에 속해야 하지만 ajax통신에서는 그러지 않아도 된다.</p><ul><li>id 속성을 사용하면 label 태그를 사용할 수 있다.</li></ul><ul><li>Input 태그의 type 속성에 사용 하는 유형.<a href="http://aboooks.tistory.com/294" target="_blank" rel="noopener">input type태그속성</a></li></ul><p>하지만 브라우저마다 지원이 다르기 때문에 이 사이트를 참조하여 얼마나 지원하는 지 알아보면 좋다.</p><a href="http://caniuse.com" target="_blank" rel="noopener">브라우저지원확인</a><h2 id="Input-태그-사용하기"><a href="#Input-태그-사용하기" class="headerlink" title="Input 태그 사용하기."></a>Input 태그 사용하기.</h2><ul><li><p>type=”hidden”<br>히든필드는 관리자가 알아야 할 정보를 입력할 때 사용합니다. 그렇기 떄문에 사용자에게는 보이지 않는다.(view상에서)</p>  <input type="hidden" name="이름" value="서버로 넘길 값"></li></ul><ul><li><p>type=”text”<br>텍스트 필드를 만들 때 사용한다. 폼에서 가장 많이 사용한다고 볼 수 있다.</p><p>  &lt;input type=”text” [속성=”속성값”]&gt;</p></li></ul><p>속성에는 name, size(필드 길이 지정), value(화면에 표실될 내용), maxlength(최대 길이)가 있다.</p><ul><li><p>type=”password”<br>비밀번호를 입력하는 창을 만들 때 사용한다.</p><p>  &lt;input type=”password” [속성=”속성값”]&gt;</p></li></ul><ul><li>type=”search”,”url”,”email”,”tel”</li></ul><p>각각, 검색 상자, URL 입력, 메일 주소 입력, 전화번호 입력 창을 만들 때 사용한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/j269fowt/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>type=”number”</li></ul><p>사용자가 입력한 내용을 숫자로 인식하는 창이다. 스핀 박스를 사용해 갯수를 조정할 수 있다.</p><ul><li>type=”range”</li></ul><p>슬라이드 막대로 범위를 지정할 수 있다. 이 속성은 브라우저 지원 버전을 확인 후 사용하여야 한다.</p><p>number, range모두 min,max,step(짝수,홀수 등 특정 숫자 지정),value 속성을 사용할 수 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/mk0jtfw6/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>type=”radio”, “checkbox”</li></ul><p>라디오 버튼과 체크박스 버튼을 생성한다. 이 둘은 여러항목 중 자신이 원하는 항목을 선택할 때 사용한다.<br>한 개만 선택할 경우 라디오 버튼, 중복 체크가 가능하도록 할 때는 체크박스 버튼을 사용한다.</p><p>속성으로는 name, value, checked(기본으로 선택해 놓을 화면) 속성이 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/wyLp1r2h/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>type=”color”</li></ul><p>색상을 선택할 수 있게 창을 만들어준다. 색상은 16진수로 표시되기 때문에 텍스트로 색상을 선택할 수는 없다.</p><pre><code>&lt;input type=&quot;color&quot; value=&quot;기본색&quot;&gt;</code></pre><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/go9jw6br/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>type=”date”, “month”, “week”</li></ul><p>날짜를 표시하는 속성이다.</p><pre><code>&lt;input type=&quot;date | month | week&quot; [value=&quot;기본값&quot; 속성=&quot;속성값&quot;]&gt;</code></pre><p>date로 지정하면 yyyy-mm-dd 형식으로 month는 yyyy-mm, week는 yyyy-w24로 표시된다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/5347u2xz/embedded/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>type=”time”,”datetime”,”datetime-local”</li></ul><p>시간 지정하는 속성이다. 시간을 지정할 때는 time, 날짜와 시간은 datetime,datetime-local을 사용하면 된다.<br>min,max,step,value를 사용할 수 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/yb63w1df/1/embedded/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>type=”submit”,”reset”</li></ul><p>서버 전송과 리셋하기 버튼이다. submit은 서버로 전송하는 버튼으로 form태그에서 지정한 폼 처리 프로그램에 넘겨진다.</p><ul><li>type=”image”</li></ul><p>submit버튼 대신 전송 이미지를 넣을 수 있다.</p><ul><li>type=”button”</li></ul><p>폼 안에 버튼 형태를 만들 수 있다. 스크립트 함수를 넣어서 사용하여야 한다.</p><ul><li>type=”file”</li></ul><p>파일을 첨부할 수 있다.</p><h2 id="Input-태그-속성들"><a href="#Input-태그-속성들" class="headerlink" title="Input 태그 속성들"></a>Input 태그 속성들</h2><ul><li>autofocus</li></ul><p>원하는 요소에 입력 커서를 표시할 수 있다.</p><ul><li>placeholder</li></ul><p>텍스트를 입력할 때 힌트를 표시할 수 있다. 필드안에 그 속성에 어떠한 값을 입력해야 하는 지 알려줄 수 있다.</p><ul><li>readonly</li></ul><p>읽게만 만드는 창을 만들 때 사용하는 속성이다. true, false값을 지정해도 되고 readonly=”readonly”라고 적어도 된다.</p><ul><li>required 속성</li></ul><p>필수적으로 입력하여야 하는 곳에 사용한다.</p><ul><li>min,max,step 속성</li></ul><p>최솟값, 최대값, 허용 범위를 설정한다.</p><ul><li>size,minlength,maxlength</li></ul><p>텍스트 길이, 최솟값, 최대값을 설정한다.</p><h2 id="실습-상품-주문서-만들기"><a href="#실습-상품-주문서-만들기" class="headerlink" title="실습(상품 주문서 만들기)"></a>실습(상품 주문서 만들기)</h2><ul><li>이 예제는 Do it! HTML5 + CSS3 웹 표준의 정석 책을 참고하였습니다.</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/05pk3vqj/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;태그&quot;&gt;&lt;a href=&quot;#태그&quot; class=&quot;headerlink&quot; title=&quot; 태그&quot;&gt;&lt;/a&gt;&lt;input&gt; 태그&lt;/h1&gt;&lt;h2 id=&quot;Input-태그란&quot;&gt;&lt;a href=&quot;#Input-태그란&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="HTML" scheme="http://rootjang92.github.io/categories/HTML-CSS/HTML/"/>
    
    
      <category term="html, html input" scheme="http://rootjang92.github.io/tags/html-html-input/"/>
    
  </entry>
  
  <entry>
    <title>함수의 this</title>
    <link href="http://rootjang92.github.io/2018/09/10/jsfuncthis/"/>
    <id>http://rootjang92.github.io/2018/09/10/jsfuncthis/</id>
    <published>2018-09-10T05:15:07.000Z</published>
    <updated>2018-09-10T06:29:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><h2 id="this-1"><a href="#this-1" class="headerlink" title="this"></a>this</h2><ul><li>arguments 객체<br>자바스크립트는 인자의 갯수를 달리해도 오류가 발생하지 않는다. 넘겨지지 않은 인자는 undefined, 갯수가 많을 경우에는 무시된다.<br>이렇기 때문에 런타임 시 인자의 갯수를 확인하여 동작을 다르게 해줘야 하는데 이를 가능하게 하는 것이 arguments 객체이다.</li></ul><pre><code>function add(a,b) {  console.dir(arguments);  return a+b;}console.log(add(1));console.log(add(1,2));VM156:2Arguments(1)0: 1 callee: ƒ add(a,b) length: 1 Symbol(Symbol.iterator): ƒ values()__proto__: ObjectVM156:6 NaNVM156:2 Arguments(2)VM156:7 3</code></pre><p>arguments는 유사 배열 객체이기 때문에 length를 가지고 있다. 이를 활용한 함수를 구현하자면…</p><ul><li><p>예시<br>ㅡ</p><p>  function sum() {</p><pre><code>var res = 0;for(var i = 0; i &lt; arguments.length; i++) {  res += arguments[i];}return res;</code></pre><p>  }</p><p>  console.log(sum(1));<br>  console.log(sum(1,2,3,4,5,6,7,8,9));</p></li></ul><p>출력결과</p><blockquote><p>1<br>45</p></blockquote><h2 id="this-바인딩"><a href="#this-바인딩" class="headerlink" title="this 바인딩"></a>this 바인딩</h2><p>자바스크립트의 this는 타 언어와 달리 함수 호출 패턴에 따라 this가 참조하는 객체가 달라진다. (후…)</p><ul><li>객체 메서드 호출 시 this</li></ul><p>이 떄에는 <strong>해당 메서드를 호출한 객체</strong>로 바인딩 된다.</p><pre><code>var myObj = {  name: &apos;Jang&apos;,  sayName: function() {    console.log(this.name);  }};var Obj = {  name: &apos;Geun&apos;};Obj.sayName = myObj.sayName;myObj.sayName(); // 1Obj.sayName(); // 2</code></pre><p>출력결과</p><blockquote><p>Jang<br>Geun</p></blockquote><p>우리는 sayName()이 호출되는 지점을 봐야 한다. 이 메서드의 this는 자신을 호출한 객체로 바뀌기 때문에 1에서는 Jang이 2에서는 Geun이 출력되는 것이다.</p><ul><li>함수를 호출할 때 this</li></ul><p>이 때의 <strong>this는 전역 객체</strong>에 바인딩 된다. (브라우저의 경우 window 객체, 런타임 환경의 경우 global)</p><pre><code>var test = &apos;test&apos;;console.log(window.test);var sayBar = function() {  console.log(this.test);};sayBar();</code></pre><p>출력결과</p><blockquote><p>test<br>test</p></blockquote><p>test 변수는 전역 변수이기 때문에 window로 접근이 가능하다. 또한 sayBar 함수에서 this는 전역을 가리키기 때문에 window에 바인딩되어 test가 호출된다.</p><pre><code>var num = 100;var myObj = {  num: 1,  func1: function() {    this.num += 1;    console.log(&apos;func1() called. this.num : &apos; + this.num);    // func2    func2 = function() {      this.num += 1;      console.log(&apos;func2() called. this.num : &apos; + this.num);    }    func2();  }};myObj.func1();</code></pre><p>출력결과</p><blockquote><p>func1() called. this.num : 2<br>func2() called. this.num : 101</p></blockquote><p>우리가 생각했던 방식은 부모 요소의 객체와 같은 거라고 예상했기에 2,3이 떠야 하지만 결과는 2와 101이 떴다. 그 이유는 내부 함수의 호출 패턴을 지정하지 않았기 때문이다. 내부 함수의 this는 전역 객체에 바인딩되기 때문에 부모 함수의 this를 다른 변수에 저장해야 한다.</p><pre><code>var num = 100;var myObj = {  num: 1,  func1: function() {    var that = this;    this.num += 1;    console.log(&apos;func1() called. this.num : &apos; + that.num);    // func2    func2 = function() {      that.num += 1;      console.log(&apos;func2() called. this.num : &apos; + that.num);    }    func2();  }};myObj.func1();</code></pre><p>출력결과</p><blockquote><p>func1() called. this.num : 2<br>func2() called. this.num : 3</p></blockquote><p>this를 that 변수에 저장하여 내부함수가 부모 함수의 변수에 접근이 가능하게 만들었다.</p><ul><li>생성자 함수 호출 시 this</li></ul><p>복습하자면 생성자 함수는 기존 함수에 new 연산자를 붙이는 방법이다. 또한 함수 이름 첫 글자를 대문자로 쓰기를 권한다. 많은 책이나 블로그에서 중요하게 여기는 것이 생성자 함수의 this바인딩을 이해하기 위해선 생성자 함수의 동작 방식을 이해해야 한다고 설명하고 있다.</p><ol><li><p>빈 객체 생성 및 this 바인딩<br>이 빈 객체가 this로 바인딩 된다. 단 이 생성자 함수가 생성한 객체는 생성자 함수 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체로 설정한다.</p></li><li><p>this를 통해 프로퍼티 생성<br>this를 사용해서 생성된 빈 객체에 동적으로 프로퍼티나 메서드를 생성할 수 있다.</p></li><li><p>생성된 객체 리턴<br>일반적으로는 this에 바인딩된 새롭게 생성된 객체가 리턴된다.(일반 함수에서는 undefined) 그러나 다른 객체를 반환한다면 해당 객체가 리턴된다.</p></li></ol><pre><code>var Person = function (name) {  this.name = name;};var foo = new Person(&apos;Jang&apos;);console.log(foo.name);</code></pre><p>출력 결과</p><blockquote><p>Jang</p></blockquote><p>Person() 생성자 함수가 빈 객체를 생성하며 Person.prototype을 [[prototype]]링크로 연결하여 자신의 프로토타입으로 설정한다.<br>그러면서 this에 name이라는 동적 프로퍼티를 생성하여 리턴을 받환하여 foo 변수에 저장한다.</p><ul><li>객체 리터럴 방식과 생성자 함수의 차이점.</li></ul><p>둘의 가장 큰 차이점은 바로 프로토타입 객체다. 객체 리터럴은 Object(), 생성자 함수는 생성자함수 이름이 프로토타입 객체가 된다.<br>그 이유는 둘의 생성자가 다르기 때문이다. 객체 리터럴의 경우 생성자가 Object()이기 때문이다.</p><ul><li>call과 apply 메서드를 사용한 this</li></ul><p>이 방법은 명시적으로 this를 바인딩시키는 방법이다. 단 이 메서드들은 Function.prototype 객체의 메서드이다.</p><p>function.apply(thisArg, argArray)</p><p>주의할 점은 결국 apply() 메서드를 호출하는 것은 함수이고, 본질적인 기능이 함수 호출이라는 점이다. 첫번째 인자는 this에 바인딩할 객체를 가리키고 두 번째 인자는 함수를 호출할 때 넘길 인자들의 배열을 가리킨다.</p><pre><code>function Person(name, age, gender) {  this.name = name;  this.age = age;  this.gender = gender;}var foo = {};Person.apply(foo,[&apos;Jang&apos;, 27, &apos;man&apos;]);console.dir(foo);</code></pre><blockquote><p>Object age: 27 gender: “man” name: “Jang” <strong>proto</strong>: Object</p></blockquote><p>결론적으로 이 코드는 Person(‘Jang’,27,’man’) 함수를 호출하여 this를 foo 객체에 명시적으로 바인딩한 것이다.</p><p>이들을 활용하는 것의 장점은 유사 배열 객체에 배열 메서드를 사용하는 경우에 나타난다.</p><pre><code>function myFunction() {  console.dir(arguments);  // arguments.shift(); -&gt; error  var arg = Array.prototype.slice.apply(arguments);  // Array.prototype.slice() 메서드를 호출하고 this는 arguments객체에 할당해라.  console.dir(arg);}myFunction(1,2,3);</code></pre><p>출력결과</p><blockquote><p>[Arguments] { ‘0’: 1, ‘1’: 2, ‘2’: 3 }<br>[ 1, 2, 3 ]</p></blockquote><h2 id="함수-리턴"><a href="#함수-리턴" class="headerlink" title="함수 리턴"></a>함수 리턴</h2><p>함수는 항상 리턴값을 반환한다. 라는게 포인트이다. 만약 리턴문이 없다면 undefined값이 리턴된다.</p><ul><li>생성자 함수에서 리턴값을 지정하지 않으면 생성된 객체가 리턴된다.</li></ul><p>생성자 함수에서 별도의 리턴값을 지정하지 않으면 this에 바인딩된 객체가 리턴되기 때문에 일반적으로 리턴문을 사용하지 않는다.<br>만약 명시적으로 리턴값을 지정한다면 객체 외에 경우에는 리턴값을 무시하지만 객체를 지정할 경우 그 객체가 반환된다.</p><p>다음 시간에는 프로토타입 체이닝에 대해서 알아보겠습니다~!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;this&lt;/h1&gt;&lt;h2 id=&quot;this-1&quot;&gt;&lt;a href=&quot;#this-1&quot; class=&quot;headerlink&quot; title=&quot;this&quot;
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="Javascript, js, js this, this, prototype chain" scheme="http://rootjang92.github.io/tags/Javascript-js-js-this-this-prototype-chain/"/>
    
  </entry>
  
  <entry>
    <title>자바스크립트의 함수</title>
    <link href="http://rootjang92.github.io/2018/09/09/jsfunction/"/>
    <id>http://rootjang92.github.io/2018/09/09/jsfunction/</id>
    <published>2018-09-09T06:52:11.000Z</published>
    <updated>2018-09-10T05:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="함수란"><a href="#함수란" class="headerlink" title="함수란?"></a>함수란?</h1><h2 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h2><p>자바스크립트에서 가장 중요한 것이 무엇이냐고 했을 때 십중팔구는 <strong>함수</strong>를 이야기 할 것이다. 자바스크립트의 함수는 모듈화, 클로져, 객체 생성, 함수형 프로그래밍 지향에 있어서 정말 중요한 개념이고 잘 이해하여야 한다.(그런 의미에서 나는 아직 멀었다.)</p><h3 id="함수의-생성방법"><a href="#함수의-생성방법" class="headerlink" title="함수의 생성방법"></a>함수의 생성방법</h3><p>함수 생성방법은 객체 생성방법과 비슷하게 3가지가 있다. 함수 선언문, 함수 표현식, Function() 생성자 함수 이 세가지 이다.</p><ul><li>함수 리터럴</li></ul><p>계속 강조하지만 함수도 결국 객체이다.(일급 객체라서 중요하다!) 그렇기 때문에 함수 리터럴 방식이 존재한다.</p><pre><code>function multiply(x,y) {  return x * y;}</code></pre><p>함수 키워드, 함수 명, 매개변수 리스트로 구성되어 있다.</p><ul><li>함수 선언문</li></ul><p>함수 리터럴과 형태는 같지만 주의할 점은 <strong>반드시 함수명이 있어야 한다는 점이다.</strong></p><pre><code>function multiply(x,y) {  return x * y;}console.log(multiply(3,4));</code></pre><p>출력결과</p><blockquote><p>12</p></blockquote><ul><li>함수 표현식</li></ul><p>함수 표현식은 함수 리터럴로 함수를 생성하여 생성된 함수를 변수에 할당하는 형태이다.</p><pre><code>var mul = function (x,y) {  return x * y;}console.log(mul(3,4));</code></pre><p>출력결과</p><blockquote><p>12</p></blockquote><p>이렇게 이름이 없는 함수 형태를 익명함수라고 부른다. 즉 변수 mul을 통해 함수를 할당한 것을 익명 함수를 이용한 함수 표현식이라고 한다.<br>위 예제는 기명 함수 표현식으로도 가능하다. 다만 함수 표현식에서 사용된 함수 이름은 <strong>외부 코드에서의 참조</strong>가 불가능하다.</p><p>이를 활용해서 팩토리얼 함수를 만들어 보도록 하자.</p><pre><code>var factorial = function factorial(n) {  if ( n &lt;= 1) { return 1; }  return n * factorial(n-1);}console.log(factorial(3));console.log(factorial(1));</code></pre><p>출력결과</p><blockquote><p>6<br>1</p></blockquote><p>이는 재귀 호출을 이용한 방법으로 함수를 선언한 후 함수 내부에서 재귀호출하여 함수를 처리하였다.</p><ul><li>Function() 생성자 함수</li></ul><p>자바스크립트의 함수도 결국 Function()이라는 내장 생성 함수에서 생성된 것이다. (축약 표현일 뿐이다.)</p><pre><code>var add = new Function(&apos;x&apos;, &apos;y&apos;, &apos;return x + y&apos;);console.log(add(3,4));</code></pre><p>출력결과</p><blockquote><p>7</p></blockquote><h3 id="함수-호이스팅"><a href="#함수-호이스팅" class="headerlink" title="함수 호이스팅"></a>함수 호이스팅</h3><p>자바스크립트의 권위자 인 더글라스 크락포드는 함수 생성에서 함수 표현식만을 사용할 것을 권하고 있는 데 그 이유가 바로 호이스팅 때문이다.</p><pre><code>// 함수 호이스팅으로 인한 호출 가능.var res = square(5);function square(number) {  return number * number;}// TypeErrorvar res = square(5);var square = function(number) {  return number * number;}</code></pre><p>함수 표현식은 <strong>변수 호이스팅</strong>이 발생하기 때문에 함수 호이스팅 처럼 변수생성, 초기화, 할당이 한 번에 일어나는 것이 아니라 변수 호이스팅 처럼 생성과 초기화만 동시에 일어난다.<br>결론적으로 <strong>함수 호출 전에는 반드시 함수를 선언하여야 한다.</strong></p><h2 id="함수-객체"><a href="#함수-객체" class="headerlink" title="함수 = 객체"></a>함수 = 객체</h2><p>자바스크립트의 함수는 결국 <strong>객체</strong>이기 떄문에 일반 객체처럼 프로퍼티들을 가질 수 있다. 그렇기 때문에 위에서 설명한 것처럼 리터럴에 의한 생성, 변수나 배열 요소, 객체 프로퍼티 할당 가능, 함수의 인자로 전달 가능, 함수의 리털값으로 사용 가능, 동적으로 프로퍼티 생성 및 할당 가능 등 객체와 똑같이 적용된다.</p><p>위에 나열한 기능이 모두 가능하기 때문에 함수를 <strong>일급 객체</strong>라고 부르는 것이다.</p><ul><li>변수나 프로퍼티에 할당.</li></ul><p>함수도 변수나 프로퍼티에 할당할 수 있다.</p><pre><code>var foo = 100;var bar = function() { return 100; };console.log(bar());var obj = {};obj.baz = function () { return 200; };console.log(obj.baz());</code></pre><p>출력결과</p><blockquote><p>100<br>200</p></blockquote><ul><li>함수 인자로 전달.</li></ul><p>다른 함수의 인자로 전달 가능하다.</p><pre><code>var foo = function(func) {  func();};foo(function() {  console.log(&apos;kkk&apos;);});</code></pre><p>출력결과</p><blockquote><p>kkk</p></blockquote><ul><li>리턴값으로 활용</li></ul><p>다른 함수의 리턴값으로도 활용할 수 있다.</p><pre><code>var a = function() {  return function() {    console.log(&apos;apple&apos;)  };};var b = a();b();</code></pre><p>출력결과</p><blockquote><p>apple</p></blockquote><p>변수 b에 함수 a를 호출하면 리턴값으로 전달되는 함수가 b 변수에 저장되어 apple이 출력된다.</p><ul><li>기본 프로퍼티</li></ul><p>정말 중요하다. <strong>함수는 객체다.</strong> (일급객체) 또한 함수 객체만의 프로퍼티를 가지고 있다. 크롬 검사도구에서 함수를 살펴보면 arguments,caller, length 등과 같은 프로퍼티가 보인다는 것을 알 수 있다. (console.dir로 호출해 보시길)<br>또한 객체이기 때문에 prototype을 갖는다. 함수 객체의 프로토타입은 <strong>Function.prototype</strong> 객체이다.</p><ul><li>prototype과 [[prototype]]</li></ul><p>이 둘은 많이 헷갈릴 수 있는 개념이다. 하지만 둘은 엄연히 다른 개념이다. 물론 두 프로퍼티가 모두 프로토타입 객체를 가리킨다. 하지만 <strong>보는 관점</strong>에서 차이가 있다.</p><ol><li><p>[[prototype]]<br>객체 입장에서 자신의 부모 역할을 수행하는 프로토타입 객체를 가리킨다.</p></li><li><p>prototype<br>함수가 생성자일 때 <strong>함수를 통해 생성된 객체의 부모 역할을 하는 개체</strong>를 가리킨다. 그래서 함수를 생성할 때 만들어지고 constructor 프로퍼티 하나만 있는 객체를 말한다.</p></li></ol><p><img src="https://poiemaweb.com/img/object_literal_prototype_chaining.png" alt="프로토타입"></p><h2 id="함수-형태"><a href="#함수-형태" class="headerlink" title="함수 형태"></a>함수 형태</h2><ul><li>콜백 함수<br>익명 함수가 사용되는 대표적인 용도가 콜백함수이다. 콜백 함수는 어떤 이벤트가 발생했을 때 시스템에서 호출되는 함수이다.<br>대표적인 예로 이벤트 핸들러 처리가 있다.</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/7drpbwmL/embedded/js,html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li><p>즉시 실행 함수<br>Immediate function은 정의와 동시에 출력되는 함수이다.</p><p>  (function (name) {</p><pre><code>console.log(&apos;welcome -&gt; &apos; + name);</code></pre><p>  })(‘Jang’);</p></li></ul><p>출력결과</p><blockquote><p>welcome -&gt; Jang</p></blockquote><p>즉시시행함수는 바로 시행되지만 다시 호출할 수 없기 때문에 한 번만 실행하는 초기화 실행 같은 코드에 적합하다.<br>(추후에 즉시실행함수에 대해 한 번 다뤄보도록 하겠습니다.)</p><ul><li><p>내부 함수<br>자바스크립트 함수는 내부에서도 함수를 정의할 수 있다. 이를 내부함수라고 한다.</p><p>  function parent() {</p><pre><code>var a = 100;var b = 200;function child() {  var b = 300;  console.log(a);  console.log(b);}child();</code></pre><p>  }<br>  parent();<br>  child();</p></li></ul><p>출력결과</p><blockquote><p>100<br>300<br>ReferenceError: child is not defined</p></blockquote><p>100이 출력되는 이유는 스코프 체이닝에 의해서 child함수의 부모인 parent 함수에서 변수 a의 값을 찾았기 때문에 가능한 것이다.<br>또한 내부 함수는 자신을 둘러싼 외부 함수에서 접근이 가능하지만 그 내부에서만 호출이 가능하기 때문에 레퍼런스 에러가 발생했다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;함수란&quot;&gt;&lt;a href=&quot;#함수란&quot; class=&quot;headerlink&quot; title=&quot;함수란?&quot;&gt;&lt;/a&gt;함수란?&lt;/h1&gt;&lt;h2 id=&quot;함수&quot;&gt;&lt;a href=&quot;#함수&quot; class=&quot;headerlink&quot; title=&quot;함수&quot;&gt;&lt;/a&gt;함수&lt;/h2&gt;
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="js, javascript, javascript function, 자바스크립트 함수" scheme="http://rootjang92.github.io/tags/js-javascript-javascript-function-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%95%A8%EC%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Form 태그에 대하여</title>
    <link href="http://rootjang92.github.io/2018/09/09/htmlform/"/>
    <id>http://rootjang92.github.io/2018/09/09/htmlform/</id>
    <published>2018-09-09T06:15:24.000Z</published>
    <updated>2018-09-09T06:51:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML-폼-태그에-대하여"><a href="#HTML-폼-태그에-대하여" class="headerlink" title="HTML 폼 태그에 대하여"></a>HTML 폼 태그에 대하여</h1><p>폼 태그란 특정 형식에 사용자가 무언가를 입력하는 형태로 이루어져 있다. 로그인이나 회원가입 창이 그 예이다.<br>웬만한 페이지에서는 형식에 구해받지 않고 이런 폼 태그를 볼 수 있다. 우리가 많이 사용하는 SNS에서도 회원가입을 하기 위해서 입력하는 정보들도 폼이다.</p><p>로그인을 예로 들면 우리가 클라리언트에서 정보를 입력하여 서버로 보내면 그 서버에서 DB를 확인하여 다시 보내주는 형태로 반응한다. 그 방법에는 여러가지가 있는데 흔히 ASP, PHP, JSP등을 사용할 수도 있고 최근 라이브러리나 프레임워크를 사용하면서 axios나 rxjs등의 여러가지 형태로도 가능하다.</p><h2 id="폼태그"><a href="#폼태그" class="headerlink" title="폼태그"></a>폼태그</h2><pre><code>&lt;form [속성=&quot;속성값&quot;]&gt;&lt;/form&gt;</code></pre><p>폼 택의 기본적인 형태는 이렇다. 하지만 그 속성은 정말 다양하게 존재한다.</p><ul><li><p>method<br>서버 쪽에 넘겨줄 <strong>방법</strong>을 지정하는 속성이다. 보통 get, post를 사용하는 데 get은 url자체에 담아서 넘겨줘 데이터 용량에 제한이 있지만 우리가 보통 사용하는 post 방식은 표준 입력으로 제한이 없고 정보가 노출되지 않는다.</p></li><li><p>name<br>폼의 이름을 지정한다.</p></li><li><p>action<br>서버 상의 프로그램을 지정한다.</p></li><li><p>target<br>스크립트 파일을 현재창에 띄울 지 다른 위치에서 열지 지정한다.</p></li><li><p>autocomplete<br>자동완성 속성이다. 우리가 검색창에서 어떤 검색어를 입력할 때 자동완성 되는 경험을 해본 적이 있을 것이다. 기본값은 on으로 지정되어 있다.</p></li></ul><h2 id="label-태그"><a href="#label-태그" class="headerlink" title="label 태그"></a>label 태그</h2><pre><code>&lt;label [속성=&quot;속성값&quot;]&gt;&lt;/label&gt;</code></pre><p>label 태그는 폼 요소에 레이블을 붙이기 위한 태그이다. 직접 텍스트를 입력할 수도 있고 for 속성을 사용하여 지정할 수도 있다. 또한 라벨 태그를 input 태그에 checkbox나 radio 버튼과 연결하면 텍스트를 클릭해도 항목이 클릭되게 만들 수도 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/zx4heatq/2/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="fieldset과-legend-태그"><a href="#fieldset과-legend-태그" class="headerlink" title="fieldset과 legend 태그"></a>fieldset과 legend 태그</h2><p>이 두 태그는 폼 요소를 그룹으로 묶을 때 사용한다. 이 태그를 사용하면 하나의 그룹으로 묶고 외곽선을 그려준다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/nwxmroj0/5/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="input-태그"><a href="#input-태그" class="headerlink" title="input 태그"></a>input 태그</h2><p>쉽게 말해서 우리가 입력할 수 있는 <strong>텍스트 상자</strong>나 <strong>로그인 버튼</strong> 등을 만들어 내는 태그가 바로 input 태그이다.</p><pre><code>&lt;input type=&quot;유형&quot; [속성=&quot;속성값&quot;]&gt;</code></pre><p>위 예제에서 봤듯이 input태그에서 id 속성을 사용하면 label 태그를 통해 속성을 붙이기도 하고 css에서도 사용할 수 있다.</p><a href="http://aboooks.tistory.com/294" target="_blank" rel="noopener">input태그 속성</a><p>다음 시간에는 input 태그의 사용법에 대해서 예제와 함께 살펴보도록 하겠습니다. (찡긋)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTML-폼-태그에-대하여&quot;&gt;&lt;a href=&quot;#HTML-폼-태그에-대하여&quot; class=&quot;headerlink&quot; title=&quot;HTML 폼 태그에 대하여&quot;&gt;&lt;/a&gt;HTML 폼 태그에 대하여&lt;/h1&gt;&lt;p&gt;폼 태그란 특정 형식에 사용자가 무언가를
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="HTML" scheme="http://rootjang92.github.io/categories/HTML-CSS/HTML/"/>
    
    
      <category term="HTML, html, html form, form tag" scheme="http://rootjang92.github.io/tags/HTML-html-html-form-form-tag/"/>
    
  </entry>
  
  <entry>
    <title>프로토타입과 배열 그리고 연산자</title>
    <link href="http://rootjang92.github.io/2018/09/05/jsprototype/"/>
    <id>http://rootjang92.github.io/2018/09/05/jsprototype/</id>
    <published>2018-09-05T07:27:24.000Z</published>
    <updated>2018-09-05T08:48:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="프로토타입"><a href="#프로토타입" class="headerlink" title="프로토타입"></a>프로토타입</h2><p>자바스크립트의 모든 객체는 자신의 부모 역할을 하는 객체와 연결되어 있다. 이를 통해 자바스크립트에서는 상속 개념을 구현할 수 있다. 이를 프로토타입 객체라고 한다.</p><pre><code>var foo = {  name: &apos;Jang&apos;,  age: 27};console.log(foo.toString());console.dir(foo);</code></pre><p>코드를 한 번 살펴보자. 사실상 1번 콘솔로그에서 toString이라는 메서드가 없어 오류가 발생해야 하지만 정상적으로 작동한다.<br>즉, foo 객체의 부모 역할을 하는 프로토타입에 toString() 메서드가 이미 정의되어 있기 때문에 호출이 가능한 것이다.</p><p>출력결과</p><blockquote><p>[object Object]<br>{ name: ‘Jang’, age: 27 }</p></blockquote><p>즉 모든 객체는 자신의 프로토타입을 가리키는 [[Prototype]]이라는 숨겨진 프로퍼티를 가진다. (크롬 브라우저의 <code>_proto_</code>)<br>여기서 foo 객체는 자신의 부모 객체를 <code>_proto_</code>라는 내부 프로퍼티로 연결하고 있다.<br>자세한 내용은 프로토타입 체이닝에서 더 다루겠지만, 결론적으로 객체 리터럴로 생성한 객체의 경우 Object.prototype 객체가 프로토타입 객체이다.</p><h2 id="배열"><a href="#배열" class="headerlink" title="배열"></a>배열</h2><ul><li><p>배열 리터럴<br>배열 리터럴은 ‘[]’를 사용해서 배열을 만든다.</p><p>  var colorArr = [‘orange’, ‘red’, ‘yellow’, ‘green’];<br>  console.log(colorArr[0]);<br>  console.log(colorArr[1]);</p></li></ul><p>출력결과</p><blockquote><p>orange<br>red</p></blockquote><p>배열은 인덱스 값으로 접근할 수 있다. 배열 내 인덱스는 0부터 시작한다. 즉 첫번째 값의 인덱스는 0인 것이다.</p><ul><li><p>배열 요소 생성<br>배열도 다른 객체와 마찬가지로 동적으로 배열 원소를 동적으로 추가할 수 있다.</p><p>  var empty = [];<br>  console.log(empty);</p><p>  empty[0] = 100;<br>  empty[3] = ‘four’;<br>  console.log(empty);<br>  console.log(empty.length);</p></li></ul><p>출력 결과</p><blockquote><p>[]<br>[ 100, undefined x 2, four ]<br>4</p></blockquote><p>자바스크립트의 배열은 인덱스 순서와 상관없이 할당이 가능하다. 값이 없다면 undefined가 뜬다.<br>또한 중요한 점은 <strong>자바스크립트가 배열의 크기를 배열 인덱스 중 가장 큰 값을 기준으로 정한다.</strong>는 것이다.<br>또한 length 프로퍼티를 이용하여 배열의 길이를 구할 수 있다. 배열의 길이 값은 가장 큰 인덱스에 +1을 한 값이다.(인덱스의 시작이 0 이기 때문이다.)</p><ul><li>length<br>길이값은 위에서 설명했지만, 중요한 것은 길이값을 명시적으로 변경할 수 있고 그 길이를 초과하는 값은 삭제된다는 점이다.<br>위 예제에서 empty의 length값은 4이지만 length값을 2로 설정하면,  100과 undefined를 제외한 뒤의 값은 삭제된다.</li></ul><ul><li>배열과 객체<br>배열과 객체는 모두 객체이지만 몇 가지 차이점이 있다. 우선 length 프로퍼티는 배열에만 존재한다. 두 번째로는 프로토타입의 차이이다.<br>일반 객체는 push와 같은 표준 배열 메서드를 사용할 수 없는데 둘의 프로토타입 체이닝에 의한 부모 프로토타입 객체가 서로 다르기 때문이다.</li></ul><blockquote><p>객체 - <code>_proto_</code> - Object.prototype<br>배열 - <code>_proto_</code> - Array.prototype - <code>_proto_</code> - Object.prototype</p></blockquote><h2 id="배열의-프로퍼티-열거"><a href="#배열의-프로퍼티-열거" class="headerlink" title="배열의 프로퍼티 열거"></a>배열의 프로퍼티 열거</h2><p>객체는 for in 문으로 객체를 열거할 수 있는데 배열은 for in문을 사용하면 불필요한 프로퍼티가 출력될 수 있으므로 for문을 사용하는 것이 좋다.</p><pre><code>var arr = [&apos;zero&apos;, &apos;one&apos;, &apos;two&apos;];console.log(arr.length);arr[3] = &apos;red&apos;;console.log(arr.length);for (var i = 0; i &lt; arr.length; i++) {  console.log(i, arr[i]);}</code></pre><p>출력 결과</p><blockquote><p>3<br>4<br>for문 결과값<br>0 ‘zero’<br>1 ‘one’<br>2 ‘two’<br>3 ‘red’</p></blockquote><h2 id="배열-요소-삭제"><a href="#배열-요소-삭제" class="headerlink" title="배열 요소 삭제"></a>배열 요소 삭제</h2><p>배열도 객체이므로 delete 연산자를 사용할 수 있지만, 이는 해당 요소를 undefined처리할 뿐이다. 그래서 배열에서는 splice()배열 메서드를 사용한다.</p><h2 id="splice-배열-메서드"><a href="#splice-배열-메서드" class="headerlink" title="splice() 배열 메서드"></a>splice() 배열 메서드</h2><p>splice(start, deleteCount, item…)</p><ul><li><p>start : 배열에서 시작 위치, deleteCount : 삭제할 요소의 수 item : 삭제할 위치에 추가할 요소<br>ㅡ</p><pre><code>var arr = [&apos;zero&apos;, &apos;one&apos;, &apos;two&apos;, &apos;three&apos;];arr.splice(2,1); // 1console.log(arr);console.log(arr.length);</code></pre></li></ul><p>즉 1의 의미는 arr배열의 2번째부터 1개 요소를 삭제하겠다는 의미이다. 즉 arr 요소에서 ‘two’가 삭제되는 것이다.</p><p>출력 결과</p><blockquote><p>[ ‘zero’, ‘one’, ‘three’ ]<br>3</p></blockquote><h2 id="Array-생성자-함수"><a href="#Array-생성자-함수" class="headerlink" title="Array() 생성자 함수"></a>Array() 생성자 함수</h2><p>배열은 배열 리터럴로 생성하지만 배열 리터럴도 결국 Array()생성자 함수로 배열을 생성하는 것을 단수화한 것이다.<br>생성자 함수로 배열을 생성할 때에는 new 연산자를 사용하여야 한다.</p><pre><code>var foo = new Array(3);console.log(foo);console.log(foo.length);var bar = new Array(1,2,3);console.log(bar);console.log(bar.length);</code></pre><p>호출할 때 인자가 1개이면 호출된 인자를 lenth로 갖는 빈 배열을 생성하고 그 외에는 호출된 인자를 요소로 같는다.</p><p>출력 결과</p><blockquote><p>[ undefined x 3]<br>3<br>[1,2,3]<br>3</p></blockquote><h2 id="유사-배열-객체"><a href="#유사-배열-객체" class="headerlink" title="유사 배열 객체"></a>유사 배열 객체</h2><p>length 프로퍼티는 배열의 동작에 있어서 정말 중요하다. 그런데 일반 객체에서도 length를 사용할 수 있는 경우가 있으니 이를 유사 배열객체라고 한다.</p><pre><code>var arr = [&apos;bar&apos;];var obj = { name: &apos;Jang&apos;, length : 1};arr.push(&apos;baz&apos;);console.log(arr);Array.prototype.push.apply(obj, [&apos;baz&apos;]);console.log(obj);</code></pre><p>원래의 경우라면 변수 obj에는 push()메서드를 사용할 수 없으나, apply() 메서드를 사용하면 객체라도 표준 배열 메서드를 사용할 수 있다.<br>후에 더 자세히 살펴볼 것이다. (call, apply 메서드)</p><p>출력 결과</p><blockquote><p>[ ‘bar’, ‘baz’ ]<br>{ ‘1’: ‘baz’, name: ‘Jang’, length: 2 }</p></blockquote><h2 id="기본-타입과-표준-메서드"><a href="#기본-타입과-표준-메서드" class="headerlink" title="기본 타입과 표준 메서드"></a>기본 타입과 표준 메서드</h2><p>기본 타입의 경우 어떻게 표준 메서드를 호출하는가? 자바스크립트에서는 기본값을 객체로 변화한 다음 각 타입의 표준 메서드를 불러온다.</p><h2 id="연산자"><a href="#연산자" class="headerlink" title="연산자"></a>연산자</h2><ul><li><ul><li>연산자</li></ul></li></ul><p>+연산자는 더하기 연산과 문자열 연결 연산을 수행한다. 두 연산자가 모두 숫자인 경우에는 더하기 연산을 실시한다.</p><ul><li>typeof 연산자</li></ul><p>피연산자의 타입을 문자열 형태로 리턴하는 연산자이다. 유의할 점은 null의 경우 object로 표시된다는 점(자바스크립트 개발단 오류)<br>함수는 function이라는 점에 유의하여야 한다.</p><ul><li>동등연산자와 일치연산자.</li></ul><p>동등연사자의 경우(==) 피연사자의 타입이 다를 경우 이를 변경하여 비교하고 일치연산자의 경우(===) 타입을 변경하지 않는다.</p><pre><code>console.log(1 == &apos;1&apos;) // trueconsole.log(1 === &apos;1&apos;) // false</code></pre><ul><li>!! 연산자</li></ul><p>!!연산자는 피연산자를 불리언값으로 변환한다. 값이 0이나 없다면 false, 그 외의 빈 객체, 배열, 문자열 등은 true로 표시된다.</p><p>다음 시간에는 <strong>함수와 프로토타입 체이닝</strong>에 대해서 알아보겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;프로토타입&quot;&gt;&lt;a href=&quot;#프로토타입&quot; class=&quot;headerlink&quot; title=&quot;프로토타입&quot;&gt;&lt;/a&gt;프로토타입&lt;/h2&gt;&lt;p&gt;자바스크립트의 모든 객체는 자신의 부모 역할을 하는 객체와 연결되어 있다. 이를 통해 자바스크립트에서는 
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="Javascript, js, es5, ES5, prototype, js prototype" scheme="http://rootjang92.github.io/tags/Javascript-js-es5-ES5-prototype-js-prototype/"/>
    
  </entry>
  
  <entry>
    <title>이미지와 하이퍼텍스트링크</title>
    <link href="http://rootjang92.github.io/2018/09/05/htmlimage/"/>
    <id>http://rootjang92.github.io/2018/09/05/htmlimage/</id>
    <published>2018-09-05T01:37:02.000Z</published>
    <updated>2018-09-05T07:26:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="이미지와-하이퍼텍스트-링크"><a href="#이미지와-하이퍼텍스트-링크" class="headerlink" title="이미지와 하이퍼텍스트 링크"></a>이미지와 하이퍼텍스트 링크</h1><h2 id="웹에서-사용되는-이미지-파일-형식은"><a href="#웹에서-사용되는-이미지-파일-형식은" class="headerlink" title="웹에서 사용되는 이미지 파일 형식은?"></a>웹에서 사용되는 이미지 파일 형식은?</h2><p>웹 페이지는 기본적으로 설명은 텍스트, 메뉴나 로고 등은 이미지로 처리 한다. 웹 페이지의 경우 크기가 작고 화질이 좋은 파일 형식을 사용하여야 하는데 웹에서 사용할 수 있는 파일 형식은 GIF, JPG/JPEG, PNG 파일이 있다.</p><a href="https://ko.wikipedia.org/wiki/%EC%9D%B4%EB%AF%B8%EC%A7%80_%ED%8C%8C%EC%9D%BC_%ED%98%95%EC%8B%9D" target="_blank" rel="noopener">이미지 파일 형식</a><h2 id="img-태그"><a href="#img-태그" class="headerlink" title="img 태그"></a>img 태그</h2><p>HTML에서 이미지를 삽입하는 태그는 <img> 태그이다. 이 때 src 속성을 사용하여 해당 이미지의 주소를 넣는다.</p><p><img src="./images/image.png" alt="img태그"></p><p>img 태그에는 src속성과 alt속성이 있는데 src는 해당 이미지의 주소, alt는 설명이 들어간다.<br>다시 돌아가 파일 경로에 대해 살펴보자. 내 컴퓨터에 있는 이미지를 사용한다면 그에 맞는 파일명, 다른 폴더에 있는 경우 하위 폴더와 함께 적어주면 된다. ‘/‘는 하위폴더를 나타낸다.(한단계 위는 ‘..’을 사용한다.)</p><p>웹 상의 이미지 또한 링크 주소를 받아 붙여넣을 수 있다. 해당 사이트가 닫히지 않는 이상 사용할 수 있다. 단 이 경우 저작권에 주의하여야 한다.</p><p>alt는 이미지를 설명하는 대체 텍스트를 달 때 사용하는 속성이다. 이를 사용할 경우 시각 장애인에게 화면 낭독기가 이미지를 설명해 줄 수 있다.</p><p>width, height 속성은 너비와 높이를 조정하는 속성이다.</p><h2 id="img의-기타-속성들"><a href="#img의-기타-속성들" class="headerlink" title="img의 기타 속성들"></a>img의 기타 속성들</h2><ul><li>figure, figcaption : 설명 속성 태그</li></ul><p>이미지에 설명을 함께 붙이고 싶을 때 사용하는 태그이다. figure태그는 설명 글을 붙일 대상을 지정합니다. 예를 들어 figure태그 안에 img태그와 figcaption태그를 넣게 되면 이미지 밑에 캡션이 달리게 됩니다.</p><h2 id="링크"><a href="#링크" class="headerlink" title="링크"></a>링크</h2><p>텍스트를 클릭하면 연결된 주소로 즉시 이동하게 하는 기능이 링크이다.</p><ul><li>a태그와 href 속성.</li></ul><p>사실상 링크에서 가장 중요한 두 요소이다. a태그를 이용하여 링크를 걸고 href 속성에 주소를 넣는다. 그 외에 속성으로는<br>target(링크한 내용이 표실될 위치, 현재 창 혹은 새 창), download(링크 다운로드), rel(관계 알리기), hreflang(링크한 문서 언어 설정), type(파일 유형)</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/2yv75k3u/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="SVG-이미지"><a href="#SVG-이미지" class="headerlink" title="SVG 이미지"></a>SVG 이미지</h2><p>최근 웹 브라우저에서 svg 파일을 지원하면서 아이콘이나 로고에 많이 사용되고 있다. 이미지를 확대, 축소해도 깨끗한 상태로 유지되는 것이 바로 벡터 이미지이고 그 확장자명이 svg이다.</p><p>다음 시간에는 폼 태그에 대해 다루겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;이미지와-하이퍼텍스트-링크&quot;&gt;&lt;a href=&quot;#이미지와-하이퍼텍스트-링크&quot; class=&quot;headerlink&quot; title=&quot;이미지와 하이퍼텍스트 링크&quot;&gt;&lt;/a&gt;이미지와 하이퍼텍스트 링크&lt;/h1&gt;&lt;h2 id=&quot;웹에서-사용되는-이미지-파일-형
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="HTML" scheme="http://rootjang92.github.io/categories/HTML-CSS/HTML/"/>
    
    
      <category term="HTML, html, HTML basic syntax, HTML hyperlink, html link" scheme="http://rootjang92.github.io/tags/HTML-html-HTML-basic-syntax-HTML-hyperlink-html-link/"/>
    
  </entry>
  
  <entry>
    <title>Object</title>
    <link href="http://rootjang92.github.io/2018/09/04/jsobject/"/>
    <id>http://rootjang92.github.io/2018/09/04/jsobject/</id>
    <published>2018-09-04T01:38:52.000Z</published>
    <updated>2018-09-05T01:36:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="객체-프로퍼티와-참조-그리고-프로토타입"><a href="#객체-프로퍼티와-참조-그리고-프로토타입" class="headerlink" title="객체 프로퍼티와 참조 그리고 프로토타입"></a>객체 프로퍼티와 참조 그리고 프로토타입</h1><h2 id="객체-프로퍼티-읽기와-쓰기-그리고-갱신"><a href="#객체-프로퍼티-읽기와-쓰기-그리고-갱신" class="headerlink" title="객체 프로퍼티 읽기와 쓰기 그리고 갱신"></a>객체 프로퍼티 읽기와 쓰기 그리고 갱신</h2><p>우선 프로퍼티에 접근하는 방법을 알아야 하는데 그 방법에는 대괄호 표기법과 마침표 표기법 두가지가 있다.</p><h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><pre><code>var foo = {  name : &apos;Jang&apos;,  major : &apos;Computer science&apos;};// 객체 프로퍼티 읽기console.log(foo.name);console.log(foo[&apos;name&apos;]);console.log(foo.nickname);foo.major = &apos;electronics Business&apos;;console.log(foo.major);console.log(foo[&apos;major&apos;]);foo.age = 27;console.log(foo.age);foo[&apos;full-name&apos;] = &apos;Jang Geun-ho&apos;;console.log(foo[&apos;full-name&apos;]);console.log(foo.full);</code></pre><p>출력 결과</p><blockquote><p>Jang<br>Jang<br>undefined<br>electronics Business<br>electronics Business<br>27<br>Jang Geun-ho<br>undefined</p></blockquote><p>마침표 표기법은 객체 다음에 마침표를 찍고 원하는 속성값을 적으면 된다. 대괄호 표기법은 객체의 프로퍼티를 문자열 형태로 만들어 대괄호 안에 넣으면 된다. 만약 문자화하지 않으면 값은 undefined가 나타난다.</p><p>또한 대괊호 표기법을 이용하여 기존 프로퍼티값을 갱신할 수 있다. 예제에서 살펴봤던 foo[‘major’]의 형태처럼 말이다.<br>JS의 특징 중 하나가 프로퍼티의 동적 생성인데 보시다시피 foo.age라는 프로퍼티는 아직 존재하지 않지만 이걸 동적으로 생성하여 27이라는 숫자값을 할당해준다.</p><p><strong>즉 기존에 있는 값은 갱신되고 없는 프로퍼터의 경우 동적 생성된 후 값이 할당된다는 의미이다.</strong></p><p>주의할 점은 연산자가 포함되있는 경우라면 <strong>대괄호 표기법</strong>을 사용하여야 한다는 것이다.<br>또한 객체 프로퍼티는 delete 연산자를 이용해 삭제할 수 있다. 단 delete 연산자는 프로퍼티만 삭제한다.</p><h3 id="예제2"><a href="#예제2" class="headerlink" title="예제2"></a>예제2</h3><pre><code>var foo = {  name : &apos;Jang&apos;,  major : &apos;Computer science&apos;};var prop;for (prop in foo) {  console.log(prop, foo[prop]);}</code></pre><p>출력결과</p><blockquote><p>name Jang<br>major Computer science</p></blockquote><p>for in 문을 이용해서 foo라는 개체에 루프를 돌렸다. prop 변수에 foo 객체의 프로퍼티가 하나씩 할당되면서 대괄호 표기법을 사용해 모든 요소가 출력된다.</p><h2 id="참조-타입의-특성"><a href="#참조-타입의-특성" class="headerlink" title="참조 타입의 특성"></a>참조 타입의 특성</h2><p>객체는 JS에서 참조 타입이라고 부른다. 객체의 연산은 참조값으로 처리가 되기 때문이다.</p><pre><code>var A = {  val : 40};var B = Aconsole.log(A.val);console.log(B.val);B.val = 50;console.log(A.val);console.log(B.val);</code></pre><p>A, B두 객체를 객체 리터럴 방식으로 생성해 보았다. 이 때 각 콘솔 로그의 값은 어떻게 찍힐까?</p><p>출력 결과</p><blockquote><p>40<br>40<br>50<br>50</p></blockquote><p>변수 A와 B는 동일한 객체를 가리키는 참조값을 가지기 때문에 B의 val 값을 50으로 변경하면 변수 A의 값도 변한다.<br>즉 <strong>A는 실제로 객체를 참조하는 값을 저장하는 것이지 실제 객체를 나타내지는 않는다</strong>는 점이다.<br><strong>A 객체는 참조 변수 A가 가리키는 객체!</strong></p><h2 id="객체-비교"><a href="#객체-비교" class="headerlink" title="객체 비교"></a>객체 비교</h2><p>JS에서의 동등 연산자(==)는 객체의 프로퍼티 값이 아니라 참조값을 비교한다.</p><pre><code>var a = 100;var b = 100;var objA = { value: 100 };var objB = { value: 100 };var objC = objBconsole.log(a == b);console.log(objA == objB);console.log(objB == objC);</code></pre><p>출력 결과를 예상해보자. 당연히 모두 true를 예상했겠지만(처음에는 저도…) 답은…</p><p>출력결과</p><blockquote><p>true<br>false<br>true</p></blockquote><p>변수 objA와 objB는 다른 참조값을 가진다. a,b처럼 기본 타입의 경우는 단순히 값을 비교하지만 객체의 경우 참조값을 비교하기 때문에 각각 다른 값을 참조하고 있는 두 변수는 동등 연산자를 사용했을 때 <strong>false</strong>가 나오는 것이다.</p><h2 id="함수-호출-방식"><a href="#함수-호출-방식" class="headerlink" title="함수 호출 방식."></a>함수 호출 방식.</h2><p>기본 타입과 참조 타입은 함수 호출 방식이 다르다.</p><ul><li><p>기본타입<br>call by value(값에 의한 호출) : 기본 타입의 값을 인자로 넘길 경우 호출된 함수의 매개변수로 <strong>복사된 값</strong>이 전달된다.<br>그렇기 때문에 함수 내 매개변수로 값을 변경해도 실제로 변수의 값은 변하지 않는다.</p></li><li><p>참조타입<br>call by reference(참조에 의한 호출) : 함수 호출 시 인자로 넘긴 객체의 참조값이 그대로 함수로 전달된다. 그렇기 때문에 함수 내부에서 참조값을 변경하면 실제 객체의 값도 변경된다.</p></li></ul><pre><code>var a = 100;var objA = { value: 100 };function changeArg(num, obj) {  num = 200;  obj.value = 200;  console.log(num);  console.log(obj);}changeArg(a, objA);console.log(a);console.log(objA);</code></pre><p>출력 결과</p><blockquote><p>200<br>{ value: 200 }<br>100<br>{ value: 200 }</p></blockquote><p>함수를 호출하면서 기본 타입인 변수 a의 값은 변화하지 않았지만, 객체 타입인 objA의 값은 변화하였다.</p><p><img src="https://poiemaweb.com/img/call-by-val&amp;ref.png" alt="value refer"></p><a href="https://poiemaweb.com/js-function" target="_blank" rel="noopener">참고자료</a><p>다음 시간에는 프로토타입과 배열에 대해 살펴보겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;객체-프로퍼티와-참조-그리고-프로토타입&quot;&gt;&lt;a href=&quot;#객체-프로퍼티와-참조-그리고-프로토타입&quot; class=&quot;headerlink&quot; title=&quot;객체 프로퍼티와 참조 그리고 프로토타입&quot;&gt;&lt;/a&gt;객체 프로퍼티와 참조 그리고 프로토타입&lt;/
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="Javascript, js, es5, ES5, object, js object" scheme="http://rootjang92.github.io/tags/Javascript-js-es5-ES5-object-js-object/"/>
    
  </entry>
  
  <entry>
    <title>목록을 생성하는 HTML 태그</title>
    <link href="http://rootjang92.github.io/2018/09/04/htmllist/"/>
    <id>http://rootjang92.github.io/2018/09/04/htmllist/</id>
    <published>2018-09-04T01:12:31.000Z</published>
    <updated>2018-09-04T08:14:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="목록을-생성하는-태그"><a href="#목록을-생성하는-태그" class="headerlink" title="목록을 생성하는 태그"></a>목록을 생성하는 태그</h1><p>HTML 문서를 작성할 때 많이 쓰이는 태그 중 하나가 바로 목록을 생성하는 태그다. 웹 표준이 정의화된 후에는 이미지나 텍스트에 구애받지 않고 어떤 것이든 목록화 시킬 수 있다. 특히 CSS를 적용한다면 메뉴나 본문 내용 등으로 사용할 수 있으니 table 태그가 거의 안쓰이는 이유가 되기도 했다.</p><h2 id="ul태그-li태그"><a href="#ul태그-li태그" class="headerlink" title="ul태그, li태그"></a>ul태그, li태그</h2><p>이 두 태그는 ‘순서 없는’ 목록을 만들 때 사용되는 태그이다. ul태그 안에 li태그를 사용하여 목록화 시킨다.</p><h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/ctfadnky/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="ol태그-li태그"><a href="#ol태그-li태그" class="headerlink" title="ol태그, li태그"></a>ol태그, li태그</h2><p>ol 태그는 순서가 필요한 목록을 만들 때 사용한다. ol은 타입을 지정할 수 있는데 1은 숫자를 나타내며 기본값으로 설정되어 있다.<br>그 외에 a(영소문자),A(영대문자),i(로마숫자 소문자),I(로마숫자 대문자)로 이루어져 있다. CSS로도 대체 가능하다.</p><h3 id="에제"><a href="#에제" class="headerlink" title="에제"></a>에제</h3><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/0y4vn2fj/1/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="dl-dt-dd-태그"><a href="#dl-dt-dd-태그" class="headerlink" title="dl,dt,dd 태그"></a>dl,dt,dd 태그</h2><p>자주 쓰이는 태그는 아니지만 설명 목록을 만들 때 주로 쓰이는 태그이다. 경험이 적어서 그런건진 몰라도 이 태그 쓰는 사이트를 본 기억이 드물다. 위키트리에서는 쓰일 수도 있겠다… 여튼 dl태그로 묶고 dt 태그에 제목을 dd 태그에 설명을 표시한다.</p><p>지금까지 배운 자료를 가지고 본인만의 간단한 프로필 웹 페이지를 만들어 보는 것도 좋을 것 같다.</p><h3 id="참고할-만한-사이트"><a href="#참고할-만한-사이트" class="headerlink" title="참고할 만한 사이트."></a>참고할 만한 사이트.</h3><p><a href="https://validator.w3.org/" target="_blank" rel="noopener">HTML 온라인 검사기</a></p><p>이 사이트는 파일을 업로드하면 자동으로 HTML 문서 상 오류가 있는 지 검사해주는 사이트다. 웹 페이지를 제작할 때 꽤 유용하다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;목록을-생성하는-태그&quot;&gt;&lt;a href=&quot;#목록을-생성하는-태그&quot; class=&quot;headerlink&quot; title=&quot;목록을 생성하는 태그&quot;&gt;&lt;/a&gt;목록을 생성하는 태그&lt;/h1&gt;&lt;p&gt;HTML 문서를 작성할 때 많이 쓰이는 태그 중 하나가 바로 
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="HTML" scheme="http://rootjang92.github.io/categories/HTML-CSS/HTML/"/>
    
    
      <category term="HTML, html, HTML basic syntax, htmltag, ul, li" scheme="http://rootjang92.github.io/tags/HTML-html-HTML-basic-syntax-htmltag-ul-li/"/>
    
  </entry>
  
  <entry>
    <title>자바스크립트 데이터 타입과 연산자.</title>
    <link href="http://rootjang92.github.io/2018/09/03/jsdatatype/"/>
    <id>http://rootjang92.github.io/2018/09/03/jsdatatype/</id>
    <published>2018-09-03T09:04:58.000Z</published>
    <updated>2018-09-04T08:05:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="자바스크립트-데이터-타입"><a href="#자바스크립트-데이터-타입" class="headerlink" title="자바스크립트 데이터 타입"></a>자바스크립트 데이터 타입</h3><p>자바스크립트의 데이터 타입에는 기본 타입과 참조 타입이 있다. 기본타입은 숫자, 문자열, boolean, undefined, null 값이 있고<br>참조형에는 객체(배열, 함수, 정규 표현식)이 있다.</p><h2 id="자바스크립트-기본-타입"><a href="#자바스크립트-기본-타입" class="headerlink" title="자바스크립트 기본 타입"></a>자바스크립트 기본 타입</h2><p>기본 타입에는 Nmber, String, Boolean, null, undefined가 있다.<br>이들 타입의 특징은 <strong>그 자체가 하나의 값</strong>을 나타낸다는 것이다. 자바스크립트는 느슨한 타입의 언어이기 때문에 변수를 선언할 때 타입을 미리 지정하지 않고 var(es5)라는 키워드로 변수를 선언하여 어떠한 값이라도 데이터를 저장할 수 있다.</p><pre><code>var intNum = 10;var floatNum = 0.1;var singleQuoteStr = &apos;single quote string&apos;;var boolVar = true;var emptyVar;var nullVar = null;console.log(typeof intNum, typeof floatNum, typeof singleQuoteStr, typeof boolVar,        typeof emptyVar, typeof nullVar);</code></pre><p>출력 결과</p><blockquote><p>number number string boolean undefined object</p></blockquote><h2 id="숫자"><a href="#숫자" class="headerlink" title="숫자"></a>숫자</h2><p>다른 언어와 달리 JS에서는 하나의 숫자형만 존재한다. (모든 숫자를 64비트 부동 소수점 형태로 저장한다.)<br>또한 모든 숫자를 실수로 처리하므로 나눗셈 연산에 주의하여야 한다.</p><pre><code>var num = 5 / 2;console.log(num);console.log(Math.floor(num));</code></pre><p>출력 결과</p><blockquote><p>2.5<br>2</p></blockquote><p>Math.floor 메서드는 정수 부분만 구하는 JS의 메서드이다.</p><h2 id="문자열"><a href="#문자열" class="headerlink" title="문자열"></a>문자열</h2><p>문자열은 작은 따옴표나 큰 따옴표를 이용해서 생성한다. 또한 JS의 문자열은 문자 배열처럼 인덱스를 이용할 수 있다. 또한 한 번 생선된 문자열은 수정이 불가능 하다.</p><pre><code>var str = &apos;easy&apos;;console.log(str[0], str[1], str[2], str[3]);str[0] = &apos;E&apos;;console.log(str);</code></pre><p>출력 결과</p><blockquote><p>e a s y<br>easy</p></blockquote><h2 id="boolean값"><a href="#boolean값" class="headerlink" title="boolean값"></a>boolean값</h2><p>JS에서 사용하는 true, false 값이다.</p><h2 id="null과-undefined"><a href="#null과-undefined" class="headerlink" title="null과 undefined"></a>null과 undefined</h2><p>두 타입 모두 ‘값이 비어 있다.’를 나타내기 위해 사용된다. <strong>값이 할당되지 않은</strong> 변수는 undefined이며 이는 변수 자체의 값이 undefined이다. (타입이자 값이다.) 여기 주의할 점은 null의 타입이 object라는 것인데 이 때문에 타입 변수인자를 확인할 때에는 일치 연산자를 사용하여야 한다. (===)</p><pre><code>var nullVar = null;console.log(typeof nullVar === null);console.log(nullVar === null);</code></pre><p>출력 결과</p><blockquote><p>false<br>true</p></blockquote><h2 id="JS-객체-타입"><a href="#JS-객체-타입" class="headerlink" title="JS 객체 타입"></a>JS 객체 타입</h2><p>JS에서 기본 타입을 제외한 모든 것은 객체이다. 배열, 함수, 정규표현식 들도 마찬가지이다. 객체는 단순히 이름(key):값(value)를 저장하는 형태이다. 기본 타입은 하나의 값마늘 가지는 데에 반해 겍체는 여러 개의 프로퍼티를 포함할 수 있다. 그래서 기본 타입을 포함하거나 다른 객체를 가리킬 수도 있다. 또한 프로퍼티의 성질에 따라 함수로 포함시킬 수도 있으며 이러한 프로퍼티를 <strong>메서드</strong>라고 부른다.</p><h2 id="JS-객체-생성-방법"><a href="#JS-객체-생성-방법" class="headerlink" title="JS 객체 생성 방법."></a>JS 객체 생성 방법.</h2><p>객체 생성 방법에는 3가지가 있다. 그 방법들에 대해 알아보자</p><h3 id="Object-생성자-함수"><a href="#Object-생성자-함수" class="headerlink" title="Object() 생성자 함수."></a>Object() 생성자 함수.</h3><p>JS에서는 객체를 생성할 때 내장 Object() 생성자 함수를 제공한다. 예제를 통해 살펴보자.</p><pre><code>var foo = new Object();// foo property make upfoo.name = &apos;Jang&apos;;foo.age = 27;foo.gender = &apos;male&apos;;console.log(typeof foo);console.log(foo);</code></pre><p>출력 결과</p><blockquote><p>object<br>{ name: ‘Jang’, age: 27, gender: ‘male’ }</p></blockquote><p>Object() 생성자 함수를 통해 객체를 생성하였고 그 타입은 object이고 변수 foo에 3가지 프로퍼티가 추가되었음을 알 수 있다.</p><h3 id="객체-리터럴-방식"><a href="#객체-리터럴-방식" class="headerlink" title="객체 리터럴 방식."></a>객체 리터럴 방식.</h3><p>리터럴이란 표기법을 의미한다. 즉 간단한 표기법으로 객체를 생성하는 방식이다.</p><pre><code>var foo = {  name : &apos;Jang&apos;,  age : 27,  gender : &apos;male&apos;};console.log(typeof foo);console.log(foo);</code></pre><p>출력 결과</p><blockquote><p>object<br>{ name: ‘Jang’, age: 27, gender: ‘male’ }</p></blockquote><h3 id="생성자-함수-이용"><a href="#생성자-함수-이용" class="headerlink" title="생성자 함수 이용."></a>생성자 함수 이용.</h3><p>객체를 함수를 통해서도 생성할 수 있다. 생성자 함수라고 하는데 다음에 더 자세히 다루도록 하겠다.</p><p>다음 시간에는 객체 프로퍼티 표기법과 참조타입의 특성에 대해 살펴보겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;자바스크립트-데이터-타입&quot;&gt;&lt;a href=&quot;#자바스크립트-데이터-타입&quot; class=&quot;headerlink&quot; title=&quot;자바스크립트 데이터 타입&quot;&gt;&lt;/a&gt;자바스크립트 데이터 타입&lt;/h3&gt;&lt;p&gt;자바스크립트의 데이터 타입에는 기본 타입과 참조
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="Javascript, js, es5, ES5, data, datatype" scheme="http://rootjang92.github.io/tags/Javascript-js-es5-ES5-data-datatype/"/>
    
  </entry>
  
  <entry>
    <title>HTML 텍스트 관련된 태그들</title>
    <link href="http://rootjang92.github.io/2018/09/03/htmltext/"/>
    <id>http://rootjang92.github.io/2018/09/03/htmltext/</id>
    <published>2018-09-03T08:02:35.000Z</published>
    <updated>2018-09-04T08:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML-텍스트-관련-태그들"><a href="#HTML-텍스트-관련-태그들" class="headerlink" title="HTML 텍스트 관련 태그들."></a>HTML 텍스트 관련 태그들.</h3><p>HTML 문서를 작성할 때 가장 많이 쓰이는 태그는 무엇일까?? 바로 텍스트 관련 태그들이다.<br>p, strong, table,em,ul,li 태그 등 꽤 많은 태그가 쓰이는 데 그 중에서 정말 자주 쓰이는 태그만 알아보자.araboza</p><h2 id="h-관련-태그"><a href="#h-관련-태그" class="headerlink" title="h 관련 태그"></a>h 관련 태그</h2><p>HTML 문서에서 제목을 붙이고 싶을 때는 h관련 태그(제목 텍스트)를 쓰면 된다. h 태그를 사용하면 글씨가 크고 굵어진다.<br>h1 ~ h6까지 사용 가능하다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/7dao64g5/10/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="p-태그"><a href="#p-태그" class="headerlink" title="p 태그"></a>p 태그</h2><p>쉽게 말하면 단락 만들기 태그이다. 단락은 앞뒤에 줄바꿈이 있는 덩어리를 말한다.</p><h2 id="br-태그"><a href="#br-태그" class="headerlink" title="br 태그"></a>br 태그</h2><p>줄바꿈 태그이다. 이 태그 없이 줄바꿈을 하더라도 줄이 바뀌지 않는다. (텍스트만 사용 시)</p><h2 id="hr-태그"><a href="#hr-태그" class="headerlink" title="hr 태그"></a>hr 태그</h2><p>수평줄을 삽입하는 태그이다. 보통 css로 만들기 때문에 딱히 쓰이진 않지만… 실습용으로</p><h2 id="blockquote-태그"><a href="#blockquote-태그" class="headerlink" title="blockquote 태그"></a>blockquote 태그</h2><p>다른 사이트에서 가져온 글을 인용할 때 사용하는 태그이다. (마크다운에도 비슷한 문법이 있다.)</p><h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/rpg6cemf/1/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="pre-태그"><a href="#pre-태그" class="headerlink" title="pre 태그"></a>pre 태그</h2><p>입력한 그대로 입력되게 해주는 태그다. 하지만 웹 표준성에 맞추기 위해 사용을 자제하는 것이 좋다.</p><h2 id="strong-b태그와-em-i-태그"><a href="#strong-b태그와-em-i-태그" class="headerlink" title="strong, b태그와 em, i 태그"></a>strong, b태그와 em, i 태그</h2><p>strong, b 태그는 텍스트를 굵게 표시하기 위해 사용된다. 둘의 차이점은 단순히 굵게 표시할떈 b태그, 강조되었다는 것을 알리기 위해선 strong 태그를 사용한다.</p><p>em, i 태그는 이탤릭체로 표시되게 하는 태그이다. 둘의 차이는 단순히 표시만 하는 것은 em, 의미를 알리기 위해선 i 태그르 사용한다는 것이다.</p><h2 id="blockquote와-q-태그"><a href="#blockquote와-q-태그" class="headerlink" title="blockquote와 q 태그"></a>blockquote와 q 태그</h2><p>두 태그 모두 인용문을 사용하는 태그이지만 둘의 차이는 블록 베레이냐 인라인 레벨이냐 이다.<br>blocakquote는 블록 레벨에 태그이기 때문에 인용 내용이 줄이 바뀌어 나타나지만, q태그는 인라인 태그이기 때문에 한 줄로 표시된다.</p><h2 id="span-태그"><a href="#span-태그" class="headerlink" title="span 태그"></a>span 태그</h2><p>줄 바꿈 없이 단락 안에서 텍스트를 묶을 때 사용하는 태그이다. 큰 의미는 없다.</p><p>다음 시간에는 목록만들기와 테이블 만들기를 알아보도록 하겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTML-텍스트-관련-태그들&quot;&gt;&lt;a href=&quot;#HTML-텍스트-관련-태그들&quot; class=&quot;headerlink&quot; title=&quot;HTML 텍스트 관련 태그들.&quot;&gt;&lt;/a&gt;HTML 텍스트 관련 태그들.&lt;/h3&gt;&lt;p&gt;HTML 문서를 작성할 때 가
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="HTML" scheme="http://rootjang92.github.io/categories/HTML-CSS/HTML/"/>
    
    
      <category term="HTML, html, HTML basic syntax, htmltag" scheme="http://rootjang92.github.io/tags/HTML-html-HTML-basic-syntax-htmltag/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 기본 개요</title>
    <link href="http://rootjang92.github.io/2018/09/02/jsbasic/"/>
    <id>http://rootjang92.github.io/2018/09/02/jsbasic/</id>
    <published>2018-09-02T01:46:18.000Z</published>
    <updated>2018-09-02T02:01:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="자바스크립트-기본-개요"><a href="#자바스크립트-기본-개요" class="headerlink" title="자바스크립트 기본 개요"></a>자바스크립트 기본 개요</h3><p>자바스크립트는 웹 브라우저에서 동작하는 스크립트 언어이다. 처음에는 웹 페이지 제작에 <strong>보조적</strong> 역할에 한정되어 있었다.<br>하지만 여러가지 연구와 prototype 라이브러리 개발 등 많은 발전이 있으면서 서버에서 담당하던 역할이 웹 브라우저로 옮겨졌고 결국 자바스크립트는 그 변화의 중심적인 언어가 되었다. (인사이드 자바스크립트 저:송형주, 고현준 참조)</p><p>현재 github에서 가장 많이 사용되고 있는 언어는 자바스크립트이고 Node.js의 개발로 서버 개발 또한 가능해지며 사용자가 늘고 있다.</p><p>자바스크립트는 현재 웹 개발은 물론 Node.js, express, socket.io 등을 활용한 서버 개발, 애플리케이션 개발도 가능해졌기 때문에 웹 기반 플랫폼에선 없어서는 안될 언어가 되었다.</p><h3 id="자바스크립트-핵심-개념"><a href="#자바스크립트-핵심-개념" class="headerlink" title="자바스크립트 핵심 개념"></a>자바스크립트 핵심 개념</h3><p>자바스크립트에서는 꼭 알아야 할 몇가지 핵심 개념이 있는데 앞으로 블로그를 운영하면서 차차 살펴보도록 하겠다.</p><ul><li>객체(Object)</li></ul><p>자바스크립트(이하 JS)의 거의 모든 것은 객체라고 할 정도로 중요한 개념이다. 자바스크립트의 기본 데이터 타입을 제외하곤 모든 것이 객체이다.<br>하지만 null과 undefined를 제외한 모든 것을 객체처럼 다룰 수 있기 때문에 이 2가지를 제외하곤 모두 객체라고 할 수 있다.</p><ul><li>함수</li></ul><p>JS에선 함수도 객체이다. 함수는 특히 중요하기 떄문에 일급 객체(First class object)로 취급된다.</p><ul><li>프로토타입</li></ul><p>모든 객체는 프로토타입을 가진다. 분량이 상당히 많을 것으로 예상되기 때문에 뒤에서 자세히 다루겠지만, 쉽게 말해서 해당 개체를 생성한 생성자를 가리킨다고 보면 된다. 이 프로토타입으로 인해 겍체지향에 상속을 구현할 수 있게 되었다.</p><ul><li>실행 컨텍스트와 클로저</li></ul><p>JS는 자신만의 방법으로 실행 컨텍스트를 만들고 그 안에서 유효범위(Scope)를 갖는다. 또한 그 과정에서 클로저를 구현할 수 있다.</p><ul><li>객체지향 프로그래밍</li></ul><p>JS는 클래스를 지원하지 않지만(ES6에서는 함수의 형태로 만들어졌다.) 상속과 캡슐화 등의 객체지향 프로그래밍을 따라가고 있다.</p><ul><li>JS와 함수형 프로그래밍</li></ul><p>‘모듈화’하면 함수형 프로그래밍! JS의 일급 객체인 함수와 클로저를 활용하여 함수형 프로그래밍이 가능하게 한다.</p><ul><li>단점</li></ul><p>굉장히 유연한 언어의 단점은 디버깅이 힘들다는 점, 느슨한 타입 체크로 인한 컴파일 에러(런타임 에러로 이어진다.)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;자바스크립트-기본-개요&quot;&gt;&lt;a href=&quot;#자바스크립트-기본-개요&quot; class=&quot;headerlink&quot; title=&quot;자바스크립트 기본 개요&quot;&gt;&lt;/a&gt;자바스크립트 기본 개요&lt;/h3&gt;&lt;p&gt;자바스크립트는 웹 브라우저에서 동작하는 스크립트 언어이
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="Javascript, js, es5, ES5" scheme="http://rootjang92.github.io/tags/Javascript-js-es5-ES5/"/>
    
  </entry>
  
  <entry>
    <title>HTML 기본 문서 구조</title>
    <link href="http://rootjang92.github.io/2018/09/02/htmlbasic/"/>
    <id>http://rootjang92.github.io/2018/09/02/htmlbasic/</id>
    <published>2018-09-02T01:03:39.000Z</published>
    <updated>2018-09-02T01:44:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML-기본-문서-구조"><a href="#HTML-기본-문서-구조" class="headerlink" title="HTML 기본 문서 구조"></a>HTML 기본 문서 구조</h3><h1 id="1-태그"><a href="#1-태그" class="headerlink" title="1. 태그"></a>1. 태그</h1><p>HTML은 웹 문서에 마크업을 하는 언어이다. 그 때 마크업을 사용하는 약속된 표기법이 <strong>태그</strong> 이다.</p><ul><li><p>태그는 <code>&lt;&gt;</code>를 사용한다.<br>꺽쇠 사이에 들어가는 부분이 바로 tag 부분이다.</p></li><li><p>소문자로 쓴다.(권장사항)<br>대,소문자를 구분하진 않지만 HTML5 표준 명세에는 소문자를 권장하고 있다.</p></li><li><p>여는 태그와 닫는 태그<br>닫는 태그가 없는 경우도 있지만 닫는 태그가 필요한 태그에는 반드시 태그를 닫아주어야 한다.</p></li><li><p>들여쓰기.<br>쉽게 눈으로 확인하고 문서의 구조를 파악하기가 쉬워진다. tab키를 사용한다.</p></li><li><p>속성을 파악해야 한다.<br>태그 안에는 사용할 수 있는 속성값이 있다. 예를 들어 img 태그에는 src(주소값), width, height 등의 속성이 있다.</p></li></ul><h2 id="처음-만들어-보는-HTML-문서"><a href="#처음-만들어-보는-HTML-문서" class="headerlink" title="처음 만들어 보는 HTML 문서"></a>처음 만들어 보는 HTML 문서</h2><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/7dao64g5/6/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="문서-구조-살펴보기"><a href="#문서-구조-살펴보기" class="headerlink" title="문서 구조 살펴보기."></a>문서 구조 살펴보기.</h2><pre><code>&lt;!DOCTYPE html&gt;</code></pre><p>HTML5로 작성된 웹 문서라는 뜻이다. HTML4에서는 엄격모드, 호환 모드 등 꽤 복잡했지만 이젠 단 한줄이면 된다.</p><pre><code>&lt;html&gt; ~ &lt;/html&gt;</code></pre><p>웹 문서의 시작과 끝이라고 보면 된다. 이 태그에는 lang이라는 속성에 언어를 설정해 줘야 하는데 특정 언어로 검색할 때 그 대상이 될 수 있다.</p><pre><code>&lt;head&gt; ~ &lt;/head&gt;</code></pre><p>웹 문서를 해석하기 위해 필요한 정보들을 입력하는 곳이다.</p><pre><code>&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;title&gt;내가 처음 만드는 HTML 문서&lt;/title&gt;</code></pre><p>head 태그 안에는 meta태그와 title태그가 보통 표시 되는데 화면에 보이는 것은 title 태그이다. meta 태그는 실제 문서 내용이 아닌 문서를 해석하기 위해 사용되는 태그이다.</p><p>title태그에 문서 제목을 입력하는 이유는 웹 표준성과 관련되어 있다. 간혹 시각 장애를 가지고 계시는 분들이 인터넷을 이용할 때 보조 기기를 이용하는데, 제목을 듣고 이 사이트가 어떤 사이트 인지 알 수 있어야 하기 떄문이다.</p><p>meta 태그 안에는 문자 인코딩 방법이나 키워드 등을 지정한다.</p><pre><code>&lt;body&gt; ~ &lt;/body&gt;</code></pre><p>웹 문서의 실질적인 내용(화면에 나오는 내용)이 나타내는 태그이다. 대부분의 태그는 이 <body>태그 안에 들어간다.</body></p><p>사이트를 이용하기 위해선 서버단에서 호스팅 서버를 준비해서 FTP 프로그램을 이용해 배포해야 한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTML-기본-문서-구조&quot;&gt;&lt;a href=&quot;#HTML-기본-문서-구조&quot; class=&quot;headerlink&quot; title=&quot;HTML 기본 문서 구조&quot;&gt;&lt;/a&gt;HTML 기본 문서 구조&lt;/h3&gt;&lt;h1 id=&quot;1-태그&quot;&gt;&lt;a href=&quot;#1-태그&quot;
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="HTML" scheme="http://rootjang92.github.io/categories/HTML-CSS/HTML/"/>
    
    
      <category term="HTML, html, HTML basic syntax, html tag" scheme="http://rootjang92.github.io/tags/HTML-html-HTML-basic-syntax-html-tag/"/>
    
  </entry>
  
  <entry>
    <title>HTML이란?</title>
    <link href="http://rootjang92.github.io/2018/09/01/html1/"/>
    <id>http://rootjang92.github.io/2018/09/01/html1/</id>
    <published>2018-09-01T06:27:45.000Z</published>
    <updated>2018-09-01T07:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML이란-무엇인가"><a href="#HTML이란-무엇인가" class="headerlink" title="HTML이란 무엇인가?"></a>HTML이란 무엇인가?</h3><p>우리가 흔히 보는 웹사이트의 기본은 HTML 이다. 흔히 ‘웹 문서’를 작성한다고 말하는데 이를 보는 프로그램이 바로 ‘Web browser’이다.<br>HTML은 HyperText Markup Language의 줄임말로서 하이퍼텍스트를 마크업한는 언어다.</p><h1 id="하이퍼-텍스트란"><a href="#하이퍼-텍스트란" class="headerlink" title="하이퍼 텍스트란?"></a>하이퍼 텍스트란?</h1><blockquote><p>웹 사이트에서 링크를 클릭해 다른 문서나 사이트로 즉시 이동할 수 있는 기능.</p></blockquote><p><code>&lt;&gt;</code>로 묶인 것은 HTML 태그라고 하고 이렇게 태그를 붙이는 것이 마크업이다. 이 꺽쇠안의 내용은 웹 브라우저 화면에 나타나지 않는다.</p><p>네이버로 들어가 [페이지 소스 보기], 혹은 검사(chrome)을 하여 documents를 살펴보자.<br><a href="https://www.naver.com" target="_blank" rel="noopener">HTML소스 엿보기</a></p><h1 id="웹-표준이란"><a href="#웹-표준이란" class="headerlink" title="웹 표준이란?"></a>웹 표준이란?</h1><p>우리가 현재 사용하고 있는 HTML5를 웹 표준 기술이라고 하는데 왜 웹 표준이 필요할까?<br>바로 ‘표준’이 필요하기 떄문입니다. 세상에는 많은 브라우저들이 있기 때문에 예를 들어 IE에서는 맞지 않고 크롬에만 맞는 사이트를 구현한다면 사용자들이 자유롭게 이용할 수 없다.</p><p>따라서 HTML5로 문서를 만드는 것은 웹 표준을 지키는 문서를 만드는 것이다.</p><ol><li>최신 웹 표준에 맞는 웹사이트를 제작할 수 있다.</li><li>앱 화면의 기초를 디자인한다.</li><li>Interactive한 사이트를 만들 수 있다.</li><li>소스를 이해하여 웹 사이트나 블로그를 쉽게 수정할 수 있다.</li></ol><p>이로서 HTML5를 왜 사용하는 지에 대해 알아보았습니다. 다음 시간에는 HTML의 기본 문서 구조에 대해 알아보겠습니다.</p><ul><li>이 글은 DO it! HTML5 + CSS3 웹 표준의 정석이라는 책을 인용하였습니다.</li><li>thumbnail 출처 : <a href="http://knulab.com/archives/1060" target="_blank" rel="noopener">http://knulab.com/archives/1060</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTML이란-무엇인가&quot;&gt;&lt;a href=&quot;#HTML이란-무엇인가&quot; class=&quot;headerlink&quot; title=&quot;HTML이란 무엇인가?&quot;&gt;&lt;/a&gt;HTML이란 무엇인가?&lt;/h3&gt;&lt;p&gt;우리가 흔히 보는 웹사이트의 기본은 HTML 이다. 흔히 
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="HTML" scheme="http://rootjang92.github.io/categories/HTML-CSS/HTML/"/>
    
    
      <category term="HTML, html" scheme="http://rootjang92.github.io/tags/HTML-html/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://rootjang92.github.io/2018/08/30/hello-world/"/>
    <id>http://rootjang92.github.io/2018/08/30/hello-world/</id>
    <published>2018-08-30T06:10:05.000Z</published>
    <updated>2018-08-30T06:10:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
