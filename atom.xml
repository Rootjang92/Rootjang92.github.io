<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rootjang&#39;s IT Blog</title>
  
  <subtitle>Geunho&#39;s IT Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rootjang92.github.io/"/>
  <updated>2018-11-14T03:09:48.635Z</updated>
  <id>http://rootjang92.github.io/</id>
  
  <author>
    <name>Geun ho</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>객체 리터럴 확장, 상속 그리고 디스트럭처링</title>
    <link href="http://rootjang92.github.io/2018/11/14/distructuring/"/>
    <id>http://rootjang92.github.io/2018/11/14/distructuring/</id>
    <published>2018-11-14T02:39:28.000Z</published>
    <updated>2018-11-14T03:09:48.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="객체-리터럴의-확장"><a href="#객체-리터럴의-확장" class="headerlink" title="객체 리터럴의 확장"></a>객체 리터럴의 확장</h2><ul><li>프로퍼티 축약 표현</li></ul><p>es5의 객체 리터럴을 살펴보자. 객체 리터럴의 프로퍼티는 프로퍼티 이름과 프로퍼티 값으로 구성되어 있다.</p><pre><code>var x = 1, y = 2var obj = {  x: x,  y: y}</code></pre><p>이런 식으로 말이다.</p><p>es6의 경우 프로퍼티 이름을 생략할 수 있다. 이 때의 프로퍼티 이름은 변수명으로 자동 생성된다.</p><pre><code>let x = 1, y = 2;const obj = { x, y};</code></pre><ul><li>프로퍼티 이름 조합하기</li></ul><p>es5의 객체 리터럴 프로퍼티 이름을 문자열과 변수를 조합하여 동적으로 생성하기 위해선 객체 리터럴 외부에서 프로퍼티 이름을 생성하여 객체에 할당했다.</p><pre><code>var i = 0;var propName = &apos;prop_&apos;;var obj = {};obj[propName + ++i] = i;obj[propName + ++i] = i;obj[propName + ++i] = i;console.log(obj);</code></pre><p>es6에서는 객체 리터럴 내부에서 프로퍼티 이름을 동적으로 생성할 수 있다.</p><pre><code>const i = 0;const propName = &apos;prop_&apos;;const obj = {  [propName + ++i] = i;}console.log(obj);</code></pre><ul><li>메소드 축약 표현</li></ul><p>es5에선 메소드를 선언하기 위해 함수 선언식을 사용한다.</p><pre><code>var obj = {  name: &apos;Jang&apos;,  sayHi: function() {    console.log(&apos;Hi! &apos; + this.name)  }};obj.sayHi();</code></pre><p>es6에서는 function 키워드를 생략하여 축약 표현이 가능하다.</p><pre><code>const obj = {  name: &apos;Jang&apos;,  sayHi() {    console.log(&apos;Hi! &apos; + this.name)  }};obj.sayHi();</code></pre><ul><li>[[prototype]] 프로퍼티에 의한 상속</li></ul><p>es5에서 객체 리터럴을 상속하기 위해선 Obejct.create() 함수를 사요했다. (프로토타입 패턴 상속)</p><pre><code>var parent = {  name: &apos;Kim&apos;,  sayHello: function() {    console.log(&apos;Hello! &apos; + this.name)  }};var child = Object.create(parent);child.name = &apos;Jang&apos;;parent.sayHello();child.sayHello();</code></pre><p>es6에서는 객체 리터럴 내부에 [[prototype]] 프로퍼티를 <strong>직접</strong> 설정할 수 있다. 즉 다른 객체를 직접 바인딩하여 상속을 표현할 수 있다.</p><pre><code>const parent = {  name: &apos;Jang&apos;,  sayHi() {    console.log(&apos;Hi! &apos; + this.name)  }};const child = {  __proto__: parent,  name: &apos;Jang&apos;};parent.sayHi();child.sayHi();</code></pre><ul><li>디스트럭처링</li></ul><p>디스트럭처링의 개념은 구조화된 배열 또는 개체를 비구조화하여 개별적인 변수에 할당한다는 것이다. (말로 설명하면 어렵다…) 배열 혹은 객체 리터럴에서 필요한 값을 뽑아내여 변수에 할당하거나 변환할 때 유용하게 사용된다.</p><ol><li>배열 디스트럭처링</li></ol><p>es5에서 배열의 각 요소들을 배열로부터 디스트럭처링하여 변수에 할당하기 위해선</p><pre><code>var arr = [1,2,3];var one = arr[0];var two = arr[1];var three = arr[2];console.log(one, two, three);</code></pre><p>이런 식으로 해서 귀찮음이 커진다. 하지만 es6에서는</p><pre><code>const arr = [1,2,3];const [one, two, three] = arr;console.log(one, two, three);</code></pre><p>무려 코드가 2줄이나 줄어들었다! 귀찮음이 때로는 이런 엄청난(?) 결과물을 만들어 내기도 한다.</p><p>배열 디스트럭처링을 위해서는 할당 연산자 왼쪽에 배열 형태의 변수 리스트가 필요하고 변수 리스트와 배열은 인덱스를 기준으로 할당된다.</p><p>Date 객체에서 연, 월, 일을 추출하는 예제를 같이 만들어 보자.</p><pre><code>const today = new Date();const date = today.isISOString().substring(0, 10);const [year, month, day ] = date.split(&apos;-&apos;);console.log([year, month, day]);</code></pre><ol start="2"><li>객체 디스트럭처링</li></ol><p>es5에서의 객체 디스트럭처링은 프로퍼티 이름을 사용했다.</p><pre><code>var obj = { first: &apos;apple&apos;, last: &apos;pineapple&apos; };var first = obj.first;var second = obj.last;console.log(first, second);</code></pre><p>es6에서는 각 프로퍼티를 객체에서 뽑아서 변수 리스트에 할당한다. 기준은 프로퍼티 이름이다.</p><pre><code>const obj = { first: &apos;apple&apos;, last: &apos;pineapple&apos; };const { first, last } = obj;console.log(first, last);</code></pre><p>객체 디스트럭처링을 위해서는 할당 연산자 왼쪽에 객체 형태의 변수 리스트가 있어야 한다. 객체 디스트럭처링의 장점은 프로퍼티 이름으로 필요한 프로퍼티 값만을 추출할 수 있다는 점이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;객체-리터럴의-확장&quot;&gt;&lt;a href=&quot;#객체-리터럴의-확장&quot; class=&quot;headerlink&quot; title=&quot;객체 리터럴의 확장&quot;&gt;&lt;/a&gt;객체 리터럴의 확장&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;프로퍼티 축약 표현&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;es5의 객체
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES6" scheme="http://rootjang92.github.io/categories/Javascript/ES6/"/>
    
    
      <category term="js, javascript, es6, destructuring" scheme="http://rootjang92.github.io/tags/js-javascript-es6-destructuring/"/>
    
  </entry>
  
  <entry>
    <title>ES6 파라미터를 알아보자.araboza</title>
    <link href="http://rootjang92.github.io/2018/11/12/param/"/>
    <id>http://rootjang92.github.io/2018/11/12/param/</id>
    <published>2018-11-12T03:12:32.000Z</published>
    <updated>2018-11-12T03:45:17.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-파라미터"><a href="#ES6-파라미터" class="headerlink" title="ES6 파라미터"></a>ES6 파라미터</h1><ul><li>파라미터 기본값</li></ul><p>es5에서는 파라미터 기본값을 설정할 수 없었지만, es6에선 기본값을 설정할 수 있어 함수 내 파라미터 검사를 수행하지 않아도 된다.</p><ul><li>Rest 파라미터</li></ul><p>Rest 파라미는 Spread 연산자를 사용하여 파라미터를 정의한 것이다. 그래서 인수 리스트를 함수 내부에서 배열로 전달받을 수 있다.</p><pre><code>function foo(...rest) {  console.log(Array.isArray(rest));  console.log(rest);}foo(1,2,3,4,5);</code></pre><p>위 결과로 볼 수 있듯이 인수는 순차적으로 파라미터와 Rest 파라미터에 할당된다.<br>또한 주의할 점은 rest 파라미터는 항상 인수의 맨 마지막에 와야 한다는 것이다. 그렇게 하지 않을 시 문법에러가 발생한다.</p><ul><li>argumetns와 rest 파라미터</li></ul><p>es5의 가변 인자 함수는 arguments 객체를 통해서 인수를 확인했다.</p><pre><code>var foo = fucntion() {  console.log(arguments);};foo(1,2);</code></pre><p>arguments는 파라미터로 인수를 전달받는 것이 불가능했다. 또한 유사 배열 객체이기 때문에 배열 메서드를 사용하기 위해선 Function.prototype.call을 사용해야 하는 불편함이 있었다.</p><p>하지만 es6에서는 rest 파라미터를 통해 가변 인자를 함수 내부에 배열로 전달이 가능하다. 위처럼 arguments 객체를 배열로 변경하는 등의 수고스러움을 덜 수 있다.</p><pre><code>function sum(...args) {  console.log(arguments)  console.log(Array.isArray(args));  return args.reduce((pre,cur) =&gt; pre + cur);}console.log(sum(1,2,3));</code></pre><p>주의할 점은 화살표 함수에는 arguments 프로퍼티가 없기 떄문에 화살표 함수로 가변 인자 함수롤 구현해야 한다면 <strong>반드시</strong> rest 파라미터를 사용해야 한다.</p><ul><li>Spread 연산자</li></ul><p>spread 연산자는 대상 배열이나 이터러블을 개별 요소로 분리한다.</p><ol><li>함수 인자로 사용하는 경우</li></ol><p>원래라면 Function.prototype.apply를 통해 개별적인 파라미터로 전달했다. 하지만 spread 연산자를 이용하면 쉽게 매개변수로 전달이 가능하다.</p><pre><code>function foo(x,y,z) {  console.log(x);  console.log(y);  console.log(z);}const arr = [1,2,3];foo(...arr);</code></pre><p>…rest와 spread연산자의 차이는 …rest는 분리된 요소를 <strong>함수 내부에 배열로 전달</strong>한다는 것이고 spread 연산자는 <strong>매개변수에 할당</strong>한다는 것이다.<br>또한 spread연산자는 자유롭게 사용할 수 있다.</p><ol start="2"><li>배열에서 사용할 경우</li></ol><p>es5에서는 기존 배열에 대한 많은 메서드를 사용하여 해결해야 했지만 spread 연산자로 좀 더 편하고 가독성이 좋게 만들 수 있다.</p><ul><li><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><pre><code>var arr = [1,2,3];console.log(arr.concat([4,5,6]));const arr = [1,2,3];console.log([...arr,4,5,6]);</code></pre></li></ul><ul><li><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><pre><code>var arr1 = [1,2,3];var arr2 = [4,5,6];Array.prototype.push.apply(arr1, arr2);console.log(arr1);const arr1 = [1,2,3];const arr2 = [4,5,6];arr1.push(...arr2);console.log(arr1);</code></pre></li></ul><ul><li><h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><pre><code>var arr1 = [1,2,3,6];var arr2 = [4,5];Array.prototype.splice.apply(arr1, [3,0].concat(arr2));console.log(arr1);const arr1 = [1,2,3,6];const arr2 = [4,5];arr1.splice(3,0,...arr2);console.log(arr1);</code></pre></li></ul><ul><li><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><pre><code>var arr = [1,2,3];var copy = arr.slice();console.log(copy);copy.push(4);console.log(copy);console.log(arr);</code></pre></li></ul><p>원본 배열에 변화는 없다.</p><pre><code>const arr = [1,2,3];const copy = [...arr];console.log(copy);</code></pre><ol start="3"><li><h2 id="객체에서-사용하는-경우"><a href="#객체에서-사용하는-경우" class="headerlink" title="객체에서 사용하는 경우"></a>객체에서 사용하는 경우</h2><p>   cost merged = {…{x:1, y:2 }, …{y: 10, z: 3}};<br>   console.log(merged);</p><p>   const changed = {…{x:1, y:2 }, y:100};<br>   console.log(changed);</p><p>   const added = {…{x:1, y:2},z:0};<br>   console.log(added);</p></li></ol><p>Object.assign 메서드를 사용해도 같은 작업이 가능하다.</p><pre><code>const merged = Object.assign({}, {x:1, y:2}, {y: 10, z: 3});console.log(merged);const changed = Object.assign({}, {x:1, y:2}, {y: 100});console.log(changed);const added = Object.assign({}, {x:1,y:2}, {z:0});console.log(added);</code></pre><p>spread연산자를 사용하여 유사 배열 객체를 손쉽게 배열로 변경할 수 있다.</p><pre><code>const htmlCollection = document.getElementByTagName(&apos;li&apos;);const newArray = [...htmlCollection];</code></pre><p>위 예제는 html 파일을 만들어서!<br>Array.from 메서드로도 가능하다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6-파라미터&quot;&gt;&lt;a href=&quot;#ES6-파라미터&quot; class=&quot;headerlink&quot; title=&quot;ES6 파라미터&quot;&gt;&lt;/a&gt;ES6 파라미터&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;파라미터 기본값&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;es5에서는 파라미터 기본값을 
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES6" scheme="http://rootjang92.github.io/categories/Javascript/ES6/"/>
    
    
      <category term="es6, javascript, rest parameter, spread" scheme="http://rootjang92.github.io/tags/es6-javascript-rest-parameter-spread/"/>
    
  </entry>
  
  <entry>
    <title>화살표 함수</title>
    <link href="http://rootjang92.github.io/2018/11/10/arrow-function/"/>
    <id>http://rootjang92.github.io/2018/11/10/arrow-function/</id>
    <published>2018-11-10T01:44:04.000Z</published>
    <updated>2018-11-10T02:17:49.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="화살표-함수"><a href="#화살표-함수" class="headerlink" title="화살표 함수"></a>화살표 함수</h1><p>화살표 함수란 es5의 function키워드 대신 <code>=&gt;</code>를 사용하여 쉽게 함수를 선언하는 것을 말한다.</p><ul><li>기본 문법</li></ul><p>() =&gt; {}는 매개변수가 없을 경우에 사용하는 방법, x =&gt; {}는 매개변수가 한 개일 경우, 소괄호를 생략 가능하다. (x,y) =&gt; {} 매개변수가 여러개일 경우 소괄호에 묶어 사용한다.</p><ul><li>호출</li></ul><p>화살표 함수는 익명함수만 사용이 가능하기 때문에 함수 표현식으로 사용하여야 한다.</p><pre><code>const plus = x =&gt; x + x;console.log(plus(2)); // 4</code></pre><p>또는 콜백함수로 사용이 가능하다.</p><pre><code>const arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];const pow = arr.map(x =&gt; x * x);console.log(pow);</code></pre><ul><li>this</li></ul><p>일반 함수의 this는 <strong>함수를 호출하는 패턴</strong>에 따라서 this에 바인딩되는 객체가 달라진다. 우선적으로 콜백 함수의 this는 기본적으로 전역을 가리킨다.</p><pre><code>function Strarr(str) {  this.str = str; // 1}Strarr.prototype.StrarrArray = function (arr) {  return arr.map(function (x) {    return this.str + &apos; &apos; + x; // 2  });};var res = new Strarr(&apos;Nice to meet you&apos;);console.log(res.StrarrArray([&apos;Jang&apos;, &apos;Park&apos;]));</code></pre><p>Strarr이라는 함수를 만들어서 새로운 프로토타입에서 문자열을 리턴하는 메서드를 다시 만들어 반환해보았다. 예상되는 결과값이 있는가?<br>상식적으로 [‘Nice to meet you Jang’, ‘Nice to meet you Park’]이 나올 것으로 예상했지만 결과는 Nice to meet you 부분은 undefined가 반환된다.</p><p>1번 this는 Strarr이 생성한 객체(인스턴스인 str)을 가리킨다. 2번에서이 this는 전역 객체를 가리킨다. 그 이유는 생성자 함수와 객체의 메서드를 제외한 모든 함수 내부의 this는 전역객체를 가리키기 때문이다.</p><p>그래서 es5에서는 이를 대체할 몇가지 방법을 제시하고 있다.</p><ol><li>that = this</li></ol><hr><pre><code>function Strarr(str) {  this.str = str;}Strarr.prototype.StrarrArray = function (arr) {  var that = this; // 참조값을 변경해준다.  return arr.map(function (x) {    return that.str + &apos; &apos; + x;  });};var res = new Strarr(&apos;Nice to meet you&apos;);console.log(res.StrarrArray([&apos;Jang&apos;,&apos;Park&apos;]));</code></pre><ol start="2"><li>생성자 함수의 인스턴스로 this 넣어주기</li><li>bind메서드 이용하기</li></ol><ul><li>화살표 함수의 this</li></ul><p>화살표 함수의 this는 상위 컨텍스트의 this를 계승하게 된다.</p><pre><code>function Strarr(str) {  this.str = str; // 1}Strarr.prototype.StrarrArray = function (arr) {  return arr.map(x =&gt; `${this.str} ${x}`);};const res = new Strarr(&apos;Nice to meet you&apos;);console.log(res.StrarrArray([&apos;Jang&apos;, &apos;Park&apos;]));</code></pre><ul><li>화살표 함수는 언제 쓰면 안될까?</li></ul><p>화살표 함수가 매우 편리한 기능인 것은 맞지만, 그것을 남용하는 것은 문제가 된다. 특히 몇가지 경우에는 화살표 함수를 사용해서는 안된다.<br>첫 번째로 화살표 함수로 객체의 메서드를 정의하는 경우이다. 화살표 함수의 this는 상위 컨텍스트를 가리키기 때문에 객체 메서드를 생성할 경우 this가 전역객체를 가리켜 문제가 될 수 있다.</p><p>이 경우 축약 메서드 표현을 사용하기로 하자!</p><pre><code>const person = {  name: &apos;Jang&apos;,  sayHello() {    console.log(`Hi ${this.name}`);  }};person.sayHello();</code></pre><p>또한 같은 이유로 prototype에 할당하는 경우도 배제해야 한다. prototype에 메서드를 할당하려는 경우에는 일반 함수로 하자!</p><p>세 번째로는 생성자 함수이다. 생성자 함수는 prototype 프로퍼티와 그가 가리키는 constructor 객체를 사용한다. 근데 화살표 함수에는 <strong>prototype 프로퍼티</strong>가 존재하지 않는다.</p><p>마지막으로 addEventListner의 콜백함수로 사용하면 안된다. 이도 마찬가지로 this가 상위 컨텍스트인 전역 객체를 가리켜버리기 때문이다. 이도 마찬가지로 this를 사용하고 싶다면 일반 함수를 사용하도록 하자.(이 때의 this는 이벤트 리스터에 바인딩된 요소를 가리킨다.)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;화살표-함수&quot;&gt;&lt;a href=&quot;#화살표-함수&quot; class=&quot;headerlink&quot; title=&quot;화살표 함수&quot;&gt;&lt;/a&gt;화살표 함수&lt;/h1&gt;&lt;p&gt;화살표 함수란 es5의 function키워드 대신 &lt;code&gt;=&amp;gt;&lt;/code&gt;를 사용하여 쉽
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES6" scheme="http://rootjang92.github.io/categories/Javascript/ES6/"/>
    
    
      <category term="javascript, es6, arrow" scheme="http://rootjang92.github.io/tags/javascript-es6-arrow/"/>
    
  </entry>
  
  <entry>
    <title>템플릿 리터럴</title>
    <link href="http://rootjang92.github.io/2018/11/08/template-literal/"/>
    <id>http://rootjang92.github.io/2018/11/08/template-literal/</id>
    <published>2018-11-08T02:08:42.000Z</published>
    <updated>2018-11-08T02:18:25.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="템플릿-리터럴"><a href="#템플릿-리터럴" class="headerlink" title="템플릿 리터럴"></a>템플릿 리터럴</h1><p>일반 문자열과 비슷해 보이는 템플릿 리터럴이지만 ES6에서는 백틱 문자를 도입했다.</p><pre><code>const template = `템플릿 리터럴은 백틱안에서 &apos;작은 따옴표&apos;, &quot;큰 따옴표&quot;를 사용할 수 있어요.!`console.log(template);</code></pre><p>백틱문자는 키보드의 물결표시와 함께 있다.</p><p>또한 일반 문자열에서 줄바꿈이 안되어 사용하던 white-space나 백슬래쉬(<code>\</code>)를 사용할 필요 없이 여러줄에 걸쳐서 사용이 가능하다.</p><pre><code>const soccerplayers = `&lt;ul class=&quot;player&quot;&gt;  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;램파드&lt;/a&gt;&lt;/li&gt;  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;제라드&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;`;console.log(soccerplayers);</code></pre><p><code>+</code>를 사용하지 않고 새로운 문자열을 삽입할 수도 있다.</p><pre><code>const first = &apos;Frank&apos;;const second = &apos;Lampard&apos;;console.log(&apos;I like &apos; + first + &apos; &apos; + second + &apos;.&apos;);console.log(`I like ${first} ${second}.`);</code></pre><p>${expression}을 템플릿 대입문이라고 한다. 문자열말고도 자바스크립트 표현식에서 사용할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;템플릿-리터럴&quot;&gt;&lt;a href=&quot;#템플릿-리터럴&quot; class=&quot;headerlink&quot; title=&quot;템플릿 리터럴&quot;&gt;&lt;/a&gt;템플릿 리터럴&lt;/h1&gt;&lt;p&gt;일반 문자열과 비슷해 보이는 템플릿 리터럴이지만 ES6에서는 백틱 문자를 도입했다.&lt;/p&gt;
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES6" scheme="http://rootjang92.github.io/categories/Javascript/ES6/"/>
    
    
      <category term="js, javascript, es6, template literal" scheme="http://rootjang92.github.io/tags/js-javascript-es6-template-literal/"/>
    
  </entry>
  
  <entry>
    <title>HTMLCanvas</title>
    <link href="http://rootjang92.github.io/2018/11/02/HTMLCanvas/"/>
    <id>http://rootjang92.github.io/2018/11/02/HTMLCanvas/</id>
    <published>2018-11-02T02:46:29.000Z</published>
    <updated>2018-11-02T02:48:12.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML-Canvas-만들기"><a href="#HTML-Canvas-만들기" class="headerlink" title="HTML Canvas 만들기"></a>HTML Canvas 만들기</h1><p>이 동영상과 코드는 Javascript 30 동영상 강의를 참조하였습니다.</p><a href="https://courses.wesbos.com/" target="_blank" rel="noopener">Javascript30</a><p>동영상 보기</p><iframe width="797" height="510" src="https://www.youtube.com/embed/YIhBLMhhlDA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><a href="https://github.com/Rootjang92/js30/tree/master/08-html5%20Canvas" target="_blank" rel="noopener">깃허브 보기</a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTML-Canvas-만들기&quot;&gt;&lt;a href=&quot;#HTML-Canvas-만들기&quot; class=&quot;headerlink&quot; title=&quot;HTML Canvas 만들기&quot;&gt;&lt;/a&gt;HTML Canvas 만들기&lt;/h1&gt;&lt;p&gt;이 동영상과 코드는 Javascr
      
    
    </summary>
    
      <category term="Project" scheme="http://rootjang92.github.io/categories/Project/"/>
    
      <category term="JS30" scheme="http://rootjang92.github.io/categories/Project/JS30/"/>
    
    
      <category term="JavaScript,js,es6, HTML Canvas" scheme="http://rootjang92.github.io/tags/JavaScript-js-es6-HTML-Canvas/"/>
    
  </entry>
  
  <entry>
    <title>JS30 - Ajax ahead example</title>
    <link href="http://rootjang92.github.io/2018/10/25/js303/"/>
    <id>http://rootjang92.github.io/2018/10/25/js303/</id>
    <published>2018-10-25T12:50:48.000Z</published>
    <updated>2018-10-25T12:56:32.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS30-Project-Ajax-Type-ahead"><a href="#JS30-Project-Ajax-Type-ahead" class="headerlink" title="JS30 Project - Ajax Type ahead"></a>JS30 Project - Ajax Type ahead</h1><p>유튜브 보기</p><iframe width="750" height="510" src="https://www.youtube.com/embed/M3ecTcf9aG4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><p>코드 보기</p><a href="https://github.com/Rootjang92/js30/tree/master/06-Ahead" target="_blank" rel="noopener">MyGithub</a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS30-Project-Ajax-Type-ahead&quot;&gt;&lt;a href=&quot;#JS30-Project-Ajax-Type-ahead&quot; class=&quot;headerlink&quot; title=&quot;JS30 Project - Ajax Type ahead&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Project" scheme="http://rootjang92.github.io/categories/Project/"/>
    
      <category term="JS30" scheme="http://rootjang92.github.io/categories/Project/JS30/"/>
    
    
      <category term="JavaScript, es6, javascript 30" scheme="http://rootjang92.github.io/tags/JavaScript-es6-javascript-30/"/>
    
  </entry>
  
  <entry>
    <title>플랙서블 박스 레이아웃에 대해 알아보자.</title>
    <link href="http://rootjang92.github.io/2018/10/19/flexbox/"/>
    <id>http://rootjang92.github.io/2018/10/19/flexbox/</id>
    <published>2018-10-19T02:04:03.000Z</published>
    <updated>2018-10-19T03:40:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flex-box-layout"><a href="#Flex-box-layout" class="headerlink" title="Flex box layout"></a>Flex box layout</h1><p>flexible box layout은 그리드 레이아웃을 기본으로 하여 플랙스 박스를 원하는 위치에 배치하는 것이다. 여유 공간에 따라 너비나 높이, 위치를 자유롭게 변형할 수 있고 화면 크기에 따라 에이아수의 배치나 크기를 조절할 때 편하게 이용 가능하다는 장점이 있다.</p><p><img src="https://poiemaweb.com/img/CSS3-Flexbox-Model.jpg" alt="flexbox"></p><p>flexbox를 사용하기 위해서는 부모 요소의 display 속성을 flex로 만들어야 한다. 이를 flex-container라고 한다. (부모 요소가 inline이라면 inline-flex)</p><p>이 flex-container에 담기는 자식 요소들을 flex-item이라고 한다.</p><p>main-axis는 플렉스 항목을 배치하는 기본 방향으로 기본적으로는 왼쪽에서 오른쪽(수평)으로 배치된다. flex 항목의 배치가 시작하는 점을 main start(주축 시작점), 끝을 main end(주축 끝점)이라고 한다.</p><p>cross-axis는 주축과 교차되는 방향을 나타낸다. cross start(교차축 시작점, cross end(교차축 끝점)으로 표현한다.</p><p>더 자세히 알고 싶다면 w3c의 표준 documents를 보는 것이 좋다.</p><a href="https://www.w3.org/TR/css-flexbox-1/" target="_blank" rel="noopener">표준</a><ul><li>기본 속성</li></ul><ul><li>display 속성을 flex-container에 지정하기</li></ul><p>flexible한 레이아웃을 만들기 위해서는 컨텐츠를 flex-container로 감싸 주어야 한다. 그 후 그 부모요소의 display값을 flex (inline 요소일 경우 inline-flex)로 만들어 주어야 한다.</p><p>주의할 점은 각 브라우저마다 지원 방법이 다르기 때문에 브라우저 접두사를 붙여주어야 한다는 것이다.</p><ul><li>flex-direction : 플렉스 방향</li></ul><p>이 속성은 배치를 row(가로)로 할지 column(세로)로 할지 결정하는 것이다. 기본 값은 row이다.</p><p>row(주축 가로, 교차축 세로 / 주축 시작 -&gt; 끝), row-inverse(주축 가로, 교차축 세로 / 주축끝 -&gt; 시작)<br>column(주축 세로, 교차축 가로 / 주축 시작 -&gt; 끝), column-inverse(주축 세로, 교차축 가로 / 주축 끝 -&gt; 시작)</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/d37610Lx/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/7bhceaf9/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>flex-wrap : 항목을 한 줄 혹은 여러 줄로 배치하기</li></ul><p>기본적으로는 주축을 따라 한 줄로 배치되지만 flex-wrap 속성을 통해 조절할 수 있다. no-wrap은 기본값으로 한 줄에 표시, wrap은 여러 줄에 표시, wrap-reverse는 여러 줄에 표시하지만 반대방향으로 배치하는 속성 값이다.</p><p>flex-wrap: wrap은 왼쪽에서 오른쪽으로 위에서 아래로 배치한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/tjqumfxn/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>flex-wrap: wrap-reverse은 왼쪽에서 오른쪽이지만 아래에서 위 방향으로 배치한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/prazju5h/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>flex-flow : flex-direction과 flex-wrap을 한꺼번에</li></ul><p>귀찮으니깐 한 번에 표시하자!</p><pre><code>flex-flox: row wrap;</code></pre><p>이런식으로 쓰면 된다.</p><ul><li>order : 배치 순서 바꾸기</li></ul><p>flex 항목은 입력한 순서대로 주축을 따라 배치되는데, order 속성을 사용하면 배치를 바꿀 수 있다. order:0이면 그대로 하며 숫자값이 바뀔 때마다 그 순서에 따라 배치된다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/stez07o5/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>flex : 항목 크기 조절하기</li></ul><p>플렉스 항목의 너비를 조절하는 속성이다.</p><p>flex-grow는 얼마나 늘일지, flex-shrink는 얼마나 줄일지, flex-basis는 기본 크기를 지정하는 속성값으로 0이나 auto를 지정한다.<br>initial은 항목의 width, height 값으로 결정하며 컨테이너 공간을 넘어갈 경우 최소 크기까지 줄인다.<br>auto는 항목의 width, height값으로 결정되지만 공간에 따라 늘이거나 줄일 수 있다.</p><p>예를 들어</p><pre><code>flex: [&lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt;] | auto | initialflex : 2 2 0;</code></pre><p>으로 설정하면 2배 늘이거나 2배 줄인다는 의미이다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/w9eo6f0b/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>flex 항목 배치 속성들</li></ul><ul><li>justify-content : 주축 기준의 배치 방법 지정</li></ul><p>이 속성은 flex 항목을 주축 방향으로 배치할 때의 배치 기준을 지정할 수 있다.</p><p>flex-start는 주축의 시작점을 기준으로 배치한다.<br>flex-end는 주축의 끝 점을 기준으로 배치한다.<br>center는 주축의 중앙을 기준으로 배치한다.<br>space-between은 첫 번째 flex 항목과 마지막 flex 항목을 시작점과 끝점에 배치한 후 가운데 항목들을 같은 간격으로 배치한다.<br>space-around는 모든 플렉스 항목들을 같은 간격으로 배치한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/xfthwog6/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>align-items, align-self : 교차축 기준의 배치</li></ul><p>교차축으로 배치 방법을 조절할 수 있다.</p><p><strong>align-items 속성들</strong></p><p>stretch : flex 항목을 확장하여 교차축을 꽉 채운다. (기본값)<br>flex-start: 교차축의 시작점을 기준으로 배치한다.<br>flex-end : 교차축의 끝점을 기준으로 배치한다.<br>center: 교차축의 중앙을 기준으로 배치한다.<br>baseline: 시작점과 글자 기준선이 가장 먼 flex 항목을 시작점에 배치한다. 그리고 그 글자의 기준선과 다른 항목의 기준선을 맞춰 배치한다. (예시로 보는게 빠릅니다.)</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/p4wua215/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p><strong>align-self 속성들</strong></p><p>align-self는 각 flex 항목들을 개별적으로 배치할 수 있다. 속성값들은 위와 같지만 auto 속성이 추가된다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/n6L5v02d/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>위 예제는 align-items 항목을 center로 지정한 후 box1 항목만 align-self를 flex-start로 지정했다.</p><ul><li>align-content : 여러 줄일 때의 배치 방법</li></ul><p>flex 항목이 여러 줄에 표시될 때 align-content 속성을 사용하면 교차축 방향 배치방법을 정할 수 있다. 속성값은 justify-contetn와 같다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/3dajos06/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>예제</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/5m8cjrna/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>(이미지는 찾아서 넣으시면 됩니다. 솔로라서 슬픈데 이런 예제를…)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flex-box-layout&quot;&gt;&lt;a href=&quot;#Flex-box-layout&quot; class=&quot;headerlink&quot; title=&quot;Flex box layout&quot;&gt;&lt;/a&gt;Flex box layout&lt;/h1&gt;&lt;p&gt;flexible box layou
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css, css3, css flex, flex box" scheme="http://rootjang92.github.io/tags/css-css3-css-flex-flex-box/"/>
    
  </entry>
  
  <entry>
    <title>미디어 쿼리</title>
    <link href="http://rootjang92.github.io/2018/10/16/mediaquery/"/>
    <id>http://rootjang92.github.io/2018/10/16/mediaquery/</id>
    <published>2018-10-16T02:48:32.000Z</published>
    <updated>2018-10-16T03:45:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="미디어-쿼리"><a href="#미디어-쿼리" class="headerlink" title="미디어 쿼리"></a>미디어 쿼리</h1><p>미디어 쿼리는 CSS3 모듈 중 하나로 사이트에 접속하는 장치에 따라 그에 맞는 css 스타일링을 하게 해준다. 즉, 다른 기기로 접속할 때마다 레이아웃이 바뀐다.</p><ul><li>구문</li></ul><p>구문은</p><pre><code>@media [only | not] 미디어 유형 [and 조건] * [and 조건]</code></pre><p>이런 식으로 작성한다. 대소문자 구별이 없고 style 태그 내에서 사용한다. 여기서 only는 미디어쿼리를 지원하는 웹 브라우저에서만 동작하게, not은 지정하는 미디어 유형을 제외하는 것이다. 유형의 종류에는 all(모두), print(인쇄 장치), screen, tv, aural(음성 장치), braille(점자 표시), handheld(패드), projection(프로젝터)가 있다.</p><ul><li>조건</li></ul><p>미디어 쿼리는 조건 체크가 중요하다. 조건에 따라 css가 적용되기 때문이다.</p><ul><li>웹 문서의 가로, 세로</li></ul><p>뷰포트의 너비와 높이를 미디어 쿼리의 조건으로 사용할 수 있다. 예를 들어서</p><pre><code>@media all (min-width: 600px) and (max-width: 959px)</code></pre><p>이라고 하면 모든 장치의 뷰포터의 너비가 600이상 959이하일 때 적용한다는 의미이다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/e5qxmpjg/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>화면의 너비를 늘였다 줄였다 해보면 어떻게 변화하는 지 볼 수 있을 것이니 코드를 직접 작성해보길 바란다.</p><ul><li>단말기의 가로, 세로</li></ul><p>device-width, device-height로 측정하고 앞에 min, max를 붙여 최소, 최대값을 나타낼 수 있다.</p><ul><li>화면 회전</li></ul><p>스마트폰이나 태블릿은 가로모드 혹은 세로 고정 모드가 있다. 즉 화면을 회전시킬 수 있다. 미디어 쿼리에서는 orientation 속성을 통해서 회전을 지정할 수 있다.<br>orientation:portrait는 세로방향, orientation: landscape는 가로 방향이다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/un42wv5b/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>개발자 도구의 디바이스 모드에서 확인해볼 수 있다.</p><ul><li>화면 비율과 단말기의 물리적 화면 비율</li></ul><p>aspect-ratio 속성은 너비 값을 높이 값으로 나눈 것으로 계산이 가능하다. 예를 들어 화면 비율이 16:9라고 가정했을 때</p><pre><code>@media all and (device-aspect-ratio: 16/9)</code></pre><p>이런 식으로 작성할 수 있다.</p><ul><li>색상 비트 수</li></ul><p>단말기의 최대 색상 비트 수를 미디어 쿼리로 사용할 수 있다. 속성은 color이다. 예를 들어 color:4이면 2^4 즉 16가지의 색상을 표현할 수 있다. 만약 컬러를 지원하지 않는다면 color:0으로 설정하면 된다.</p><ul><li>중단점 만들기</li></ul><p>미디어 쿼리 작성 시 다른 css를 적용할 화면 크기를 중단점이라고 한다. 보통은 모바일, 태블릿, 데스크탑 정도로만 구분한다. (모든 크기를 맞추긴 힘들기 때문에)<br>또한 처리 속도나 화면의 크기 등을 고려했을 때 모바일의 제약 조건이 많기 때문에 모바일을 기본으로 css를 만든다.</p><ul><li>외부 css 연결하기</li></ul><ul><li>link 태그 사용하기</li></ul><p>가장 많이 사용하는 방법이다. (css) head태그 사이에 삽입한다.</p><pre><code>&lt;link rel=&quot;stylesheet&quot; media=&quot;조건&quot; href=&quot;주소&quot;&gt;</code></pre><p>즉 미디어에 따른 스타일 시트 파일을 만들어 놓았다면 조건을 좀 더 추가해서 사용할 수도 있다.</p><ul><li>@import 구문</li></ul><p>@import 구문은 style태그 사이에 만든다.</p><pre><code>@import url(&quot;css/tablet.css&quot;) only screen and (min-width:321px) and (max-width:768px)</code></pre><p>이런 식으로 사용한다.</p><p>둘의 차이는 크지 않으나 많은 css 파일을 사용할 때에는 <strong>link 태그</strong>가 좀 더 처리 속도가 빠르다. 또한 IE의 경우 @import구문과 js가 함께 있으면 js를 먼저 다운로드하기 때문에 자바스크립트에서 스타일 처리를 할 경우 오류가 날 가능성이 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/7819xhpk/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>모바일용 미디어쿼리이다. (div부분은 이미지파일을 가져오기 힘들어 임의로 넣었습니다.)</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/xj5hLb6o/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>테블릿용이다. 이미지는 본인이 직접 넣어서 적용해보면 된다. (css 그대로입니다.)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;미디어-쿼리&quot;&gt;&lt;a href=&quot;#미디어-쿼리&quot; class=&quot;headerlink&quot; title=&quot;미디어 쿼리&quot;&gt;&lt;/a&gt;미디어 쿼리&lt;/h1&gt;&lt;p&gt;미디어 쿼리는 CSS3 모듈 중 하나로 사이트에 접속하는 장치에 따라 그에 맞는 css 스타일링을
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css, css3, css mediaquery" scheme="http://rootjang92.github.io/tags/css-css3-css-mediaquery/"/>
    
  </entry>
  
  <entry>
    <title>가변 레이아웃과 가변 요소</title>
    <link href="http://rootjang92.github.io/2018/10/15/fluid/"/>
    <id>http://rootjang92.github.io/2018/10/15/fluid/</id>
    <published>2018-10-15T02:03:10.000Z</published>
    <updated>2018-10-15T02:55:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="가변-레이아웃과-가변-요소"><a href="#가변-레이아웃과-가변-요소" class="headerlink" title="가변 레이아웃과 가변 요소"></a>가변 레이아웃과 가변 요소</h1><h2 id="가변-글꼴"><a href="#가변-글꼴" class="headerlink" title="가변 글꼴"></a>가변 글꼴</h2><p>보통 우리는 텍스트 크기를 px단위로 지정한다. 하지만 px단위로 지정하게 되면 화면에 크기가 고정되기 떄문에 작은 기기에서 매우 작게 표시되는 상황이 발생한다.<br>가변 그리드 레이아웃을 사용할 때는 글자 크기도 유동적으로 변해야 하는데 그 때 사용하는 것이 ‘가변 글꼴’이다.</p><ul><li>em 단위</li></ul><p>em단위는 부모 요소에서 지정한 폰트의 대문자 M의 넓이를 1em으로 지정한 것이다. (1em = 16px) 따라서 이미 px로 표시한 글자의 크기를 16px로 나누면 em값으로 계산이 가능하다.</p><p>em = px / 16px</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/xfm467cu/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>여기서 2em은 32px이다. (크롬 인스펙터에서 Computed를 확인해보길 바란다.)</p><ul><li>rem 단위</li></ul><p>em 단위는 부모 요소의 글꼴을 기준으로 하기 때문에 부모 요소의 크기에 따라 글자 크기가 달라진다. 이러한 점은 보완하는 단위가 rem 단위이다. rem은 처음부터 기본 크기를 지정하기 때문에 중간에 기본값이 바뀌지 않는다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/z12ywLmr/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>가변 이미지</li></ul><p>이미지 또한 크기가 정해져있기 때문에 가변 이미지 형태로 만들어 창의 너비에 따라 이미지 너비도 적절히 조절할 수 있다.</p><ul><li>css 이용하기</li></ul><p>css에 max-width 속성값은 100%로 하면 이미지와 너비가 바뀐다.</p><p><img src="/images/fluid-img.png" alt="fluid-img"></p><p><img src="/images/fluid-img2.png" alt="fluid-img2"></p><ul><li>img 태그와 srcset 속성</li></ul><p>max-width 속성을 언제든지 사용할 수 있다면 참 좋겠지만, 고해상도 이미지를 크기만 줄인다면 파일 사이즈 크기 떄문에 모바일에서는 시간이 더 오래걸린다. 또한 텍스트가 포함되어 있다면 크기가 줄었을 때 텍스트를 알아보기가 힘들어진다. 이 때 사용하는 것이 img 태그에 srcset 속성이다.</p><pre><code>&lt;img src=&quot;&lt;img&gt;&quot; srcset=&quot;&lt;img&gt;[,]&quot;&gt;</code></pre><p>[]안에는 화면 너비가 달라질 때마다 표시할 이미지를 나열한 것이다. 이 때 픽셀 밀도를 함께 표시하여야 한다.</p><ul><li>picture 태그와 source 태그</li></ul><p>두 태그는 상황별로 다른 이미지를 표시하는 태그이다. 둘을 함께 사용한다면 해상도나 화면 너비에 따른 이미지 파일을 표시할 수 있다.</p><pre><code>&lt;picture&gt;  &lt;source srcset=&quot;&lt;img-large&gt;&quot; media=&quot;(min-width)&quot;&gt;  &lt;img src=&quot;&lt;img&gt;&quot; style=&quot;width&quot;&gt;&lt;/picture&gt;</code></pre><ul><li>가변 비디오</li></ul><p>이미지와 마찬가지로 비디오도 max-width:100%를 사용할 수 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/98jfvdwm/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;가변-레이아웃과-가변-요소&quot;&gt;&lt;a href=&quot;#가변-레이아웃과-가변-요소&quot; class=&quot;headerlink&quot; title=&quot;가변 레이아웃과 가변 요소&quot;&gt;&lt;/a&gt;가변 레이아웃과 가변 요소&lt;/h1&gt;&lt;h2 id=&quot;가변-글꼴&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css, css3, css fluid elements" scheme="http://rootjang92.github.io/tags/css-css3-css-fluid-elements/"/>
    
  </entry>
  
  <entry>
    <title>반응형 웹이란?</title>
    <link href="http://rootjang92.github.io/2018/10/12/reactiveweb/"/>
    <id>http://rootjang92.github.io/2018/10/12/reactiveweb/</id>
    <published>2018-10-12T04:36:36.000Z</published>
    <updated>2018-10-12T05:17:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="반응형-웹이란-무엇일까"><a href="#반응형-웹이란-무엇일까" class="headerlink" title="반응형 웹이란 무엇일까?"></a>반응형 웹이란 무엇일까?</h1><p>많은 웹 사이트가 데스크탑 위주로 만들어 지긴 하지만, 모바일 시장이 점점 발전하고 스마트폰 보급이 많아지면서 어디서 접속하든 화면을 보는데 불편함이 없게 만들고자 하는 디자인 형태가 늘어나고 있다. 이를 반응형 웹 디자인이라고 한다.</p><h2 id="모바일-기기와-웹-디자인"><a href="#모바일-기기와-웹-디자인" class="headerlink" title="모바일 기기와 웹 디자인"></a>모바일 기기와 웹 디자인</h2><p>스마트폰에서 웹을 사용하는 일이 더 많아지면서 반응형 웹은 이제 흔히 볼 수 있게 되었다. 그래서 포털 사이트, 쇼핑몰 등이 모바일 전용 사이트를 따로 만들어내기 시작하였다. 근데 솔직히 언제 하나하나 다 만들고 있을지 의문이다. 그렇기 때문에 하나의 웹 사이트에서도 크기에 맞게 웹 사이틀 표시하게 만든 것이 반응형 웹 이다.</p><ul><li>반응형 웹의 장점</li></ul><ol><li><p>어떤 스마트 기기던지 접속할 수 있다.<br>단 W3C의 웹 표준으로 만든다면!</p></li><li><p>스마트 폰이나 태블릿 가로 모드의 맞춰 레이아웃을 변경할 수 있다.<br>개인적으로 이게 제일 신기하다.</p></li><li><p>사이트 유지와 관리가 용이해진다.<br>사이트를 하나하나 만드는 것이 아니기 때문이다.</p></li></ol><h2 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h2><p>반응형 웹의 기본 중 하나는 뷰포트를 알고 가는 것이다. pc화면과 모바일 기기의 픽셀 표현방법이 다르기 때문이다. 뷰포트는 스마트폰 화면에서 표시되는 실제 영역이다. webkit 기반의 모바일 브라우저들의 기본 뷰포트는 980px이다. 결국 스마트폰의 비율인 320px에 맞춰 웹 사이트를 제작해도 스마트폰의 모바일 브라우저의 기본 뷰포트가 980px이기 때문에 글씨와 그림이 작아진다.</p><p>그래서 뷰포트를 따로 설정해 줘야 한다.</p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;&quot;&gt;</code></pre><p>이 때 content안의 속성은 width, height, user-scalable, initial-scale, minimum-scale, maximum-scale이 있다.</p><h2 id="가변-그리드-레이아웃-만들기"><a href="#가변-그리드-레이아웃-만들기" class="headerlink" title="가변 그리드 레이아웃 만들기"></a>가변 그리드 레이아웃 만들기</h2><ul><li>고정 그리드와 가변 그리드</li></ul><p>grid system은 사이트 전체의 디자인이나 일관성을 유지하는 데 편안하다. 그리드 시스템이란 화면을 몇가지 column으로 나누어 요소들을 배치할 때 사용하는 것이다.</p><p>고정 그리드 아웃은 화면 너비를 특정값으로 지정하여 그 안에 표시할 요소들의 너비 값을 지정하기 때문에 배치가 굉장히 편하다. 반면 기기에 상관없이 동일한 레이아웃을 위해서는 각 요소의 너비를 백분율과 같은 가변 값으로 지정해줘야 한다.</p><p>고정 그리드</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/rez8x0k5/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>코드를 직접 입력해보고 창을 줄였다 늘였다하면서 비교해보면 좋을 것 같다.</p><p>가변 그리드</p><p>우선 전체를 감싸는 요소를 확인한다. 고정된 픽스값이 아니라 너비를 백분율로 표시하는 것이 좋다. 그 후 각 요소의 너비 값을 계싼해서 지정해야 한다.<br>(요소의 너비 / 콘텐츠 전체를 감싸는 요소의 너비) * 100</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/oLx5uqtp/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;반응형-웹이란-무엇일까&quot;&gt;&lt;a href=&quot;#반응형-웹이란-무엇일까&quot; class=&quot;headerlink&quot; title=&quot;반응형 웹이란 무엇일까?&quot;&gt;&lt;/a&gt;반응형 웹이란 무엇일까?&lt;/h1&gt;&lt;p&gt;많은 웹 사이트가 데스크탑 위주로 만들어 지긴 하지
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css, css3, 반응형 웹, reactive web" scheme="http://rootjang92.github.io/tags/css-css3-%EB%B0%98%EC%9D%91%ED%98%95-%EC%9B%B9-reactive-web/"/>
    
  </entry>
  
  <entry>
    <title>애니메이션</title>
    <link href="http://rootjang92.github.io/2018/10/07/cssanimation/"/>
    <id>http://rootjang92.github.io/2018/10/07/cssanimation/</id>
    <published>2018-10-07T03:44:46.000Z</published>
    <updated>2018-10-07T04:15:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="애니메이션-알아보기"><a href="#애니메이션-알아보기" class="headerlink" title="애니메이션 알아보기"></a>애니메이션 알아보기</h1><p>트랜스폼과 트랜지션 등으로 애니메이션 효과를 만들 수도 있지만, animation 속성을 이용하면 더욱 쉽게 애니메이션을 만들 수 있다.</p><h2 id="CSS와-애니메이션"><a href="#CSS와-애니메이션" class="headerlink" title="CSS와 애니메이션"></a>CSS와 애니메이션</h2><p>자바스크립트나 플래시 대신에 웹 요소에 애니메이션을 추가하는 기능이다. 트랜지션과 비슷한 점은 시작부터 끝 스타일까지의 스타일을 지정한다는 점이다. 하지만 애니메이션은 원하는 곳에 스타일을 바꾸며 애니메이션을 적용할 수 있다는 점에서 다르다. (여기서 사용하는 개념이 keyframes)</p><ul><li>@keyframes : 지점 설정하기</li></ul><p>시작과 끝을 비롯해 상태가 바뀌는 부분에 이 속성을 이용하여 지정한다.</p><pre><code>@keyframes &lt;이름&gt; {  &lt;선택자&gt; { &lt;스타일&gt; }}</code></pre><p>이름으로 애니메이션을 구분하고 선택자로 속성 값이 바뀌는 지점을 선택해준다. 백분율 혹은 from ~ to를 사용할 수 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/wmg05jy9/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>animation-name : 이름 정하기</li></ul><p>말 그대로 애니메이션의 이름을 정하는 속성이다. 위 예제처럼 change-bg라는 이름을 붙여 사용한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/hy5ep0fg/3/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>animation-direction : 방향 지정</li></ul><p>원래 위치로 되돌리거나 반대 방향으로 애니메이션을 한 번 더 실행시킬 수 있다. 속성값으로는 normal(원래 위치로 , 기본값), alternate(왔던 방향으로 되돌아감)</p><ul><li>animation-iteration-count : 반복 횟수 지정하기</li></ul><p>애니메이션이 실행되는 횟수를 지정한다. 숫자로 지정할 수 있고 infinite(무한)반복이 가능하다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/4opuzL90/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>animation-timing-function : 속도 곡선 지정하기</li></ul><p>시작과 중간 끝에 속도를 선택해서 전체적인 속도를 지정할 수 있다.</p><pre><code>animation-timing-function: linear | ease | ease-in | ease-out | ease-in-out | cubic-bezier</code></pre><ul><li>animation : 한 번에 설정하기</li></ul><p>이것저것 다 지정하면 엄청 긴 코드가 작성될 것이다. 그냥 한 번에 쓰자. 하지만 주의할 점은 animation-duration은 반드시 표기를 하여야 한다. 실행 시간을 지정하지 않으면 기본 값인 0이 지정되기 때문에 애니메이션 효과를 볼 수 없다. 또한 시간 관련 된 값이 2개라면 첫 번째는  animation-time, 두 번째는 animation-delay로 인지한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/L7s0tcqk/6/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;애니메이션-알아보기&quot;&gt;&lt;a href=&quot;#애니메이션-알아보기&quot; class=&quot;headerlink&quot; title=&quot;애니메이션 알아보기&quot;&gt;&lt;/a&gt;애니메이션 알아보기&lt;/h1&gt;&lt;p&gt;트랜스폼과 트랜지션 등으로 애니메이션 효과를 만들 수도 있지만, an
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css, css3, css animation, keyframes" scheme="http://rootjang92.github.io/tags/css-css3-css-animation-keyframes/"/>
    
  </entry>
  
  <entry>
    <title>트랜지션</title>
    <link href="http://rootjang92.github.io/2018/10/06/transition/"/>
    <id>http://rootjang92.github.io/2018/10/06/transition/</id>
    <published>2018-10-06T03:07:56.000Z</published>
    <updated>2018-10-06T03:43:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="트랜지션과-애니메이션-살펴보기"><a href="#트랜지션과-애니메이션-살펴보기" class="headerlink" title="트랜지션과 애니메이션 살펴보기"></a>트랜지션과 애니메이션 살펴보기</h1><h2 id="트랜지션"><a href="#트랜지션" class="headerlink" title="트랜지션?"></a>트랜지션?</h2><p>트랜지션은 웹 요소의 배경 색, 도형 테두리 변경 등 스타일 속성을 변화시키는 것을 말한다. 예를 들어 마우스를 올려 놓았을 때 배경색이 바뀐다던지, 테두리가 사격형에서 원형으로 바뀐다던 지의 변화들을 말하는 것이다.</p><ul><li>transition-property : 트랜지션을 적용할 속성 지정</li></ul><p>트랜지션을 어느 속성에 적용할 지 정하는 속성이다. 속성 값에는 all(모든 요소, 생략 가능), none, 속성이름 등이 있다.</p><pre><code>transition-property: all; /* 해당 요소의 모든 속성 */transition-property: none; /* 아무것도 적용되지 않음 */transition-property: beckground-color; /* 해당 요소의 배경색에 트랜지션 적용 */</code></pre><ul><li>transition-duration : 트랜지션 시간 정하기</li></ul><p>트랜지션 대상을 지정한 후, 진행 시간을 지정하는 속성이 바로 transition-duration 이다. 기본은 0초이며 초 혹은 밀리초로 지정할 수 있다. 또한 쉼표를 이용하여 순서대로 여러 개를 지정할 수 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/qL6n1ckx/1/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>만약 transition-property 속성을 4개 지정하고 transition-duration을 2개 지정했다면 2개의 속성 씩 반복 적용된다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/6u719hcq/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>transition-timing-function : 트랜지션 속도 곡선 지정</li></ul><p>천천히 시작하다가 빨라지거나 하는 속도를 지정할 수 있는 속성이다. 속성 값에는 linear(같은 속도로), ease(천천히-빠르게-천천히, 기본값)<br>ease-in(시작을 느리게), ease-out(끝을 느리게), ease-in-out(느리게 시작하고 느리게 끝), cubic-bezier(n,n,n,n)(베지에 함수를 직접 정의 n은 0~1)</p><ul><li>transition-delay : 지연 시간 설정</li></ul><p>시작 시간을 언제로 시작할 것인지를 설정하는 속성이다. 초나 밀리초를 사용하며 기본값은 0s이다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/seyb5L20/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>transition : 한꺼번에 설정하기</li></ul><p>단 트랜지션 적용 대상을 한정할 시에는 따로따로 지정해주는 게 좋다. 하지만 전체적으로 적용할 때 실행시간이 다르지 않다면 한 번에 하는 것이 편하다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/cyvb85a4/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;트랜지션과-애니메이션-살펴보기&quot;&gt;&lt;a href=&quot;#트랜지션과-애니메이션-살펴보기&quot; class=&quot;headerlink&quot; title=&quot;트랜지션과 애니메이션 살펴보기&quot;&gt;&lt;/a&gt;트랜지션과 애니메이션 살펴보기&lt;/h1&gt;&lt;h2 id=&quot;트랜지션&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css, css transition" scheme="http://rootjang92.github.io/tags/css-css-transition/"/>
    
  </entry>
  
  <entry>
    <title>CSS 애니메이션 - 변형</title>
    <link href="http://rootjang92.github.io/2018/10/04/csstransform/"/>
    <id>http://rootjang92.github.io/2018/10/04/csstransform/</id>
    <published>2018-10-04T02:37:34.000Z</published>
    <updated>2018-10-04T03:32:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-Transform"><a href="#CSS-Transform" class="headerlink" title="CSS Transform"></a>CSS Transform</h1><p>특정 요소의 크기나 형태가 변하는 것을 변형이라고 한다. 웹에서도 마찬가지로 css를 이용하여 텍스트나 이미지 등을 움직이게 할 수 있다.</p><h2 id="2차원과-3차원-변형"><a href="#2차원과-3차원-변형" class="headerlink" title="2차원과 3차원 변형"></a>2차원과 3차원 변형</h2><p>2차원 변형은 x,y 축, 즉 수평 혹은 수직으로 이동하고 회전시키는 것을 말한다. x축은 오른쪽으로 y축은 아래쪽으로 이동한다.<br>3차원 변형은 x,y 축에 z라는 원근감을 주는 요소를 추가하여 변형시킨다. 보는 사람 쪽으로 다가올 수록 값이 커진다.</p><ul><li>transform과 변형 함수</li></ul><p>이 때 사용하는 것이 transform 속성이다.</p><pre><code>.photo { transform: translate(50px, 100px); }</code></pre><p>2차원 변형 함수에는 translate(x,y), scale(x,y),rotate(degree), skew(x,y)가 있다.<br>translate는 이동, scale은 확대/축소, rotate는 회전, skew는 왜곡이다.</p><p>3차원 변형 함수에는 matrix3d(n,[, n]), translate3d(x,y,z), scale3d(x,y,z), rotate3d(x,y,z),rotateX,rotateY,rotateZ, perspective(길이)가 있다.</p><p>matrix3d는 4*4행렬을 이용해 이동, 확대/축소, 회전 등의 변환을 지정할 수 있다.<br>그 외에는 모두 같고 perspective는 입체적으로 보일 수 있는 깊이 값을 지정하는 것이다.</p><ul><li>translate : 요소 이동</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/snkxu5b6/2/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>scale : 요소 확대/축소</li></ul><p>숫자로 얼만큼 확대할 것인지 지정할 수 있다. (몇 배로 확대할 것인지)</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/hfecx7w2/3/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>rotate : 요소 회전하기</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/98k6w0vt/7/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>skew : 요소 왜곡하기</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/vksqfgap/2/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="변형-관련-속성들"><a href="#변형-관련-속성들" class="headerlink" title="변형 관련 속성들"></a>변형 관련 속성들</h2><ul><li>transform-origin : 변형 기준점 설정하기</li></ul><p>이 속성을 사용하면 x,y,z 축이 아닌 다른 지점을 변형의 기준으로 설정할 수 있다. 2차원, 3차원 변형 모두 적용할 수 있다.</p><ul><li>perspective, perspective-origin : 원근감 표현하기</li></ul><p>3차원 변형 속성으로 원근감을 갖게 한다. 속성값은 0보다 커야한다. 또한 perspective-origin을 사용하면 더 높은 곳에서 원근을 조절하는 느낌을 받을 수 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/azuo185f/3/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>transform-style : 3D 변형 적용하기</li></ul><p>여러 가지 변형을 동시에 적용할 땐 이 속성을 사용하면 된다. 속성값으로는 flat(하위 요소 평면 처리), preserve-3d(하위 요소들 3d적용)<br>이 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/o53r187t/9/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>backface-visibility : 요소의 뒷면 표시</li></ul><p>요소 회전 시 각도가 90도가 넘으면 뒷면이 보이는 데, 그 때의 표시 유무를 지정할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS-Transform&quot;&gt;&lt;a href=&quot;#CSS-Transform&quot; class=&quot;headerlink&quot; title=&quot;CSS Transform&quot;&gt;&lt;/a&gt;CSS Transform&lt;/h1&gt;&lt;p&gt;특정 요소의 크기나 형태가 변하는 것을 변형이라
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css,css3, css transform" scheme="http://rootjang92.github.io/tags/css-css3-css-transform/"/>
    
  </entry>
  
  <entry>
    <title>JS30 - 시계만들기</title>
    <link href="http://rootjang92.github.io/2018/10/02/js302/"/>
    <id>http://rootjang92.github.io/2018/10/02/js302/</id>
    <published>2018-10-02T07:24:29.000Z</published>
    <updated>2018-10-02T07:25:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS와-CSS로-시계-만들기"><a href="#JS와-CSS로-시계-만들기" class="headerlink" title="JS와 CSS로 시계 만들기"></a>JS와 CSS로 시계 만들기</h1><p>코드 설명은 추후에 만들기로…</p><p>유튜브 보기</p><iframe width="560" height="315" src="https://www.youtube.com/embed/JHrBJF7jDz4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><p>코드 보기<br><a href="https://github.com/Rootjang92/js30" target="_blank" rel="noopener">MyGithub</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS와-CSS로-시계-만들기&quot;&gt;&lt;a href=&quot;#JS와-CSS로-시계-만들기&quot; class=&quot;headerlink&quot; title=&quot;JS와 CSS로 시계 만들기&quot;&gt;&lt;/a&gt;JS와 CSS로 시계 만들기&lt;/h1&gt;&lt;p&gt;코드 설명은 추후에 만들기로…&lt;/
      
    
    </summary>
    
      <category term="Project" scheme="http://rootjang92.github.io/categories/Project/"/>
    
      <category term="JS30" scheme="http://rootjang92.github.io/categories/Project/JS30/"/>
    
    
      <category term="javascript,js,es6,clock" scheme="http://rootjang92.github.io/tags/javascript-js-es6-clock/"/>
    
  </entry>
  
  <entry>
    <title>CSS 선택자</title>
    <link href="http://rootjang92.github.io/2018/10/02/cssselector/"/>
    <id>http://rootjang92.github.io/2018/10/02/cssselector/</id>
    <published>2018-10-02T04:10:05.000Z</published>
    <updated>2018-10-02T05:10:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-선택자-알아보기"><a href="#CSS-선택자-알아보기" class="headerlink" title="CSS 선택자 알아보기"></a>CSS 선택자 알아보기</h1><h2 id="연결-선택자"><a href="#연결-선택자" class="headerlink" title="연결 선택자"></a>연결 선택자</h2><p>combination selector라고도 부른다.</p><ul><li>하위 선택자 : 지정한 하위 요소에 스타일 적용하기</li></ul><p>예제 코드를 살펴보자</p><pre><code>div p { color: blue }</code></pre><p>여기서 div는 상위 요소 p는 하위 요소이다. 이 코드를 해석하자면 div 태그안에 있는 모든 p태그에 css 요소를 적용하겠다는 의미이다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/0u1dq8ks/2/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>예제를 보면 ul태그 모두 section의 하위 요소에 속하기 때문에 모두 적용되는 것을 볼 수 있다.</p><ul><li>자식 선택자 : 자식 요소에만 스타일 적용하기</li></ul><p>부모 요소의 자식 요소에만 스타일을 적용하는 방법도 있다.</p><pre><code>section &gt; p { color: blue }</code></pre><p>하위 요소 전체가 아닌 section 요소 안에 포함된 p 요소 중 자식 p요소에만 스타일을 적용하겠다는 의미이다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/hgjqcbp6/1/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>여기서는 container의 자식인 첫 번째 ul요소에만 스타일이 적용된다.</p><ul><li>인접 형제 선택자</li></ul><p>문서 구조상 같은 부모를 가진 형제 요소 중 첫 번째 동생 요소에만 스타일을 적용할 때 사용한다.</p><pre><code>h1 + p { text-decoration: underline; }</code></pre><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/ws8oecx1/2/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>형제 선택자</li></ul><p>인접 형제 선택자와 달리 모든 형제 요소에 적용된다. 인접 형제 선택자에선 ‘+’ 기호를 사용했다면 형제 선택자에선 ‘~’ 기호를 사용한다.</p><h2 id="속성-선택자"><a href="#속성-선택자" class="headerlink" title="속성 선택자"></a>속성 선택자</h2><ul><li>‘[속성]’ 선택자 : 지정한 속성에 스타일 적용</li></ul><p>특정 요소에 스타일을 적용시킨다. 대괄호 사이에 찾으려는 속성을 넣으면 된다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/fvn8oe74/2/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>[속성 = 값] : 특정 값을 갖는 속성에 스타일 적용</li></ul><p>위 예제에서</p><pre><code>a[target=&quot;_blank&quot;] { ... }</code></pre><p>라고 입력하면 target=”_blank”인 링크를 찾아 스타일을 적용시킨다.</p><ul><li>[속성 ~= 값] : 여러 값 중 특정 값이 포함된 소성에 스타일 적용</li></ul><p>[속성 = 값]이 속성과 값이 정확히 일치하는 요소를 찾는다면 [속성 ~= 값]은 여러 속성 값 중 해당 값이 포함되어 있는 요소를 선택한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/4rdLno59/2/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>[속성 |= 값] : 특정 값이 포함된 속성에 스타일 적용</li></ul><p>이 때 값은 한 단어로 같아야 한다. 단어가 포함된 하이픈 연결 단어도 스타일이 적용된다.</p><ul><li>[속성 ^= 값] : 특정 값으로 시작하는 속성에 스타일 적용</li></ul><p>^는 캐럿이라고 한다. 캐럿이 붙으면 지정한 문자로 시작하는 속성 값에 대해서만 스타일을 적용시킨다.</p><ul><li>[속성 $= 값] : 특정 값으로 끝나는 속성에 스타일 적용</li></ul><p>반대로 $는 지정한 문자로 끝나는 속성에 스타일을 적용시킨다.</p><ul><li>[속성 *= 값] : 값의 일부가 일치하는 속성에 스타일 적용</li></ul><p>사용자가 지정한 속성 값의 위치에 관계없이 값이 포함되어 있으면 스타일이 적용된다.</p><h2 id="가상-클래스와-가상-요소"><a href="#가상-클래스와-가상-요소" class="headerlink" title="가상 클래스와 가상 요소"></a>가상 클래스와 가상 요소</h2><ul><li>사용자 동작에 반응하는 가상 클래스</li></ul><p>사용자가 커서를 올린다던 지 클릭을 한다던지의 이벤트가 발생할 때 스타일이 바뀌도록 만들고 싶을 때 사용하는 것이 가상 클래스 선택자이다.</p><ol><li>:link</li></ol><p>하이퍼링크 중 사용자가 아직 방문하지 않은 링크에 스타일을 적용한다. 기본적으로 파란줄이 표시되는 것을 없애고 싶다거나 할 때에 사용한다.</p><ol start="2"><li>:visited</li></ol><p>링크 중 한 번 이상 방문한 링크에 대해 스타일을 적용한다.</p><ol start="3"><li>:hover</li></ol><p>요소에 마우스 커서를 올렸을 때 스타일을 지정한다. 롤오버 효과등이 그 예이다.</p><ol start="4"><li>:active</li></ol><p>요소를 활성화 시켰을 때 스타일을 지정하는 요소이다.</p><ol start="5"><li>:focus</li></ol><p>요소에 초점이 맞춰젔을 때 사용한다. 아이디를 입력하기 위해 텍스트 필드로 마우스 커서를 갖다 놓았을 때 등에 사용한다.</p><ul><li>주의할 점은 가상 클래스 선택자는 순서를 중요하게 해야한다. link, visited, hover, active 순으로 정의한다.</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/19kzwt2x/1/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>UI 요소 상태에 따른 가상 클래스</li></ul><p>User Interface 요소에 상태에 따른 가상 클래스는 화면 디자인할 때 상태 스타일을 지정하기 위해 사용한다.</p><ol><li>:enabled, :disabled : 요소를 사용할 수 있을 때와 없을 때</li></ol><p>둘의 차이를 예제로 설명하자면 회원가입은 사용자가 텍스트를 작성해야 하기 때문에 enabled 상태, 약관 등은 disabled 상태로 표시해야 한다.</p><ol start="2"><li>:checked : 라디오, 체크 박스에서 항목을 선택했을 때</li></ol><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/o970fqwa/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>구조 가상 클래스</li></ul><p>웹 문서의 구조를 기준으로 특정 위치에 있는 요소를 찾아서 스타일을 지정한다.</p><ol><li>:root</li></ol><p>문서 전체에 적용한다.</p><ol start="2"><li>:nth-child(n) , nth-last-child(n) : 자식 요소의 위치에 따른 스타일 적용</li></ol><p>특정 부분에 스타일을 적용하기 위해서는 보통 class나 id를 통해 이름을 붙여준다. 그러나 여러 개의 항목이 일렬로 나열되어 있다면, nth-child(n)을 사용하여 n번째 자식 요소에 스타일을 적용하거나 nth-last-child(n) 끝에서부터 n번째 자식 요소를 통해서 사용한다.<br>an+b 처럼 수식사용도 가능하다. 조금은 어려운 개념이므로 충분한 연습이 필요하다.<br>단, 위치에 따른 스타일 적용이기 때문에 해당 요소들이 모두 한 부모 요소를 가지고 있어야 한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/tpwvx671/2/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>다음 예제는 홀수 열에만 스타일을 적용시키는 예제이다.</p><ol start="3"><li>:nth-of-type(n), nth-last-of-type(n) : 특정 태그 위치에 스타일 적용하기</li></ol><ol start="4"><li>:first-child, :last-child : 첫번째, 마지막 자식 요소에 스타일 적용하기</li></ol><ol start="5"><li>:first-of-type, :last-of-type : 형제 관계 요소의 위치에 따른 스타일 적용</li></ol><p>형제 관계 요소 중에서 첫번째, 마지막 요소에 스타일을 적용한다.</p><ol start="6"><li>:only-child, :only-of-type : 하나뿐인 자식 요소에 스타일 적용하기</li></ol><p>부모 요소 중 자식 요소가 하나일 때 스타일을 적용한다. only-child는 다른 자식요소가 존재할 수 없고 only-of-type은 다른 자식 요소가 있어도 된다.</p><ul><li>그 외에 가상 요소</li></ul><ol><li>:target : 앵커 목적지에 스타일 적용</li></ol><p>다른 사이트로 이동할 때 링크를 이용하고, 같은 문서 안에서 다른 위치로 이동할 때에는 앵커를 사용한다.</p><ol start="2"><li>:not : 특정 요소가 아닐 때 스타일 적용</li></ol><ul><li>가상 요소</li></ul><ol><li>::first-line, ::first-letter : 첫 번째 줄과 첫 번째 글자에 스타일 적용</li></ol><ol start="2"><li>::before, ::after : 내용 앞 뒤에 콘텐츠 추가하기</li></ol><p>요소 앞 뒤에 텍스트, 이미지 등을 표시한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS-선택자-알아보기&quot;&gt;&lt;a href=&quot;#CSS-선택자-알아보기&quot; class=&quot;headerlink&quot; title=&quot;CSS 선택자 알아보기&quot;&gt;&lt;/a&gt;CSS 선택자 알아보기&lt;/h1&gt;&lt;h2 id=&quot;연결-선택자&quot;&gt;&lt;a href=&quot;#연결-선택자&quot;
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css, css3, css selector" scheme="http://rootjang92.github.io/tags/css-css3-css-selector/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 30 project Day 1 - Drum kit</title>
    <link href="http://rootjang92.github.io/2018/10/02/js301/"/>
    <id>http://rootjang92.github.io/2018/10/02/js301/</id>
    <published>2018-10-02T02:30:29.000Z</published>
    <updated>2018-10-02T02:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6로-Drum-kit-제작하기"><a href="#ES6로-Drum-kit-제작하기" class="headerlink" title="ES6로 Drum kit 제작하기"></a>ES6로 Drum kit 제작하기</h1><p>이 동영상과 코드는 Javascript 30 동영상 강의를 참조하였습니다.</p><a href="https://courses.wesbos.com/" target="_blank" rel="noopener">Javascript30</a><p>동영상 보기</p><iframe width="596" height="331" src="https://www.youtube.com/embed/eP1KufDzsK4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><p>깃허브 링크</p><a href="https://github.com/Rootjang92/js30" target="_blank" rel="noopener">MyGithub</a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6로-Drum-kit-제작하기&quot;&gt;&lt;a href=&quot;#ES6로-Drum-kit-제작하기&quot; class=&quot;headerlink&quot; title=&quot;ES6로 Drum kit 제작하기&quot;&gt;&lt;/a&gt;ES6로 Drum kit 제작하기&lt;/h1&gt;&lt;p&gt;이 동영상과
      
    
    </summary>
    
      <category term="Project" scheme="http://rootjang92.github.io/categories/Project/"/>
    
      <category term="JS30" scheme="http://rootjang92.github.io/categories/Project/JS30/"/>
    
    
      <category term="Javascript, js, es6, drum" scheme="http://rootjang92.github.io/tags/Javascript-js-es6-drum/"/>
    
  </entry>
  
  <entry>
    <title>HTML 멀티 미디어</title>
    <link href="http://rootjang92.github.io/2018/10/01/htmlmedia/"/>
    <id>http://rootjang92.github.io/2018/10/01/htmlmedia/</id>
    <published>2018-10-01T05:10:44.000Z</published>
    <updated>2018-10-01T05:39:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML-멀티미디어-관련-태그들"><a href="#HTML-멀티미디어-관련-태그들" class="headerlink" title="HTML 멀티미디어 관련 태그들"></a>HTML 멀티미디어 관련 태그들</h1><p>과거에 사용하던 플러그인은 문제가 많았다. 확장자 지원 문제도 그렇고 원하지 않는 툴바 등이 설치되는 경우도 있었다. 하지만 최근 플래시 플레이어가 거의 차단 된 만큼, html5에도 그와 관련된 태그가 생겨났다.</p><h2 id="object-태그-embed-태그"><a href="#object-태그-embed-태그" class="headerlink" title="object 태그, embed 태그"></a>object 태그, embed 태그</h2><p>이 태그들은 사실 플러그인을 지원하는 태그이지만, 아직 html5를 지원하지 않는 브라우저를 위해 알아두면 좋다.<br>object 태그는 자바 애플릿이나 pdf 파일 등을 웹 문서안에 포함시키기 위해 사용하는 태그이다. 다른 html 문서도 가능하다.</p><pre><code>&lt;object data=&quot;경로&quot; type=&quot;유형&quot; [name, width, height]&gt;&lt;/object&gt;</code></pre><p>많이 사용하지 않기 때문에 여기까지만 알아보도록 하자.</p><p>embed 태그는 웹 브라우저에서 재생할 수 없는 외부 파일을 삽입할 때 사용하는 태그이다. 더 오래된 태그이다.</p><h2 id="비디오-코덱"><a href="#비디오-코덱" class="headerlink" title="비디오 코덱"></a>비디오 코덱</h2><p>동영상 파일을 재생하기 위해 코덱이라는 용어를 많이 봤을 것이다. 그에 앞서 이 과정에서 촬영한 비디오를 압축해서 컴퓨터에서 사용할 수 있는 비디오 파일로 변환하는 과정인 인코딩이 있다면, 비디오 파일에 저장되어 있는 정보를 가져와 플레이어에 보여 주는 과정이 디코딩이다.</p><p>코덱이란 인코딩과 디코딩을 수행하는 것이다. 종료가 매우 다양하기 때문에 플레이어에선 코덱을 지원하게 되주는 파일을 지원하지만 html5에선 그게 아니기 때문에 크게 3가지 코덱을 사용하고 있다.</p><ol><li><p>H.264/AVC<br>mp4 파일에 사용하는 코덱이다. 대부분 멀티미디어 업계에서 표준으로 사용하고 있는 코덱이다.</p></li><li><p>v8, v9<br>구글 오픈 소스 코덱이다. 화질이 우수하고 무료이다. 파이어 폭스, 오페라, 크롬이 이 코덱을 사용한다.</p></li><li><p>Ogg Theora<br>H.264에 대응하는 무료 오픈 코덱이며 ogv 파일에서 사용한다. 단점은 모바일 브라우저에선 사용할 수 없다.</p></li></ol><p>주로 사용하는 오디오 코덱에는</p><ol><li><p>MPEG-1 AUDIO Layer3<br>MP3 코덱이다.</p></li><li><p>Ogg Vorbis<br>오픈 소스 코덱으로 ogg, oga 확장자를 사용한다. 무료이기 때문에 PC게임에서 많이 사용한다. 단점으로는 인코딩이 오~래 걸린다.</p></li></ol><h2 id="오디오와-비디오-재생하기"><a href="#오디오와-비디오-재생하기" class="headerlink" title="오디오와 비디오 재생하기"></a>오디오와 비디오 재생하기</h2><ul><li>audio 태그</li></ul><p>오디오를 재생하기 위한 태그이다.</p><pre><code>&lt;audio src=&quot;경로&quot; [속성] [속성=&quot;속성 값&quot;]&gt;&lt;/audio&gt;</code></pre><p>속성에는 autoplay, controls(컨트롤 막대 표시), loop(반복 재생), muted(소리만 끄기), preload(재생하기 전 오디오 파일 다운로드)<br>가 있다.</p><ul><li>video 태그</li></ul><p>비디오를 재생하기 위한 태그이다. audio 태그와 같다.</p><ul><li>source 태그</li></ul><p>여러 미디어를 한꺼번에 지정하는 태그이다.</p><ul><li>track 태그</li></ul><p>비디오 화면에 자막을 추가할 수 있다.</p><pre><code>&lt;track kind=&quot;자막 종류&quot; src=&quot;경로&quot; srclang=&quot;언어&quot; label=&quot;제목&quot; default&gt;</code></pre><p>kind 속성에 속성값에는 subtitles(다른 언어로 번역한 자막일 경우 사용), captions, descriptions(비디오 콘텐츠 설명), chapters(비디오 탐색을 위한 장 제목), metadata(비디오 콘텐츠 정보)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTML-멀티미디어-관련-태그들&quot;&gt;&lt;a href=&quot;#HTML-멀티미디어-관련-태그들&quot; class=&quot;headerlink&quot; title=&quot;HTML 멀티미디어 관련 태그들&quot;&gt;&lt;/a&gt;HTML 멀티미디어 관련 태그들&lt;/h1&gt;&lt;p&gt;과거에 사용하던 플
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="HTML" scheme="http://rootjang92.github.io/categories/HTML-CSS/HTML/"/>
    
    
      <category term="html,html5, html video, html audio" scheme="http://rootjang92.github.io/tags/html-html5-html-video-html-audio/"/>
    
  </entry>
  
  <entry>
    <title>ES6의 변수와 블록 레벨 스코프</title>
    <link href="http://rootjang92.github.io/2018/09/25/es6value/"/>
    <id>http://rootjang92.github.io/2018/09/25/es6value/</id>
    <published>2018-09-25T09:34:26.000Z</published>
    <updated>2018-09-26T08:06:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6의-변수-선언과-블록-레벨-스코프"><a href="#ES6의-변수-선언과-블록-레벨-스코프" class="headerlink" title="ES6의 변수 선언과 블록 레벨 스코프"></a>ES6의 변수 선언과 블록 레벨 스코프</h1><p>요즘 핫한 JS 관련 문법은 Typescript이다. 타입 선언이 가능할 뿐만 아니라 js의 모든 문법을 사용할 수도 있고, 제네릭 등의 기타 편리한 요소가 추가되었다. 이를 익히기 위해선 기본적으로 ES6에 대한 지식이 필요하다. 그래서 오늘부터 며칠간 ES6의 기본 문법에 대해 알아보고자 한다.</p><h2 id="let-const"><a href="#let-const" class="headerlink" title="let, const"></a>let, const</h2><p>es5의 변수 선언은 var 키워드를 통해 했었다. 하지만 var 키워드의 문제점이 있었다. 우선 <strong>함수 레벨 스코프</strong>였기 떄문에 전역 변수를 남발할 수 있었고 변수의 참조 범위에 대한 문제도 있었다. 또한 <strong>var 키워드의 생략을 허용</strong>하였기 때문에 의도치 않게 변수를 전역화 하였다. 그 외에도 중복 선언이 허용되어 의도치 않게 변수의 할당값을 변경한다던지, 변수 호이스팅으로 인해서 변수를 선언하기 전에 참조가 가능했었다.<br>그래서 이러한 단점들을 보안하기 위해 등장한것이 let과 const이다.</p><ul><li>let</li></ul><p>var 키워드에서 변수는 함수 레벨 스코프를 가졌다. 하지만 es6에서는 let을 지원한다. 우선적으로 이들은 블록레벨 스코프를 갖는다.</p><pre><code>let foo = 123;{  let foo = 456;  let bar = 456;}console.log(foo); // 123console.log(bar); // ReferenceError: bar is not defined</code></pre><p>변수 bar는 블록 내에서만 참조할 수 있기 떄문에 에러가 발생한다. 또한 중복선언이 금지되어 있어 중복선언 시 문법 에러가 발생한다.</p><ul><li>호이스팅</li></ul><p>물론 let과 const 역시 호이스팅이 발생한다. 자바스크립트에서는 모든 선언을 호이스팅하기 떄문이다. var 키워드는 선언과 초기화가 한 번에 이루어진다. 그래서 스코프에 변수를 등록하고 메모리에 공간을 확보한 후 undefined 값으로 초기화한다. 그렇게 하면 변수 선언문 이전에 변수에 접근하여도 스코프에 변수가 존재하기 때문에 에러가 발생하지 않는다.</p><p>하지만 let의 경우는 조금 다르다. let의 경우는 선언과 초기화가 분리되서 진행된다. 즉 초기화가 변수 선언문에 도달했을 때 실행되기 때문에 참조에러가 발생하게 된다. 변수를 위한 메모리 공간이 확보되지 않았다는 의미이다.<br>이것을 <strong>일시적 사각지대</strong>라고 부른다.</p><p><img src="https://poiemaweb.com/img/let-lifecycle.png" alt="TDZ"></p><pre><code>let foo = 1;{  console.log(foo); // ReferenceError  let foo = 2;}</code></pre><p>블록 안에서 foo를 호출하면 foo가 출력될 것 같지만, 참조 에러가 발생한다. ES6의 변수 선언을 블록레벨 스코프를 가지기 때문에 블록 안에서의 변수 foo는 호출당시 일시적 사각지대에 빠져있다.</p><ul><li>클로저</li></ul><p>아래 코드를 살펴보자.</p><pre><code>var func = [];for (var i = 0; i &lt; 3; i++) {  func.push(function () {    console.log(i);  });}for (var j = 0; j &lt; 3; j++) {  func[j](); // 3 3 3}</code></pre><p>여기서 for 루프의 변수 i는 전역변수이다. 따라서 반복문에서 계속 값이 할당되고 결국 마지막 값이 남아 3번 출력되는 것이다.<br>0,1,2를 출력하기 위해선 클로저를 사용하여야 한다.</p><pre><code>var func = [];for (var i = 0; i &lt; 3; i++) {(function (index) {  func.push(function () { console.log(index); })}(i));}for (var j = 0; j &lt; 3; j++) {  func[j](); // 0 1 2}</code></pre><p>여기서 인자 index가 자유변수가 된다. 즉시실행함수가 죽어도 해당 환경이 남아있기 때문에 결과값을 기억한다. 하지만 let을 사용하면</p><pre><code>var func = [];for(let i = 0; i &lt; 3; i++) {  func.push(function () { console.log(i); });}for(let j = 0; j &lt; 3; j++) {  console.dir(func[j]);  func[j]();}// // [Function]// 0// [Function]// 1// [Function]// 2</code></pre><p>여기서의 변수 i는 지역변수가 된다. 또한 자유변수로서 for 루프가 끝나도 변수 i를 참조하는 함수가 존재한다면 계속 유지된다.</p><ul><li>let은 전역에서 접근할 수 없다.</li></ul><p>보통 전역 변수는 window.변수명으로 접근이 가능하지만, let은 전역 변수여도 보이지 않는 블록이 존재하기 때문에 window 키워드로 접근할 경우 undefined가 뜬다.</p><ul><li>const</li></ul><p>const도 let과 마찬가지로 변수를 선언하는 키워드이지만, const는 상수(변하지 않는 값)을 위해서 사용한다. (반드시 그런 것은 아니다.)<br>let과 대부분 비슷하지만 그 차이점도 있다.</p><ol><li>선언과 초기화</li></ol><p>let은 재할당 해도 상관없지만 const는 재할당할 수 없다. 또한 const는 선언과 동시에 할당이 이루어져야 한다. 그냥 변수만 선언할 경우에 문법에러가 발생하게 된다.</p><ol start="2"><li>상수</li></ol><p>아래 예제를 살펴보자. (그냥 보기만 하셔도 됩니다.)</p><pre><code>if (rows &gt; 10) {} // ???const MAXROWS = 10;if (rows &gt; MAXROWS) {}</code></pre><p>첫 번째 문장에서는 사실 그냥 딱 보았을 때 무슨 의미인지 알기 힘들지만, const로 변수 이름을 잘 설정한다면 의미가 명확해지기 떄문에 가독성과 유지보수가 편해진다.</p><ol start="3"><li>객체</li></ol><p>위에서도 말했지만, const는 재할당이 금지된다. 즉 const의 타입이 객체인 경우에는 객체에 대한 참조를 변경할 수 없다.<br>하지만 <strong>객체의 프로퍼티</strong>는 보호되지 않기 때문에 재할당은 안되지만, 할당된 내용은 변경할 수 있다.</p><pre><code>const user = { name: &apos;Lee&apos; }user.name = &apos;Jang&apos;;console.log(user) // { name: &apos;Jang&apos; }</code></pre><p>이 의미는 할당된 주소값이 변경되지 않고 그 값 자체가 변화한다는 의미이다. 이렇기 떄문에 객체 타입에는 const가 매우 좋다.</p><ul><li>요약</li></ul><p>재할당이 필요하다면 let을 사용하자!<br>ES6와 Typescript를 위해서 var 사용을 자제하자!<br>재할당이 필요없는 타입에는 const를 사용하자!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6의-변수-선언과-블록-레벨-스코프&quot;&gt;&lt;a href=&quot;#ES6의-변수-선언과-블록-레벨-스코프&quot; class=&quot;headerlink&quot; title=&quot;ES6의 변수 선언과 블록 레벨 스코프&quot;&gt;&lt;/a&gt;ES6의 변수 선언과 블록 레벨 스코프&lt;/
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES6" scheme="http://rootjang92.github.io/categories/Javascript/ES6/"/>
    
    
      <category term="javascript,js,es6,let,const" scheme="http://rootjang92.github.io/tags/javascript-js-es6-let-const/"/>
    
  </entry>
  
  <entry>
    <title>HTML5 시맨틱 태그</title>
    <link href="http://rootjang92.github.io/2018/09/25/csssemantic/"/>
    <id>http://rootjang92.github.io/2018/09/25/csssemantic/</id>
    <published>2018-09-25T02:13:12.000Z</published>
    <updated>2018-09-25T09:33:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="시맨틱-태그"><a href="#시맨틱-태그" class="headerlink" title="시맨틱 태그"></a>시맨틱 태그</h1><p>많은 웹 사이트를 분석하여 웹 문서 레이아웃의 표준화를 하는 태그가 많이 추가되었다. (물론 아직 많이 사용하진 않는다.)<br>‘semantic’은 의미가 통한다는 의미이기 때문에 태그만 보면 ‘아 여기구나’라고 알 수 있다.</p><p>우리가 흔히 쓰는 의미 없는 상자 태그인 div 대신에 각 구역의 의미가 담긴 태그를 사용하는 것이다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/948up2sm/1/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>HTML5의 시맨틱 태그를 사용해야 하는 이유는 <strong>웹 표준성</strong>이다. 우리가 웹 사이트의 태그를 보고 필요한 내용을 즉각 찾아낼 수 있어 편리해지고, 어떤 내용인지 바로 알 수 있기 때문이다.</p><h2 id="header-머리말"><a href="#header-머리말" class="headerlink" title="header : 머리말"></a>header : 머리말</h2><p>head부분이 아니고 body안에 머릿말에 들어가는 태그이다. header 부분에는 검색창이나 메뉴를 삽입한다.</p><ul><li>nav 태그 : 문서를 연결하는 네비게이션</li></ul><p>보통 메뉴에 사용하는 태그이다. header, aside, footer 어디에든 사용 가능하다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/hmp29usv/3/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>(참조 : HTML5 &amp; CSS3 웹 표준의 정석)</p><h2 id="section-주제별-콘텐츠-영역"><a href="#section-주제별-콘텐츠-영역" class="headerlink" title="section : 주제별 콘텐츠 영역"></a>section : 주제별 콘텐츠 영역</h2><p>콘텐츠의 주제를 묶을 때 사용하는 태그이다.</p><h2 id="article-콘텐츠-내용"><a href="#article-콘텐츠-내용" class="headerlink" title="article : 콘텐츠 내용"></a>article : 콘텐츠 내용</h2><p>사전적의미로 신문이나 잡지의 기사를 뜻하는 내용이니, 일맥상통한다. 여기서는 블로그 포스트, 코멘트, 독립적인 웹 콘텐츠를 넣는다.<br>보통 section은 문맥상 콘텐츠를 주제별로 묶을 때 사용하기 떄문에 article 태그 안에 section 태그를 넣기도 한다.</p><h2 id="aside-본문-이외의-내용"><a href="#aside-본문-이외의-내용" class="headerlink" title="aside : 본문 이외의 내용"></a>aside : 본문 이외의 내용</h2><p>블로그나 웹 사이트의 왼쪽이나 오른쪽, 하단 사이드바를 만드는 태그이다. 문서의 메인 컨텐츠에 영향을 끼치지 않는 내용을 삽입한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/k79oLfas/1/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="iframe-외부-태그-삽입하기"><a href="#iframe-외부-태그-삽입하기" class="headerlink" title="iframe : 외부 태그 삽입하기"></a>iframe : 외부 태그 삽입하기</h2><p>HTML, CSS란에 있는 예제태그가 모두 iframe 태그를 통해 가져온 것이다. 즉 외부 문서를 삽입하는 태그이다.</p><h2 id="footer-제작정보-저작권-정보-표시"><a href="#footer-제작정보-저작권-정보-표시" class="headerlink" title="footer : 제작정보, 저작권 정보 표시"></a>footer : 제작정보, 저작권 정보 표시</h2><h2 id="address-사이트-제작-정보-연락처-정보"><a href="#address-사이트-제작-정보-연락처-정보" class="headerlink" title="address : 사이트 제작 정보, 연락처 정보"></a>address : 사이트 제작 정보, 연락처 정보</h2><p>주로 footer 태그 안에서 사용되며 연락처 정보 등을 남긴다.</p><h2 id="div는-뭔데-그럼"><a href="#div는-뭔데-그럼" class="headerlink" title="div는 뭔데 그럼?"></a>div는 뭔데 그럼?</h2><p>div는 콘텐츠를 묶어서 css 등을 사용해야 할 때 사용합니다. (물론 주로 div로 다 한다.)</p><h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/jguvx2zq/2/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;시맨틱-태그&quot;&gt;&lt;a href=&quot;#시맨틱-태그&quot; class=&quot;headerlink&quot; title=&quot;시맨틱 태그&quot;&gt;&lt;/a&gt;시맨틱 태그&lt;/h1&gt;&lt;p&gt;많은 웹 사이트를 분석하여 웹 문서 레이아웃의 표준화를 하는 태그가 많이 추가되었다. (물론 아직
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css,css3, css semantic tag, 시맨틱 태그" scheme="http://rootjang92.github.io/tags/css-css3-css-semantic-tag-%EC%8B%9C%EB%A7%A8%ED%8B%B1-%ED%83%9C%EA%B7%B8/"/>
    
  </entry>
  
  <entry>
    <title>표 스타일</title>
    <link href="http://rootjang92.github.io/2018/09/23/csstable/"/>
    <id>http://rootjang92.github.io/2018/09/23/csstable/</id>
    <published>2018-09-23T03:16:25.000Z</published>
    <updated>2018-09-25T02:12:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="간단히-살펴보는-표-스타일"><a href="#간단히-살펴보는-표-스타일" class="headerlink" title="간단히 살펴보는 표 스타일"></a>간단히 살펴보는 표 스타일</h1><p>이제 테이블이라는 태그는 많이 사용하지 않지만, 자신이 만들어야 하는 웹 페이지에 테이블이 필요하다면 ul태그나 기타 다른 태그를 사용하는 것보단 테이블 태그를 사용하는 것이 훨씬 실용적이고, 또 웹 표준성에도 맞는 방법이다. 그렇기 때문에 오늘은 표 관련 css를 살펴보려고 한다.</p><ul><li>caption-side : 표 제목 위치</li></ul><p>표 제목은 caption 태그를 이용하는 데 그 위치를 조정하는 css 속성은 caption-side이다. top은 기본 값이며 제목이 위에 설정되도록, bottom은 제목이 아래에 오도록 하는 속성값이다.</p><ul><li>border : 표 테두리</li></ul><p>일반 컨텐츠와 마찬가지로 border는 테두리를 지정하는 속성이다. 하지만 주의할 점은 표는 바깥 테두리와 셀 테두리를 따로 설정해주어야 한다는 점이다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/hmrpgesz/1/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>border-collapse : 테두리 통합, 분리</li></ul><p>바깥 테두리와 셀의 각 테두리를 떨어트릴지 하나로 합칠 것인지를 정하는 속성이다. collapse는 테두리를 하나로 합치는 속성값이고, separate는 테두리를 따로 표시하는 속성값이다.(이래서 영어공부를 해야한다.)</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/5m0fjdtc/1/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>border-spacing : 인접한 셀 테두리 사이 거리 지정</li></ul><p>border-collapse : separate를 지정했을 때 인접한 셀 테두리의 거리를 지정하는 속성이다.</p><ul><li>empty-cells : 빈 셀 표시 여부 지정.</li></ul><p>빈 셀의 표시여부를 지정할 수 있다. 속성값으로는 show와 hide가 있다.</p><ul><li>table-layout : 콘텐츠에 맞는 셀 너비</li></ul><p>width값으로 셀 너비를 지정할 수 있지만, 영문의 경우는 그걸 무시하고 한 줄로 표시된다. 이를 지정하는 속성이 table-layout 속성이다.</p><p>fixed는 너비 고정, auto는 셀의 너비가 달라진다.(기본값)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;간단히-살펴보는-표-스타일&quot;&gt;&lt;a href=&quot;#간단히-살펴보는-표-스타일&quot; class=&quot;headerlink&quot; title=&quot;간단히 살펴보는 표 스타일&quot;&gt;&lt;/a&gt;간단히 살펴보는 표 스타일&lt;/h1&gt;&lt;p&gt;이제 테이블이라는 태그는 많이 사용하지 
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css,css3,css table" scheme="http://rootjang92.github.io/tags/css-css3-css-table/"/>
    
  </entry>
  
  <entry>
    <title>CSS 포지셔닝에 대해서</title>
    <link href="http://rootjang92.github.io/2018/09/22/cssposition/"/>
    <id>http://rootjang92.github.io/2018/09/22/cssposition/</id>
    <published>2018-09-22T03:32:10.000Z</published>
    <updated>2018-09-22T07:57:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-포지셔닝"><a href="#CSS-포지셔닝" class="headerlink" title="CSS 포지셔닝"></a>CSS 포지셔닝</h1><p>css에서 가장 <strong>중요한</strong>속성이 바로 포지셔닝이다. 이것을 이용해서 웹 문서의 레이아웃이 짜여진다고 생각하면 된다.<br>우리가 네이버나 다음에서 보는 검색창, 광고, 로그인 창들의 <strong>위치</strong>는 모두 css로 만들고 그 배치를 하는 것이 바로 포지셔닝이다.</p><h2 id="box-sizing-박스-너비-기준-정하기"><a href="#box-sizing-박스-너비-기준-정하기" class="headerlink" title="box-sizing : 박스 너비 기준 정하기"></a>box-sizing : 박스 너비 기준 정하기</h2><p>box-sizing은 박스 모델 안에 있는 콘텐츠 부분의 너비와 높이를 정하는 속성이다. 속성값에는 content-box와 border-box가 있으며 content-box는 너비의 기준이 컨텐츠이고, border-box는 콘텐츠 영역의 테두리까지 포함한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/w7eaL5q2/4/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>box1의 실제 넓이는 패딩 30px border 2px 콘텐츠 너비 300px = 364px<br>box2의 실제 넓이는 300px에서 패딩 30px과 테두리 2px씩 할당해서 = 236px이 된다.</p><p>더 자세히 보고 싶으면 크롬 검사에 Computed 요소를 살펴보면 더 자세히 볼 수 있다.</p><h2 id="float-왼쪽-혹은-오른쪽"><a href="#float-왼쪽-혹은-오른쪽" class="headerlink" title="float : 왼쪽 혹은 오른쪽"></a>float : 왼쪽 혹은 오른쪽</h2><p>float의 단어적 의미는 “뜨다”, “띄우다”이다. 즉 css에서 float는 요소를 띄어서 배치시킨다는 의미이다.<br>즉 이미지를 어떻게 띄어서 텍스트와 함께 배치할 것인가를 나타낸다. 속성값에는 inherit(부모 요소로부터 상속),left, right, none이 있다.</p><p>float에서 중요한 점은 그 원리 이다. float를 지정할 경우 필요한 너비 값을 차지하고 다른 요소가 들어올 만큼의 공간을 비워둔다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/bv6h1du4/2/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="clear-float-해제하기"><a href="#clear-float-해제하기" class="headerlink" title="clear : float 해제하기"></a>clear : float 해제하기</h2><p>float 속성을 적용시켜 배치하면 그 다음에 넣는 요소들에게도 같은 속성이 전달된다. 이제 그만~ 을 알려주기 위해선 clear를 사용하여야 한다.</p><p>left를 무효화 할 때에는 clear:left, right는 clear:right, 상관업싱 할 떄는 clear: both를 사용하면 된다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/4zq2Lcye/3/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="문서-구조-만들기"><a href="#문서-구조-만들기" class="headerlink" title="문서 구조 만들기"></a>문서 구조 만들기</h2><p><img src="https://t1.daumcdn.net/cfile/tistory/18237F364C8497089B" alt="문서구조"></p><a href="http://m.mkexdev.net/77" target="_blank" rel="noopener">출처</a><p>사이드바나 nav의 위치가 바뀌는 것은 상관없지만 보통 웹 문서는 이러한 레이아웃 구조를 가지고 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/khogt4v9/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="position-속성"><a href="#position-속성" class="headerlink" title="position 속성"></a>position 속성</h2><p>position 속성은 문서 안 요소들을 자유롭게 배치하는 속성이다. 속성값에는 static(문서의 흐름에 맞춰 배치), relative(이전 요소에 자연스럽게 연결해 배치, 위치 지정 가능), absolute(원하는 위치 배정), fixed(지정한 위치에 고정)</p><p>static 속성을 제외한 나머지는 좌표를 이용하여 위치를 조절할 수 있다.</p><ul><li>relative</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/L5gprju9/4/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>위 예제는 원래 float 상 위치해야 될 위치에서 왼쪽으로 50px, 위에서 아래로 30px 조정되었다.</p><ul><li>absolute</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/4pen1qs5/8/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>absolute의 기준이 되는 위치는 가장 가까운 부모 요소나 조상 요소 중 position이 relative인 속성이다.</p><ul><li>fixed</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/ca46eb50/1/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>문서이 흐름과 상관없이 좌표로 결정하지만 브라우저 창이 기준이 된다. (브라우저 창 왼쪽 위 기준)</p><h2 id="visibility-보이거나-보이지-않거나"><a href="#visibility-보이거나-보이지-않거나" class="headerlink" title="visibility : 보이거나 보이지 않거나"></a>visibility : 보이거나 보이지 않거나</h2><p>특정 요소를 보이게 하거나 보이지 않게 할 수 있다. 속성값에는 visible, hidden, collapse이 있다.</p><h2 id="z-index-요소-쌓는-순서-정하기"><a href="#z-index-요소-쌓는-순서-정하기" class="headerlink" title="z-index : 요소 쌓는 순서 정하기"></a>z-index : 요소 쌓는 순서 정하기</h2><p>한 요소 위에 다른 요소를 쌓는 속성이다. z-index 값이 작을 수록 아래에 쌓이고 높을 수록 작은 요소보다 위에 쌓인다. 명시하지 않을 경우에는 웹 문서에 제일 처음 삽입하는 요소가 z-index: 1 값을 가지고 순차적으로 커진다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS-포지셔닝&quot;&gt;&lt;a href=&quot;#CSS-포지셔닝&quot; class=&quot;headerlink&quot; title=&quot;CSS 포지셔닝&quot;&gt;&lt;/a&gt;CSS 포지셔닝&lt;/h1&gt;&lt;p&gt;css에서 가장 &lt;strong&gt;중요한&lt;/strong&gt;속성이 바로 포지셔닝이다. 이것
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css, css3, css positioning, float, z-index" scheme="http://rootjang92.github.io/tags/css-css3-css-positioning-float-z-index/"/>
    
  </entry>
  
  <entry>
    <title>함수형 프로그래밍이란</title>
    <link href="http://rootjang92.github.io/2018/09/18/functionprogram/"/>
    <id>http://rootjang92.github.io/2018/09/18/functionprogram/</id>
    <published>2018-09-18T09:08:59.000Z</published>
    <updated>2018-09-22T03:31:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="함수형-프로그래밍"><a href="#함수형-프로그래밍" class="headerlink" title="함수형 프로그래밍"></a>함수형 프로그래밍</h1><p>사실 함수형 프로그래밍은 정말… 설명하기가 힘들다. (아직도 힘들다.) 하지만 자바스크립트에서 함수형 프로그래밍이 어떤 식으로 사용되는 지 간단하게 나마 남겨보고자 한다.</p><h2 id="함수형-프로그래밍이-뭔데"><a href="#함수형-프로그래밍이-뭔데" class="headerlink" title="함수형 프로그래밍이 뭔데?"></a>함수형 프로그래밍이 뭔데?</h2><p>그러게 말이다… 단순히 말하자면 <strong>함수를 조합하여 작업을 수행한다.</strong>라고 말하고 싶다. 말 그대로다 프로그램을 만들기 위해 프로그래밍을 한다면, 함수형 프로그래밍은 함수를 이용해서 프로그래밍을 하겠다는 이야기니 말이다. 중요한 점은 작업 동안에 데이터나 상태의 변화 없이 오로지 함수만 변화하고 연산의 대상이 된다는 점이다.</p><p>함수에는 외부에 아무런 영향을 끼치지 않는 순수함수와 함수를 하나의 값으로 인식하여 함수의 인자나 반환값으로 사용하는 고차함수가 있다.</p><h2 id="자바스크립트에서의-함수형-프로그래밍"><a href="#자바스크립트에서의-함수형-프로그래밍" class="headerlink" title="자바스크립트에서의 함수형 프로그래밍"></a>자바스크립트에서의 함수형 프로그래밍</h2><p>자바스크립트의 함수는 일급 객체이면서 클로저를 활용할 수 있다.</p><p>암호화 예제를 자바스크립트로 표현해 보았다.</p><pre><code>var f1 = function(input) {  var result;  result = 1;  return result;}var f2 = function(input) {  var result;  result = 2;  return result;}var f3 = function(input) {  var result;  result = 3;  return result;}var get_encrypted = function(func) {  var str = &apos;Jang&apos;;  return function() {    return func.call(null, str);  }}var encrypted_value = get_encrypted(f1)();console.log(encrypted_value);var encrypted_value = get_encrypted(f2)();console.log(encrypted_value);var encrypted_value = get_encrypted(f3)();console.log(encrypted_value);</code></pre><p>출력결과는 1,2,3 이다. 변수 str은 외부에서 접근이 불가능하다(영향을 끼칠 수 없다.). 또한 함수는 일급 객체이기 때문에 함수의 인자로 함수를 넘기고 결과로 함수를 반환할 수도 있다.</p><h2 id="함수형-프로그래밍-예제"><a href="#함수형-프로그래밍-예제" class="headerlink" title="함수형 프로그래밍 예제"></a>함수형 프로그래밍 예제</h2><ol><li>시그마</li></ol><p>배열의 각 원소의 합을 구하는 알고리즘을 구현해보자. (코드를 보지 않고 직접 해보길 추천한다.)</p><pre><code>function sum(arr) {  var len = arr.length;  var i = 0, sum = 0;  for (; i &lt; len ; i++) {    sum += arr[i];  }  return sum;}var arr = [1,2,3,4];console.log(sum(arr)); // 10</code></pre><p>이를 응용하여 곱셈값을 구하면,</p><pre><code>function multiply(arr) {  var len = arr.length;  var i = 0, result = 1;  for(; i &lt; len; i++) {    result *= arr[i];  }  return result;}var arr = [1,2,3,4];console.log(multiply(arr)); // 24</code></pre><p>이를 함수형 프로그래밍을 이용해보자.</p><pre><code>function reduce(func, arr, memo) {  var len = arr.length,  i = 0;  accum = memo;  for(; i &lt; len; i++) {    accum = func(accum, arr[i]);  }  return accum;}var arr = [1,2,3,4];var sum = function(x, y) {  return x+y;};var multyply = function(x, y) {  return x*y;};console.log(reduce(sum, arr, 0)); // 10console.log(reduce(multyply, arr, 1)); // 24</code></pre><p>reduce 함수에서 함수와 배열, 기본값을 인자로 받아 넘기고 루프를 돌며 함수를 실행시킨다. 결과값은 변수 accum에 저장된다.</p><ol start="2"><li>팩토리얼</li></ol><p>함수형 프로그래밍을 이용해서 팩토리얼을 구현해보자.</p><pre><code>function fact(num) {  if (num === 0 ) return 1;  else return num * fact(num-1);}console.log(fact(10)); // 3628800</code></pre><p>간단한 재귀함수를 통해 팩토리얼을 구현했다. 이를 함수형 프로그래밍으로 하면, (사실 그냥 하려면 이게 더 쉽지만 재사용성 등을 위해서..)</p><pre><code>var factorial = function() {  var cache = {&apos;0&apos; : 1};  var func = function(n) {    var result = 0;    if(typeof(cache[n]) === &apos;number&apos;) {      result = cache[n];    } else {      result = cache[n] = n * func(n-1);    }    return result;  }  return func;}();console.log(factorial(1)); // 1console.log(factorial(10)); // 3628800console.log(factorial(20)); // 2432902008176650000</code></pre><p>변수 factorial은 cache에 접근할 수 있는 클로저를 반환받아, 캐시에 저장된 값이 있으면 곧바로 그 값을 반환하는 방식으로 만들었다. (아직도 어렵다.) 한 번 연산된 값을 cache에 저장하고 있기 때문에 중복 연산을 피할 수 있다.</p><ol start="3"><li>피보나치 수열</li></ol><a href="https://namu.wiki/w/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98" target="_blank" rel="noopener">메모이제이션 패턴</a><pre><code>var fibo = function() {  var cache = {&apos;0&apos; : 0, &apos;1&apos; : 1};  var func = function(n) {    if (typeof(cache[n]) === &apos;number&apos;) {      result = cache[n];    } else {      result = cache[n] = func(n-1) + func(n-2);    }    return result;  }  return func;}();console.log(fibo(10)); // 55</code></pre><p>클로저를 활용하여 cache를 캐시로 활용한다.</p><h2 id="함수형-프로그램밍의-주요함수"><a href="#함수형-프로그램밍의-주요함수" class="headerlink" title="함수형 프로그램밍의 주요함수"></a>함수형 프로그램밍의 주요함수</h2><ol><li>커링</li></ol><p>커링이란 특정 함수에서 정의된 인자의 일부를 넣어 고정시켜, 나머지를 인자로 받는 새로운 함수를 받는 것을 의미한다.</p><pre><code>function calc(a, b, c) {  return a*b+c;}function curry2(func) {  var args = Array.prototype.slice.call(arguments, 1);  return function() {    var arg_index = 0;    for (var i = 0; i &lt; args.length &amp;&amp; arg_index &lt; arguments.length; i++)      if (args[i] === undefined ) args[i] = arguments[arg_index++];    return func.apply(null, args);  }}var new_func = curry2(calc, 1, undefined, 4);console.log(new_func(3)); // 7  1 * 3 + 4var new_func2 = curry2(calc, 1, 3, undefined);console.log(new_func2(5));</code></pre><ol start="2"><li>bind</li></ol><p>bind 함수는 특정 함수에 원하는 객체를 바인딩시켜서 새로운 함수를 사용할 때 bind 함수를 사용하는 것이다.</p><pre><code>var print_all = function(arg) {  for(var i in this ) console.log(i + &quot; : &quot; + this[i]);  for(var i in arguments ) console.log(i + &quot; : &quot; + arguments[i]);}var myObj = { name : &apos;Jang&apos; };var myfunc = print_all.bind(myObj);myfunc(); // name : Jang // 2var myfunc1 = print_all.bind(myObj, &quot;I am Jang&quot;, &quot;others&quot;);myfunc1(&quot;inside&quot;); // 0 : I am Jang, 1 : others, 2: inside // 3console.log(print_all); // [Function: print_all] // 1</code></pre><p>1번째는 변수 print_all의 로그값. 2번째는 myfunc라는 변수에 print_all 변수에 myObj를 바인딩한 것을 할당한 것이다.<br>3번째는 myfun1에 3가지 인수를 바인딩해서 할당한 것이다.</p><ol start="3"><li>반복함수</li></ol><ul><li>map</li></ul><p>배열의 각 요소를 꺼내서 사용자 정의 함수를 적용시켜 새로운 값을 얻은 후, 새로운 배열에 넣는 함수이다. 이 때 원본 배열은 변형되지 않는다.<br>즉, 배열을 순회하여 요소 값을 다른 값으로 <strong>매핑</strong>하기 위한 함수이다.</p><pre><code>var numbers = [1, 4, 9];var roots = numbers.map(function (item) {  return Math.sqrt(item);});console.log(roots); // [1,2,3]console.log(numbers); // [1,4,9] -&gt; 원본 배열은 변하지 않는다.numbers = [1,4,9];roots = numbers.map(function (item) {  return ++item;});console.log(roots); // [2,5,10]</code></pre><p>또한 두 번째 인자로 this를 전달할 수 있다.</p><pre><code>function Prefix(prefix) {  this.prefix = prefix;}Prefix.prototype.prefixArray = function (arr) {  return arr.map(function (x) {    return this.prefix + x; // 2번째 인자가 없다면 this는 전역 객체  }, this);};var pre = new Prefix(&apos;-webkit-&apos;);var preArr = pre.prefixArray([&apos;liner-gredient&apos;, &apos;border-radius&apos;]);console.log(preArr); // [ &apos;-webkit-liner-gredient&apos;, &apos;-webkit-border-radius&apos; ]</code></pre><ol start="3"><li>forEach</li></ol><p>배열을 순회하며 배열의 각 요소로 주어진 인자에 콜백함수를 실행한다. 매개변수를 통해 배열 요소의 값, 인덱스, 순회할 배열을 전달받을 수 있다. for와 다른 점은 break가 없다는 점이다. 또한 forEach 역시 원본 배열을 변경하지 않는다.</p><pre><code>function Counter() {  this.sum = 0;  this.count = 0;}Counter.prototype.add = function (array) {  array.forEach(function (entry) {    this.sum += entry;    this.count++;  }, this);};var counter = new Counter();counter.add([2,5,9]);console.log(counter.count); // 3console.log(counter.sum); // 16</code></pre><ol start="4"><li>filter</li></ol><p>배열을 순회하며 각 요소의 인자로 주어진 값에서 콜백함수의 실행결과가 true인 것만 반환한다. 역시 원본 배열은 변경되지 않는다.</p><pre><code>var result = [1,2,3,4,5].filter(function (item, index, array) {  console.log(&apos;[&apos; + index + &apos;] = &apos; + item);  return item % 2; // 각 배열 요소, 인덱스, 순회할 배열을 인자로 받아 2로 나눴을 때 나머지가 있는 것만 반환});console.log(result);  // [0] = 1                      // [1] = 2                      // [2] = 3                      // [3] = 4                      // [4] = 5                      // [ 1, 3, 5 ]</code></pre><ol start="5"><li>reduce</li></ol><p>각 배열을 순회하여 콜백 함수를 적용시킨 뒤, 이전 콜백함수의 값을 누적시키는 함수이다.</p><pre><code>var result = [1,2,3,4,5].reduce(function (previouValue, currentValue, currentIndex, array) {  console.log(previouValue + &apos;+&apos; + currentValue + &apos;=&apos; + (previouValue + currentValue));  return previouValue + currentValue;});console.log(result);// 1+2=3// 3+3=6// 6+4=10// 10+5=15// 15</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;함수형-프로그래밍&quot;&gt;&lt;a href=&quot;#함수형-프로그래밍&quot; class=&quot;headerlink&quot; title=&quot;함수형 프로그래밍&quot;&gt;&lt;/a&gt;함수형 프로그래밍&lt;/h1&gt;&lt;p&gt;사실 함수형 프로그래밍은 정말… 설명하기가 힘들다. (아직도 힘들다.) 하지
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="javascript, function programming, 함수형 프로그래밍, 함수형 프로그래밍 이란?" scheme="http://rootjang92.github.io/tags/javascript-function-programming-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9D%B4%EB%9E%80/"/>
    
  </entry>
  
  <entry>
    <title>레이아웃 관련 스타일</title>
    <link href="http://rootjang92.github.io/2018/09/18/csslayout/"/>
    <id>http://rootjang92.github.io/2018/09/18/csslayout/</id>
    <published>2018-09-18T01:41:39.000Z</published>
    <updated>2018-09-18T09:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="레이아웃-관련-스타일-태그들"><a href="#레이아웃-관련-스타일-태그들" class="headerlink" title="레이아웃 관련 스타일 태그들."></a>레이아웃 관련 스타일 태그들.</h1><p>결국 디자인을 위해선 레이아웃을 알아야 한다. 흔히 ‘박스 모델의 조합’이라고들 말한다. 이는 영역, 테두리, 여백들의 조합을 말한다.<br>css를 제대로 알기 위해선 결국 <strong>레이아웃</strong>을 잘 알아야 한다.</p><h2 id="박스모델"><a href="#박스모델" class="headerlink" title="박스모델"></a>박스모델</h2><p>말 그대로 박스 형태의 모델을 말한다. 이 박스들을 합쳐서 웹 문서를 만든다.</p><ul><li>블록 레벨과 인라인 레벨</li></ul><p><strong>block-level</strong>은 태그를 요소에 삽입했을 때 한 줄을 차지하는 요소다. 즉 너비가 100%이다. margin, padding 등으로 크기 조정을 하기 위해서도 block-level의 요소여야 한다. 그 예로는 div, p 태그 등이 있다.</p><p>반면 <strong>in-line</strong> 요소는 화면에 표시되는 콘텐츠 만큼만 영역을 차지한다. 예로는 img나 strong 태그가 있다.</p><ul><li>박스 형태의 컨텐츠</li></ul><p>앞에서 본 블록 레벨의 요소들은 모두 박스 형태이다. 이 박스 형태를 잘 알고 있어야 웹 문서의 전체적인 배치 형태를 조절할 수 있다.</p><p><img src="https://poiemaweb.com/img/box-model.png" alt="박스모델"></p><p>박스 모델은 콘텐츠 영역을 시작으로 영역과 영역 사이를 뜻하는 padding, 박스 모델의 여백을 뜻하는 margin, 박스의 테두리인 border로 구성되어 있다. 실제로 구글의 검사 탭에서 Computed 영역을 살펴보면 실제 박스모델이 어떻게 적용되어 있는지 볼 수 있다.</p><ul><li>width와 height</li></ul><p>쉬운 영어단어 이다. 그 뜻처럼 너비와 높이를 나타내는 속성이다. 속성 값으로는 px 단위로 크기를 직접 지정할 수도 있고 백분율이다 auto를 사용할 수도 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/gdb0xt9p/1/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>width 값을 직접준 것과 백분율로 준 값을 비교해보았다.</p><p>주의할 점은 실제 콘텐츠의 크기를 계산하는 법이다. 보통 브라우저의 박스 모델 전체 너비는 <strong>width값 + 좌우 패딩 + 좌우 테두리</strong>로 계산한다. 만약 box의 너비값이 200px, 패딩값이 10px, 테두리가 5px로 지정되어 있다면 컨텐츠의 총 넓이는 230px이다.</p><ul><li>display</li></ul><p>display 속성은 원래 해당 요소가 화면에 <strong>어떻게 보일지</strong>를 지정하는 속성이다. 하지만 display 속성은 박스 모델을 변경할 수 있다. 블록 요소를 인라인 요소로, 또 인라인 요소를 블록 요소로 변경할 수 있다.<br>display의 속성값으로는 none, contents, block, inline, inline-block, table, tabel-cell 등이 있다.</p><ul><li><p>block 속성 값은 해당 요소를 블록 레벨로 지정하는 요소이다. img같은 인라인 요소도 블록 요소처럼 사용할 수 있다.</p></li><li><p>inline 속성 값은 블록 레벨 요소를 인라인 레벨 요소로 사용할 수 있다. 블록 레벨 요소 처럼 한 줄을 차지하지 않고 수평적으로 나열 할 수 있다.</p></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/wcf3gzu8/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>inline-block의 경우는 inline의 단점인 마진, 패딩값이 적용되지 않는다는 점을 보완해준다. 요소를 인라인 레벨로 배치하면서 내용은 블록 레벨 속성을 적용하는 것이다.</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/p9ysfzh6/2/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>none은 해당 요소를 표시하지 않는다. 이는 공간조차 차지하지 않는다는 점에서 visibility: hidden;과 차이가 있다.</li></ul><h2 id="테두리"><a href="#테두리" class="headerlink" title="테두리"></a>테두리</h2><p>앞서 말했듯이 테두리는 border이다. 기본값이 none이기 때문에 테두리를 설정하기 위해서는 border 값을 지정해 주어야 한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/g3e6549f/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>border의 예시이다. (poiemaweb.com 참조)</p><ul><li><p>border-width 속성은 테두리의 두께를 나타내는 속성이다. top, right, left, bottom 별로 지정할 수 있다.</p></li><li><p>border-color 속성은 테두리의 색상을 지정한다. 각 방향별로 지정할 수 있다.</p></li><li><p>border-radius 속성은 박스 모서리를 둥글게 만드는 속성이다. 이 때 크기는 직접 지정하거나 백분율을 사용할 수 있다.</p></li></ul><p><img src="https://poiemaweb.com/img/border-radius.jpg" alt="radius"></p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/4ehd5vbj/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>box-shadow 속성은 선택한 요소에 그림자 효과를 나타내는 것이다. 속성 값으로는 수평거리, 수직거리, 흐림 정도, 번짐 정도, 색상, inset(안쪽 그림자 표시)가 있다.</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/vzu38fcL/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="여백-조정"><a href="#여백-조정" class="headerlink" title="여백 조정"></a>여백 조정</h2><p><img src="https://poiemaweb.com/img/box-model-calc.png" alt="calc"></p><p>여백을 설정하는 속성에는 margin과 padding이 있다. 그 차이에 대해 살펴보자.</p><ul><li>margin : 요소 주변의 여백을 설정한다.</li></ul><p>요소 주변에 여백을 설정하기 때문에 다른 콘텐츠와의 간격을 조절할 수 있다. 역시 방향마다 크기를 다르게 설정하 ㄹ수 있고 속성 값으로는 크기를 직접 설정할 수 있고 백분율이나 auto도 사용 가능하다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/qgvt6ch4/2/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>만약 left, right의 값을 auto로 지정하면 좌우 마진을 똑같이 맞춰 가운데 정렬을 할 때 많이 사용한다.</p><ul><li>padding : 콘텐츠와 테두리 사이 여백을 설정한다.</li></ul><p>padding도 margin과 사용법은 비슷하지만 <strong>어디에</strong> 여백을 만드는지에는 차이가 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/fhj5qumz/1/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><ul><li>이 예제는 Do it! HTML5 + CSS3 웹 표준의 정석 책을 참고하였습니다.</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/kx1n7gbf/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;레이아웃-관련-스타일-태그들&quot;&gt;&lt;a href=&quot;#레이아웃-관련-스타일-태그들&quot; class=&quot;headerlink&quot; title=&quot;레이아웃 관련 스타일 태그들.&quot;&gt;&lt;/a&gt;레이아웃 관련 스타일 태그들.&lt;/h1&gt;&lt;p&gt;결국 디자인을 위해선 레이아웃
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css, css3, css layout" scheme="http://rootjang92.github.io/tags/css-css3-css-layout/"/>
    
  </entry>
  
  <entry>
    <title>객체지향 프로그래밍</title>
    <link href="http://rootjang92.github.io/2018/09/17/Programming/"/>
    <id>http://rootjang92.github.io/2018/09/17/Programming/</id>
    <published>2018-09-17T06:49:36.000Z</published>
    <updated>2018-09-22T07:42:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1><h2 id="객체지향이-뭔데"><a href="#객체지향이-뭔데" class="headerlink" title="객체지향이 뭔데?"></a>객체지향이 뭔데?</h2><p>어려운 말이 정말 많다. 관계성 있는 객체들의 집합? 책임을 갖는 기계나 부품의 결합? 정도로 표현할 수 있겠다. (그나마 쉽게 말하면…)<br>객체지향이라는 의미 자체를 한마디로 정의하기가 정말 힘들다. 그래서 우리는 객체지향 프로그래밍이 의미하는 바를 짚어보면서 이해해보고자 한다.</p><h2 id="클래스-기반과-프로토타입-기반"><a href="#클래스-기반과-프로토타입-기반" class="headerlink" title="클래스 기반과 프로토타입 기반"></a>클래스 기반과 프로토타입 기반</h2><p>프로그래밍 언어를 자바스크립트로 처음 접한 사람은(저를 포함해서) 클래스 기반을 이해하기가 조금은 힘들 수 있다. 많은 사람들이 사용하는 Java, c++가 이에 해당하며 클래스에 정의된 메서드를 사용하여 여러가지 기능을 수행하는 언어이다. 클래스란 한 집단에 속해 있는 속성과 행위들을 정의한 것이다. 즉 클래슨느 객체 생성의 패턴이나 설계도 정도로 말할 수 있겠다.</p><p>반면 프로토타입 기반의 언어는 객체의 자료구조나 메서드 등을 <strong>동적</strong>으로 바꿀 수 있다. 즉 자바스크립트는 <strong>프로토타입 기반의 객체 지향 언어</strong>라고 할 수 있겠다. 예를 들어 객체 생성 방법만 해도 객체 리터럴, Object() 생성자 함수, 생성자 함수 등의 방법이 있다.</p><pre><code>function Person(name) {  this.name = name;  this.setName = function (name) {    this.name = name;  }  this.getName = function () {    return this.name;  };}var me = new Person(&apos;jang&apos;);console.log(me.getName());me.setName(&apos;Jang&apos;);console.log(me.getName());</code></pre><p>출력결과</p><blockquote><p>jang<br>Jang</p></blockquote><p>굳이 이럴 필요는 없다.(좀 인스턴가 동일한 메서드를 각자 가지고 있어 메모리 낭비이다.) 이 함수를 프로토타입을 이용하여 바꾸면</p><pre><code>function Person(name) {  this.name = name;  Person.prototype.setName = function (name) {    this.name = name;  }  Person.prototype.getName = function () {    return this.name;  }};var me = new Person(&apos;Jang&apos;);var you = new Person(&apos;Lee&apos;);var him = new Person(&apos;Park&apos;);console.log(Person.prototype);console.log(me);console.log(you);console.log(him);</code></pre><p>출력결과</p><blockquote><p>Person { setName: [Function], getName: [Function] }<br>Person { name: ‘Jang’ }<br>Person { name: ‘Lee’ }<br>Person { name: ‘Park’ }</p></blockquote><p><img src="https://poiemaweb.com/img/prototype.png" alt="함수프로토타입"></p><p>setName, getName 함수를 프로토타입으로 이동시켜씩 때문에 모든 인스턴스가 참조할 수 있다.</p><p>아래 예제는 자바스크립트의 권위자인 더글라스 크락포드가 제안한 프로토타입에 객체에 메서드를 추가하는 방법이다.</p><p>참조 링크는 <a href="https://poiemaweb.com/js-object-oriented-programming" target="_blank" rel="noopener">참조하기</a></p><pre><code>/*** 모든 생성자 함수의 프로토타입은 Function.prototype이다. 따라서 모든 생성자 함수는 Function.prototype.method()에 접근할 수 있다.* @method Function.prototype.method* @param ({string}) (name) - (메소드 이름)* @param ({function}) (func) - (추가할 메소드 본체)*/Function.prototype.method = function (name, func) {  // 생성자함수의 프로토타입에 동일한 이름의 메소드가 없으면 생성자함수의 프로토타입에 메소드를 추가  // this: 생성자함수  if (!this.prototype[name]) {    this.prototype[name] = func;  }};/*** 생성자 함수*/function Person(name) {  this.name = name;}/*** 생성자함수 Person의 프로토타입에 메소드 setName을 추가*/Person.method(&apos;setName&apos;, function (name) {  this.name = name;});/*** 생성자함수 Person의 프로토타입에 메소드 getName을 추가*/Person.method(&apos;getName&apos;, function () {  return this.name;});var me  = new Person(&apos;Lee&apos;);var you = new Person(&apos;Kim&apos;);var him = new Person(&apos;choi&apos;);console.log(Person.prototype);// Person { setName: [Function], getName: [Function] }console.log(me);  // Person { name: &apos;Lee&apos; }console.log(you); // Person { name: &apos;Kim&apos; }console.log(him); // Person { name: &apos;choi&apos; }</code></pre><h2 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h2><p>자바스크립트는 전통적인 상속을 지원하지 않는다. 그래서 프로토타입 체인을 이용하여 상속을 구현해낸다. 즉 프로토타입을 통해서 객체가 다른 객체로 상속된다고 보면 되겠다. 방법에는 클래스 방식을 따라하는 Pseudo-classical 방식과 프로토타입 상속이 있다.</p><ol><li>의사 클래스 상속 구현</li></ol><p>–</p><pre><code>var Parent = (function () {  function Parent (name) {    this.name = name;  }  Parent.prototype.sayHi = function () {    console.log(&apos;Hi! &apos; + this.name);  };  return Parent;}());var Child = (function () {  function Child(name) {    this.name = name;  }  // 자식 생성자 함수의 프로토타입 객체를 부모의 인스턴스로 변경  Child.prototype = new Parent();  Child.prototype.sayHi = function() {    console.log(&apos;안녕하세요! &apos; + this.name);  };  Child.prototype.sayBye = function() {    console.log(&apos;안녕히가세요! &apos; + this.name);  };  return Child;}());var child = new Child(&apos;Jang&apos;);console.log(child);console.log(Child.prototype);child.sayHi();child.sayBye();console.log(child instanceof Parent);console.log(child instanceof Child);</code></pre><p>출력결과</p><blockquote><p>Parent { name: ‘Jang’ }<br>Parent { name: undefined, sayHi: [Function], sayBye: [Function] }<br>안녕하세요! Jang<br>안녕히가세요! Jang<br>true<br>true</p></blockquote><p>인스턴스 child의 프로토타입 객체는 Parent 생성자 함수가 생성한 인스턴스이다. 또한 Parent 생성자 함수가 생성한 인스턴스의 프로토타입 객체는 Parent.prototype이다. 따라서 child는 Parent 생성자 함수가 생성한 인스턴스와 Parent.prototype에 있는 모든 프로퍼티에 접근할 수 있다. 여기서 sayBye() 메서드는 Parent 생성자 함수 인스턴스에 위치한다.</p><p><img src="https://poiemaweb.com/img/inheritance-prototype-change.png" alt="의사상속"></p><p>하지만 new 연산자를 사용하여 불필요한 객체를 계속 생성하여야 하고 new 키워드를 빼먹을 경우 this가 전역 객체에 바인딩되는 실수가 일어날 수 있다. 또한 프로토타입 객체를 인스턴스로 교체하면서 constructor가 깨지게 된다.</p><ol start="2"><li>프로토타입 상속</li></ol><p>그래서 결국은 자바스크립트의 프로토타입 체인을 이용한 상속을 이용하여야 한다.</p><pre><code>var Parent = (function () {  function Parent(name) {    this.name = name;  }  Parent.prototype.sayHi = function() {    console.log(&apos;Hi &apos; + this.name);  };  return Parent;}());var child = Object.create(Parent.prototype);child.name = &apos;Jang&apos;;child.sayHi();console.log(child instanceof Parent);</code></pre><p>출력결과</p><blockquote><p>Hi Jang<br>true</p></blockquote><p><img src="https://poiemaweb.com/img/prototypal-inheritance1.png" alt="프로토타입 상속"></p><p>객체리터럴로도 사용 가능하다.</p><pre><code>var parent = {  name: &apos;Jang&apos;,  sayHi: function() {    console.log(&apos;Hi &apos; + this.name);  }};var child = Object.create(parent);child.name = &apos;kim&apos;;parent.sayHi();child.sayHi();console.log(parent.isPrototypeOf(child));</code></pre><p>출력결과</p><blockquote><p>Hi Jang<br>Hi kim<br>true</p></blockquote><p>Object.create 함수는 매개변수에 프로토타입으로 설정할 객체 또는 인스턴스를 전달하고 이를 상속하는 새로운 객체를 생성한다.<br>이 함수의 폴리필을 구현하는 함수가 있다.</p><pre><code>function create_object(o) {  function F() {}  F.prototype = o;  return new F();}</code></pre><p>비어 있는 함수 F를 생성하여 그 프로토타입의 프로퍼티에 매개변수로 전달받은 객체를 넣는다. 그 후 생성자 함수 F로 새로운 객체를 생성하고 반환하는 것이다.</p><h2 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h2><p>캡슐화는 객체지향 프로그래밍에서 정말 중요한 개념이다. 그 정의는 필요한 여러가지 정보를 하나의 틀 안에 담는 것을 말한다.<br>관련있는 변수와 메서드를 클래스 같은 틀 안에 담는다고 생각하면 편하겠다. 또한 외부에 공개될 필요가 없는 정보는 은닉한다.<br>원래의 자바스크립트는 public이나 private 같은 키워드를 제공하지 않지만 캡슐화가 가능하다.</p><pre><code>var person = function(arg) {  var name = arg ? arg : &apos;&apos;; // 삼항 연산자  return { getName: function() {      return name;    },    setName: function(arg) {      name = arg;    }  }};var me = person(&apos;Jang&apos;);var name = me.getName();console.log(name); // Jangme.setName(&apos;kim&apos;);name = me.getName();console.log(name); // kim</code></pre><p>person 함수가 객첼르 반환하면서 객체 내 메서드 getName, setName은 클로저로, private 변수에 접근할 수 있다.<br>이것이 <strong>모듈화</strong>이며 캡슐화와 은닉 정보를 제공한다.</p><p>단 주의할 점은</p><ol><li>private 멤버가 객체나 배열일 경우 쉽게 변경할 수 있다.</li></ol><p>객체 반환 시 반환값은 얉은 복사를 통해서 private 멤버의 참조값을 반환하는 데 이는 외부에서도 private 값을 변경할 수 있음을 나타낸다. 이를 해결하려면 <strong>깊은 복사</strong>를 활용해야 한다.</p><ol start="2"><li>person 함수가 반환한 객체는 person 함수 객체의 프로토타입에 접근할 수 없다. = 상속을 구현하 수 없다.</li></ol><p>위는 생성자 함수가 아니고 그냥 메서드를 담은 객체이기 때문이다.</p><pre><code>var Person = function() {  var name;  var F = function(arg) { name = arg ? arg : &apos;&apos;; };  F.prototype = {    getName: function() {      return name;    },    setName: function(arg) {      name = arg;    }  };  return F;}();var me = new Person(&apos;Jang&apos;);console.log(Person.prototype === me.__proto__); // trueconsole.log(me.getName()); // Jangme.setName(&apos;kim&apos;);console.log(me.getName()); // kim</code></pre><p><img src="https://poiemaweb.com/img/module_pattern_2.png" alt="깊은 복사"></p><p>객체지향 프로그래밍은 결국 <strong>재사용성</strong>,<strong>유지보수</strong>를 잘하기 위해 사용하려고 하는 것이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;객체-지향-프로그래밍&quot;&gt;&lt;a href=&quot;#객체-지향-프로그래밍&quot; class=&quot;headerlink&quot; title=&quot;객체 지향 프로그래밍&quot;&gt;&lt;/a&gt;객체 지향 프로그래밍&lt;/h1&gt;&lt;h2 id=&quot;객체지향이-뭔데&quot;&gt;&lt;a href=&quot;#객체지향이-뭔데&quot;
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="javsscript, 객체지향 프로그래밍, object oriented programming" scheme="http://rootjang92.github.io/tags/javsscript-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-object-oriented-programming/"/>
    
  </entry>
  
  <entry>
    <title>색상과 배경 꾸미기</title>
    <link href="http://rootjang92.github.io/2018/09/15/cssbg/"/>
    <id>http://rootjang92.github.io/2018/09/15/cssbg/</id>
    <published>2018-09-15T04:09:17.000Z</published>
    <updated>2018-09-17T06:44:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="색상과-배경-꾸미기"><a href="#색상과-배경-꾸미기" class="headerlink" title="색상과 배경 꾸미기"></a>색상과 배경 꾸미기</h1><h2 id="색상-표현하기"><a href="#색상-표현하기" class="headerlink" title="색상 표현하기"></a>색상 표현하기</h2><p>텍스트나 배경 등 우리가 색상을 사용하는 일은 비일비재할 정도로 많다. 웹에서도 마찬가지이다. 오늘은 색상을 표현하는 방법과 배경을 적용하는 방법에 대해서 알아보려고 한다.</p><ul><li>16진수 표기법</li></ul><p>‘#’기호 다음에 알파벳이나 숫자로 색상을 표현하는 것은 16진수 표기법이라고 한다. 6자리는 앞에서부터 두자리씩 묶어 RGB(red, green, blue)를 표현한다. 예를 들어 ‘#ffff00’은 빨강과 초록은 가득 파란색은 전혀 없는 것을 의미한다.</p><ul><li>rgb와 rgba</li></ul><p>css에서 색상을 표기하는 방법 중 하나는 rgb와 rgba를 사용하는 것이다.</p><pre><code>color: rgb(255,0,0);</code></pre><p>이렇게 작성할 경우 빨간색이 나온다. 또한 여기선 10진수를 사용하여 표기한다. 근데 rgba는 무엇일까? a는 불투명도를 나타내는 값이다. 0부터 1까지의 숫자로 사용하고 1은 완전 불투명함을 뜻한다. 0.5 대신 .5로 표시하여도 된다.</p><ul><li>hsl, hsla</li></ul><p>hsl은 hue(색), saturation(채도), lightness(밝기)를 나타내는 표시이다. a는 위와 마찬가지로 불투명도를 나타낸다.</p><pre><code>hsl(&lt;hue&gt;, &lt;saturation&gt;, &lt;lightness&gt;)</code></pre><p>색은 3요소 중 하나로 각도 기준으로 색상을 배치한다. 0과 360도는 빨간색 120도에는 초록색, 240도에는 파란색이 배치되어 그 사이사이에 다른색들이 배치되어 있다. 채도는 %로 표시하고 0%이면 회색톤, 100%이면 무색이다. 밝기도 %로 표시하고 0%가 가장 어둡고 100%가 가장 밝다.</p><ul><li>이름 표기법</li></ul><p>색상을 단순히 이름으로 표기할 수도 있다. 웹 안전색상이라고 부르는 이 색상들은 기본 16가지를 포함, 모두 216가지로 표현할 수 있다.</p><ul><li>예제</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/v1ag5b39/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><a href="www.colorpicker.com">색상추출사이트</a><h2 id="배경-색과-배경-이미지-꾸미기"><a href="#배경-색과-배경-이미지-꾸미기" class="headerlink" title="배경 색과 배경 이미지 꾸미기"></a>배경 색과 배경 이미지 꾸미기</h2><ul><li>background-color : 배경 색 지정</li></ul><p>background-color 속성은 배경색을 지정할 때 사용한다. 16진수 ,rgb, 이름 표기법 모두 사용할 수 있다.<br>주의할 점은 이 속성은 상속되지 않는다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/w6agm9tv/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>background-clip : 배경 적용 범위 조절하기</li></ul><p>박스 모델에 따라 적용 범위를 조절할 수 있다. 예를 들어 테두리까지 적용할지, 패딩 범위까지 적용할 지 등을 정하는 속성이다. 속성값으로는 border-box(테두리까지), padding-box(패딩까지), content-box(콘텐츠까지)가 있다.</p><ul><li>background-image : 웹 요소에 배경 이미지 넣기</li></ul><p>이 속성은 배경에 이미지를 넣을 때 사용한다. background-image: url(‘파일경로’)을 사용하며 상대 경로 절대 경로 모두 이용 가능하다.</p><ul><li>background-repeat : 배경 이미지 반복 지정.</li></ul><p>배경 이미지를 반복시키는 방법을 설정할 수 있다. 속성값에는 repeat(가로 세로 반복), repeat-x(창 너비와 같아질 때까지 가로로 반복), repeat-y (세로 반복), no-repeat(반복하지 않음)</p><ul><li>background-size : 배경 이미지 크기 조절</li></ul><p>배경 이미지의 크기를 조절할 수 있다. 속성값으로는 auto, contain(요소 안에 배경 이미지가 다 들어오게 하기), cover(모두 덮도록), 크기 값, 백분율이 있다.</p><ul><li>background-position : 배경 이미지 위치 조절하기</li></ul><p>제목이나 본문에 한 쪽에서 이미지를 표시할 경우 사용한다. left,center,right, top, bottom, 백분율, 길이 값 등을 사용할 수 있다.</p><ul><li>background-origin : 배경 이미지 배치 기준</li></ul><p>배경 이미지가 어떻게 배칠될 지 기준을 정하는 속성이다. 속성값으로는 border-box, padding-box, content-box가 있다.</p><ul><li>background-attachment : 배경 이미지 고정하기</li></ul><p>배경 이미지를 고정시킬 수 있따. 속성에 scroll을 사용하면 스크롤과 함께 배경이미지도 이동, fixed는 고정된다.</p><h2 id="그라데이션"><a href="#그라데이션" class="headerlink" title="그라데이션"></a>그라데이션</h2><p>종류에는 선형, 원형 그라데이션이 있다. 하지만 웹 브라우저마다 호환성이 다 다르기 때문에 접두사를 붙여줘야 한다는 불편함이 있다.</p><ul><li>선형 그라데이션</li></ul><p>수직, 수평 또는 대각선 방향으로 일정하게 변하게 하는 그라데이션을 말한다.</p><pre><code>line-gradient(각도 to 방향, color-stop ...)</code></pre><p>방향은 to top, to left, to right, to bottom이 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/2othpx0g/3/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>원형 그라데이션</li></ul><p>원이나 타원 중심부터 동심원을 그리면서 바깥 방향으로 색상이 바뀐다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/hL7pw8mv/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>위치 지정</li></ul><p>그라데이션이 시작하는 중심도 지정할 수 있다. 주의할 점은 브라우저 접두사를 붙이는 구문에는 at 키워드를 생략해야 한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/zqp7t3jv/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>크기</li></ul><p>원의 크기 또한 지정할 수 있다.</p><p>closest-side 속성값은 그라데이션 가장자리가 그라데이션 중심에서 가장 가까운 요소의 모서리와 만난다. 타원일 경우 그라데이션 중심에서 가장 가까운 요소의 수평축이나 수직축과 만난다.<br>closest-corner는 가장 가까운 코너에 닿도록 한다.<br>farthest-side는 그라데이션 가장자리가 중심에서 가장 먼 모서리와 만나게 한다.<br>farthest-corner는 그라데이션 가장자리가 그라데이션 중심에서 제일 먼 코너에 닿도록 한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/ygv1z9c4/2/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>색상 중지 점</li></ul><p>원형 그라데이션에서도 색상이 바뀌는 부분을 색상 중지점이라고 하며 색상뿐 아니라 색상이 바뀌는 위치도 지정 가능하다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/bkwLzcov/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>그라데이션 반복</li></ul><p>그라데이션은 패턴을 만든 후 요소를 채울 만큼 반복해서 표시할 수 있다. repeating-linear-gradient(선형 그라데이션 반복), repeating-radial-gradient(원형 그라데이션 반복)을 사용한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/ho5ubmdg/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;색상과-배경-꾸미기&quot;&gt;&lt;a href=&quot;#색상과-배경-꾸미기&quot; class=&quot;headerlink&quot; title=&quot;색상과 배경 꾸미기&quot;&gt;&lt;/a&gt;색상과 배경 꾸미기&lt;/h1&gt;&lt;h2 id=&quot;색상-표현하기&quot;&gt;&lt;a href=&quot;#색상-표현하기&quot; class
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css,css3,css image, css background" scheme="http://rootjang92.github.io/tags/css-css3-css-image-css-background/"/>
    
  </entry>
  
  <entry>
    <title>텍스트 관련 css</title>
    <link href="http://rootjang92.github.io/2018/09/14/csstext/"/>
    <id>http://rootjang92.github.io/2018/09/14/csstext/</id>
    <published>2018-09-14T01:35:18.000Z</published>
    <updated>2018-09-23T03:44:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Text-관련-css"><a href="#Text-관련-css" class="headerlink" title="Text 관련 css"></a>Text 관련 css</h1><p>오늘은 텍스트에 적용되는 스타일에 대해 알아보자. 우리가 웹 사이트를 보다 보면 가장 많은 요소 중 하나가 텍스트이다. 글꼴, 줄, 정렬 등 텍스트에도 많은 스타일 요소가 있다.</p><h2 id="글꼴"><a href="#글꼴" class="headerlink" title="글꼴"></a>글꼴</h2><ul><li>font-family : 글꼴 지정하기 스타일</li></ul><p>font-family는 body, p ,hn 태그 등 텍스트를 사용하는 요소들에게 사용하는 글꼴 지정 태그이다.</p><pre><code>font-family: 글꼴이름;</code></pre><p>굴림이나 맑은 고딕 등의 이름을 넣으면 된다. 글꼴에서 중요한 것은 글꼴 자체를 시스템에 설치하여야 한다는 것이다. 기본 글꼴은 물론 적용이 되지만 그렇지 않을 경우에는 적용되지 않는다.</p><ul><li>@font-face : 웹 폰트 사용하기</li></ul><p>css3는 웹 폰트를 표준으로 채택하여 굳이 다운로드 받을 필요 없이 사용할 수 있다.</p><pre><code>&lt;style&gt;@import url(&apos;url주소&apos;); // 소스 붙여넣기.ng-font {  font-family:&apos;Nanum Gothic&apos;, 돋움; // 웹 폰트 적용(구글 나눔 고딕)}&lt;/style&gt;&lt;p class=&quot;ng-font&quot;&gt;ddd&lt;/p&gt;</code></pre><p>이런 식으로 사용하면 된다.</p><a href="https://fonts.google.com/earlyaccess" target="_blank" rel="noopener">구글폰트</a><ul><li>글꼴 저작권에 주의하여야 한다.</li></ul><p>만약 글꼴 파일을 업로드 해서 사용한다면 @font-face를 사용해서 하면 된다.</p><pre><code>@font-face {  font-family: 글꼴 이름;  src:url(글꼴파일경로) format(파일 유형);}</code></pre><ul><li>font-size : 글자 크기 조절</li></ul><p>font-size는 글꼴을 조정하는 스타일인데 크기에는 절대 크기, 상대 크기, 백분율, 크기를 정할 수 있다.</p><ol><li>절대 크기</li></ol><p>xx-small, xx-large, large 등으로 지정하는 데 거의 사용하지 않는다.(주관적인 의견입니다.)</p><ol start="2"><li>상대 크기</li></ol><p>부모 요소의 크기를 기준으로 크거나 작게 표시할 수 있다. larger | smaller</p><ol start="3"><li>크기</li></ol><p>글자 크기를 직접 지정한다.</p><ol start="4"><li>백분율</li></ol><p>글자 크기를 %로 지정한다.</p><p>글자 크기의 단위에는 em, ex, px, pt가 있다. font-size에서 가장 많이 사용하는 것은 px이다. 픽셀 단위를 사용할 경우 폰트 크기가 고정되어 모바일 등에서 볼 때에도 크기가 고정된다. 여러 웹 표준성을 고려한다면 em단위를 쓰는 것이 가장 좋긴 하다.</p><p>부모 요소에서 지정한 폰트의 너비를 1em으로 정해놓고 상대적으로 계산하는 방법이다. 기본적으로는 body태그의 16px이 1em으로 지정된다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/saod98h4/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>font-weight : 글자 굵기</li></ul><p>normal은 기본 글자 굵기 이다. 그 외에 bold | lighter | bolder (굵게 | 더 가늘게 | 원래 굵기보다 더 굵게), 100~900 (400이 normal, 700은 bold)가 있다.</p><ul><li>font-variant : 작은 대문자 표시</li></ul><p>소문자를 작은 대문자로 표시할 수 있다. 글을 꾸밀 때 유요하지만 잘 사용하지는 않는다.</p><ul><li>font-style : 글자 스타일 지정하기</li></ul><p>이탤릭체 여부를 결정한다. 속성에는 italic, oblique가 있다.</p><ul><li>font : 글꼴 속성 묶어서 사용하기</li></ul><p>font라는 스타일을 적용해서 위에 설명한 속성들을 한 번에 사용할 수 있다. 그 외에도 caption, icon, menu, message-box, small-caption, status-bar 등 각 상황에 맞는 글꼴을 표시할 수 있다.</p><p>주의할 점은 font-size와 line-height의 차이이다. 둘은 슬래시를 통해 묶어서 사용할 수 있지만, 백분율로 표시했을 때 font-size는 부모요소를 기준으로 line-height는 현재 요소의 글자 크기를 기준으로 한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/dk5nra3o/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><a href="https://www.w3.org/TR/css-fonts-3" target="_blank" rel="noopener">그 외 다양한 폰트 스타일</a><h2 id="텍스트-스타일"><a href="#텍스트-스타일" class="headerlink" title="텍스트 스타일"></a>텍스트 스타일</h2><ul><li>color : 글자 색 지정하기</li></ul><p>색상은 16진수, rgb, rgba, hsl, hsla, 색상 이름으로 지정할 수 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/8f3tj6hw/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>text-decoration : 텍스트에 줄 표시하기/없애기</li></ul><p>텍스트에 줄을 표시하거나 없앨 수 있다. 속성으로는 underline(밑줄), overline(영역 위에 선), line-through(취소 선)이 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/tLqbzco8/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>text-transform : 대 소문자 변환하기</li></ul><p>텍스트의 영문자를 대소문자로 변환시킬 수 있다. 속성으로는 capitalize(첫 글자를 대문자로), uppercase(모든 글자를 대문자로), lowercase(모든 글자를 소문자로), full-width(가능한 모든 문자를 전각문자로) 가 있다.</p><ul><li>text-shadow : 그림자 효과주기</li></ul><p>텍스트에 그림자 효과를 주는 태그이다.</p><pre><code>text-shadow : none | &lt;가로거리&gt; &lt;세로거리&gt; &lt;번짐정도&gt; &lt;색상&gt;</code></pre><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/2s8qLfy1/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>white-space  : 공백 처리하기</li></ul><p>white-space는 공백을 처리하는 속성이다. 속성 값에는 normal, nowrap(공백 그대로계속 한 줄 표시), pre(공백 하나로한줄 표시), pre-line(공백 하나로자동 줄바꿈), pre-wrap(공백 그대로 자동 줄바꿈)이 있다.</p><pre><code>td {  white-space: nowrap;}</code></pre><p>이럴 경우 td 속성의 모든 공백을 한 칸으로 인식하고 줄을 바꾸지 않는다.</p><ul><li>letter-spacing, word-spacing : 텍스트 간격 조절</li></ul><p>letter-spacing은 글자 사이 간격 조절, word-spacing은 단어와 단어 사이의 간격을 조절한다. 보통 letter-spacing 속성으로 자간을 조정한다.</p><h2 id="문단-스타일"><a href="#문단-스타일" class="headerlink" title="문단 스타일"></a>문단 스타일</h2><ul><li>direction : 글자 방향 지정하기</li></ul><p>텍스트를 어느 방향부터 써 나갈 것인지 정하는 속성이다 속성값으로 ltr, rtl이 있다. ltr은 기본 값이다.</p><ul><li>text-align 속성 : 텍스트 정렬하기</li></ul><p>왼쪽 정렬, 가운데 정렬 등 텍스트를 정렬할 때 사용하는 속성이다. 속성 값으로는 start(줄의 시작 위치에 맞춰 문단 정렬), end(텍스트 줄 끝 위치에 맞추어 문단 정렬), left, right, center, justify(양쪽에 맞추어), match-parent(부모 요소에 따라)가 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/hwcaj053/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>text-justify : 정렬 시 공백 조절</li></ul><p>text-align의 속성값이 justify일 경우, 글자 간격이 어색해질 수 있기 때문에 이를 조정하는 속성이다. 속성값으로는 auto, none, inter-word(단어 사이 공백 조절), distribute(인접한 글자 사이 공백을 같게)가 있다.</p><ul><li>text-indent : 텍스트 들여쓰기</li></ul><p>px나 백분율로 조정한다. 백분율은 부모 요소를 기준으로 크기를 지정한다.</p><ul><li>line-height: 줄 간격 조정하기</li></ul><p>역시 숫자, 실제 크기, 백분율로 표시한다. 계산법은 글자 크기가 12px일 때, 줄 간격을 2.0으로 지정하면 실제 줄 간격은  24px이 된다.</p><ul><li>text-overflow : 넘치는 텍스트 표시하기</li></ul><p>넘치는 컨텐츠를 어떻게 처리할 지 정하는 속성이다. 속성값에는 clip(자르기), ellipsis(말 줄임표 사용하기)가 있다. 단, 해당 요소의 overflow속성값이 hidden, scroll, auto이면서 white-space의 속성값이 nowrap일 경우만 적용된다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/8krz23gu/1/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="목록-스타일"><a href="#목록-스타일" class="headerlink" title="목록 스타일"></a>목록 스타일</h2><ul><li>list-style-type : 목록의 불릿과 번호 스타일 지정</li></ul><p>목록 앞에 불릿이나 번호 스타일을 지정할 수 있다. 속성 값으로는 순서 없는 목록에는 disc(원), circle(빈 원), square(사각형),none(불릿 없애기)가 있고 순서가 있는 목록에서 숫자를 바꾸고 싶은 경우 decimal, decimal-leading-zero등 여러가지 속성이 있다.</p><ul><li>list-style-image : 불릿 대신 이미지 넣기</li></ul><p>특정 이미지 속성이 있다면 불릿을 원하는 이미지로 바꿀 수 있다.</p><pre><code>list-style-image:url(&apos;url주소&apos;);</code></pre><ul><li>list-style-position : 목록에 들여 쓰기 효과내기</li></ul><p>목록을 들여쓰기 할 수 있다. 속성값으로는 inside(불릿이나 숫자를 안쪽으로), outside(내어쓰기)가 있다.</p><ul><li>list-style : 위 속성 한번에 묶어 쓰기</li></ul><p>다음 시간에는 색상과 배경에 적용하는 스타일에 대해 알아보겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Text-관련-css&quot;&gt;&lt;a href=&quot;#Text-관련-css&quot; class=&quot;headerlink&quot; title=&quot;Text 관련 css&quot;&gt;&lt;/a&gt;Text 관련 css&lt;/h1&gt;&lt;p&gt;오늘은 텍스트에 적용되는 스타일에 대해 알아보자. 우리가 웹 
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css,css3,css text" scheme="http://rootjang92.github.io/tags/css-css3-css-text/"/>
    
  </entry>
  
  <entry>
    <title>클로저에 대하여</title>
    <link href="http://rootjang92.github.io/2018/09/14/closure/"/>
    <id>http://rootjang92.github.io/2018/09/14/closure/</id>
    <published>2018-09-14T01:35:10.000Z</published>
    <updated>2018-09-14T08:20:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h1><p>앞에서 살펴봤던 실행 컨텍스트에서 클로저에 대해 잠깐 언급했다. 실행 컨텍스트가 소멸하여도 그 환경은 남아 외부에서 참조가 가능하다고 했었지만, 사실 말도 너무 어렵고 이해하기가 어렵다.(저도 그랬습니다… 아직도 완벽하다고 보긴 어렵기도 하고…)</p><pre><code>function outFun() {  var x = 1;  var inFun = function() {    console.log(x);  };  return inFun;};var inner = outFun();inner();</code></pre><p>이 함수를 살펴보자. 함수 outFun()은 내부함수 inFun을 반환하고 소멸했다. 마지막에 함수 outFun()을 할당해준 변수를 소환해도 변수 x에는 접근할 수 없을 것 같지만 결과는 1이 나온다.<br>이처럼 자신을 포함하고 있는 외부함수가 내부함수보다 더 오래 유지되는 경우(그 환경이) 내부함수가 노출되더라도 외부함수의 지역 변에 접근할 수 있는 것을 <strong>클로저(Closure)</strong> 라고 한다.</p><p>다른 정의로는 내부함수가 그 렉시컬 환경(선언 됐을 때 환경)의 스코프를 기억하여 자신의 선언됐을 때 환경 밖에서 호출되어도 그 환경에 접근할 수 있는 함수를 말한다. 즉 <strong>자신의 태어났을 때의 환경을 기억하는 함수</strong>라고 할 수 있다.</p><p><img src="https://poiemaweb.com/img/closure.png" alt="실행컨텍스트"></p><p>내부함수가 유효한 상태에서 외부함수가 종료되어 외부함수의 실행 컨텍스트가 반환되어도, 외부함수 실행 컨텍스트 내의 활성 객체는 내부함수가 참조하는 한 내부함수가 스코프체인을 통해 참조할 수 있다는 것을 의미한다.<br><strong>내부함수가 하나 이상 존재하는 경우 계속 유지된다.</strong> 이 때 내부함수는 외부함수의 실제 변수에 접근한다.</p><h2 id="클로저-활용하기"><a href="#클로저-활용하기" class="headerlink" title="클로저 활용하기"></a>클로저 활용하기</h2><ol><li>전역 변수 억제</li></ol><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/f2twcqpr/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>단 이 코드의 문제는 함수 increase 함수가 호출되기 전 counter의 값이 반드시 0이여야 한다는 것이다. 그렇다고 변수 counter를 increase 함수 안에 넣는다면 함수가 호출될 때마다 값이 초기화가 된다.</p><p>이 코드를 클로저를 활용해 문제를 해결하면</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/1w4q0tru/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>즉시실행함수는 한 번만 실행되기 때문에 counter가 초기화 될 일이 없다. 또한 increaser에 담겨있는 함수가 외부함수 변수 counter에 접근할 수 있다는 것이다. 또한 변수 counter는 private 변수이므로 외부에서의 변경을 신경쓸 필요가 없다. 여기서의 counter가 바로 <strong>자유변수</strong>이다.</p><ol start="2"><li>특정 함수에 사용자가 정의한 객체 메서드 연결</li></ol><p>예제를 살펴보면</p><pre><code>function HelloFunc(func) {  this.greeting = &apos;Helle&apos;;}HelloFunc.prototype.call = function(func) {  func ? func(this.greeting) : this.func(this.greeting);}var user = function(greeting) {  console.log(greeting); // Hello}var objHello = new HelloFunc();objHello.func = user;objHello.call();</code></pre><p>func 프로퍼티에 참조되는 함수를 call() 함수로 호출하여 func 프로퍼티에 자신이 정의한 함수를 참조시켜 호출할 수 있다.<br>다만 greeting만을 인자로 넣어 사용하기 때문에 한 개의 인자를 받는 함수를 정의할 수 밖에 없기 때문에</p><pre><code>function saySomething(obj, methodName, name) {  return (function(greeting) {    return obj[methodName](greeting,name);  });}function newObj(obj, name) {  obj.func = saySomething(this, &quot;who&quot;, name);  return obj;}newObj.prototype.who = function(greeting, name) {  console.log(greeting + &quot; &quot; + (name || &quot;everyone&quot;) );}var obj1 = new newObj(objHello, &quot;Jang&quot;);obj1.call();console.log(obj1);</code></pre><p>첫 번째로  obj.func가 실행되어 saySomething() 함수에서 반환되는 함수를 참조한다. 결국 obj1은 objHello 객체에서 func 프로퍼티에 참조된 함수만 바뀐 객체가 되기 때문에 call 함수를 사용할 수 있다.</p><p>출력결과</p><blockquote><p>Helle<br>Helle Jang<br>HelloFunc { greeting: ‘Helle’, func: [Function] }</p></blockquote><p>또한 obj1.call()로 인해 실행되는 것은 실제로 newObj.prototype.who()가 된다. who를 HelloFunc에 연결할 수 있고 클로저는 saySomething()에서 반환되면 function(greeting) {}이 되어 자유변수 obj, methodName, name을 참조하게 된다.</p><ol start="3"><li><p>함수 캡슐화<br>다음 예제를 통해 자기소개를 출력해보자.</p><p> var getCompleted = (function() {<br>   var buffAr = [</p><pre><code>&apos;I am &apos;,&apos;&apos;,&apos;I live in &apos;,&apos;&apos;,&apos;. I\&apos;m &apos;,&apos;&apos;,&apos; years old.&apos;,</code></pre><p>   ];<br>   return (function(name, city, age) {</p><pre><code>buffAr[1] = name;buffAr[3] = city;buffAr[5] = age;return buffAr.join(&apos;&apos;);</code></pre><p>   });<br> })();</p><p> var str = getCompleted(‘Jang’, ‘Incheon’, 27);<br> console.log(str);</p></li></ol><p>변수 getComplted에 익명 함수를 즉시 실행함수로 실행시켜서 반환되는 함수를 할당하는 것이다. 여기서 반환되는 함수가 클로저가 되서 자유변수 buffAr을 스코프체인에서 참조할 수 있다.</p><ol start="4"><li>setTimeout()</li></ol><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/1mkwqr95/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>첫번째로 함수 fade가 document.body를 인자로 전달받아서 호출한다. 그 후 함수 fade의 지역변수인 level이 1로 초기화가 되어 있다. step은 내부함수, 외부 함수 fade의 지역변수 level을 사용하고 level은 자유 변수다.<br>setTimeout() 호출 후에는 fade 함수는 종료되지만, 100ms 이후에 함수 step이 호출된다.<br>step은 지역 변수 hex를 갖고 16진수 문자열이다. fade의 배경색을 변경할 수 있다.<br>그 후 변수 level이 15보다 작은지 확인한다. 그 후 level = 1을 증가시켜 작업을 반복한다.</p><ol start="5"><li>실수</li></ol><p>클로저의 프로퍼티값이 쓰기 가능하면 여러번 호출로 값이 항상 변할 수 있다.</p><pre><code>function outerFun(argNum) {  var num = argNum;  return function(x) {    num += x;    console.log(&apos;num : &apos; + num);  }}var exam = outerFun(40);exam(5); // 45exam(-5); //40</code></pre><p>exam을 호출할 때마다 num의 값이 변한다.</p><p>하나의 클로저가 여러 함수 객체의 스코프 체인에 들어있는 경우.</p><pre><code>function func() {  var x = 1;  return {    func1 : function(){ console.log(++x); },    func2 : function(){ console.log(-x); }  };};var exam = func();exam.func1(); // 2exam.func2(); // -2</code></pre><p>함수 호출 때마다 값이 변하므로 주의.</p><p>루프 안 클로저 활용.</p><pre><code>var arr = [];for(var i = 0; i &lt; 5; i++) {  arr[i] = function() {    return i;  };}for (var j=0; j &lt; arr.length; j++) {  console.log(arr[j]());} // 55555</code></pre><p>배열 arr 안에 5개의 함수가 할당되지만 변수 i가 전역변수이기 때문에 이미 길이가 5가 된 상태이기 때문이다.<br>이를 해결하기 위해서</p><pre><code>var arr = [];for (var i = 0; i &lt; 5; i++) {  arr[i] = (function (id) {    return function() {      return id;    };  }(i));}for (var j=0; j &lt; arr.length; j++) {  console.log(arr[j]());} // 01234</code></pre><p>이런 식으로 즉시 실행 함수를 사용하여 매개변수 id를 자유변수를 만들어 반환하면 id의 값이 유지된다.</p><p>물론 ES6의 let 키워드를 사용하면 말끔히 해결된다.(일시적 사각지대가 생기기 때문에.)</p><p>다음 시간에는 객체지향 프로그래밍의 개념에 대해 알아보겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;클로저&quot;&gt;&lt;a href=&quot;#클로저&quot; class=&quot;headerlink&quot; title=&quot;클로저&quot;&gt;&lt;/a&gt;클로저&lt;/h1&gt;&lt;p&gt;앞에서 살펴봤던 실행 컨텍스트에서 클로저에 대해 잠깐 언급했다. 실행 컨텍스트가 소멸하여도 그 환경은 남아 외부에서 참
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="Javascript, js, es5, closure, js closure" scheme="http://rootjang92.github.io/tags/Javascript-js-es5-closure-js-closure/"/>
    
  </entry>
  
  <entry>
    <title>실행 컨텍스트와 스코프</title>
    <link href="http://rootjang92.github.io/2018/09/12/executioncontext/"/>
    <id>http://rootjang92.github.io/2018/09/12/executioncontext/</id>
    <published>2018-09-12T07:33:21.000Z</published>
    <updated>2018-09-14T01:34:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="실행-컨텍스트와-스코프"><a href="#실행-컨텍스트와-스코프" class="headerlink" title="실행 컨텍스트와 스코프"></a>실행 컨텍스트와 스코프</h1><h2 id="실행-컨텍스트란"><a href="#실행-컨텍스트란" class="headerlink" title="실행 컨텍스트란?"></a>실행 컨텍스트란?</h2><p>ECMAScript의 정의를 살펴보면 <strong>실행 가능한 코드를 형상화하고 구분하는 추상적인 개념</strong>이라고 설명하고 있다.<br>즉 실행 가능한 자바스크립트 코드 블록이 실행되는 환경이라고 할 수 있다. 실행 가능한 코드에는 전역 코드, eval() 코드, 함수 코드가 있다.</p><p>우리는 오늘 한가지 예제를 통해 콜 스택부터 실행 컨텍스트, 스코프가 어떻게 설계되는 지에 대해 살펴보도록 하겠다.</p><a href="https://poiemaweb.com/js-execution-context" target="_blank" rel="noopener">참조사이트</a><pre><code>var x = &apos;xxx&apos;;function foo () {  var y = &apos;yyy&apos;;  function bar () {    var z = &apos;zzz&apos;;    console.log(x + y + z);  }  bar();}foo();</code></pre><p>이 코드에서는 스택이 쌓이고 소멸하게 된다.</p><p><img src="https://poiemaweb.com/img/ec_1.png" alt="stack"></p><ol><li>실행 가능한 코드가 새로운 실행 컨텍스트 스택으로 생성된다. 이때는 후입선출(LIFO)로 진행된다.</li><li>전역 실행 컨텍스트는 처음에 만들어져 컨텍스트가 끝날 때까지 유지된다</li><li>함수 호출 시 스택이 쌓인다.</li><li>함수 호출이 끝나면 실행 컨텍스트를 파기하고 직전 실행 컨텍스트의 컨트롤을 반환한다.</li></ol><h2 id="실행-컨텍스트-생성과정"><a href="#실행-컨텍스트-생성과정" class="headerlink" title="실행 컨텍스트 생성과정"></a>실행 컨텍스트 생성과정</h2><ol><li>전역 컨텍스트의 경우<br>전역에 선언된 전역변수와 전역 함수를 객체로 갖는다.</li></ol><p><img src="https://poiemaweb.com/img/ec-vo-global.png" alt="go"></p><ol start="2"><li>함수 컨텍스트의 경우<br>활성 객체를 가리키며 매개변수와 인수들의 정보를 가지고 있는 arguments객체가 추가된다.</li></ol><p><img src="https://poiemaweb.com/img/ec-vo-foo.png" alt="ao"></p><p>순서로는 우선 활성 객체를 생성한다. 그 후 arguments 객체를 생성한다. 이 떄 활성객체는 arguments 프로퍼티로 arguments 객체를 참조하게 된다. 그 후 스코프의 정보를 생성한다. 연결 리스트와 유사한 형태로 만들어지며 [[scope]] 프로퍼티로 참조된다. 그 후 변수를 생성한다. 주의할 점은 생성과 초기화만 진행할 뿐, 실행되기 전까지는 할당이 이루어지지 않는다는 것이다. 마지막으로 this를 할당하는 데 함수 호출 패턴에 따라 this가 참조하는 객체가 정해진다.</p><ul><li>전역 코드 진입</li></ul><p>전역 객체가 생성되면 전역 코드로 컨트롤이 진입하여 전역 실행 컨텍스트가 생성되고 실행 컨텍스트가 쌓인다.</p><p><img src="https://poiemaweb.com/img/ec_4.png" alt="전역코드"></p><ul><li>스코프 체인 생성 및 초기화</li></ul><p>이 때 스코프체인은 전역 객체 레퍼런스를 포함한다.</p><p><img src="https://poiemaweb.com/img/ec_5.png" alt="스코프체인"></p><ul><li>변수 객체화</li></ul><p><img src="https://poiemaweb.com/img/ec_6.png" alt="변수 객체화"></p><p>여기선 매개변수가 변수 객체의 프로퍼티로 인수가 값으로 설정된다. 그 후 코드 내 함수 선을 대상으로 변수 객체가 프로퍼티로, 생성된 함수 객체가 값으로 설정되며 함수 호이스팅이 발생한다. 그 다음 대상 코드 대상으로 변수 명이 변수 객체의 프로퍼티로 undefined가 값으로 설정된다. 이를 변수 호이스팅이라고 한다.</p><p>이후 위 코드의 함수 foo가 처리된다. 함수 foo가 프로퍼티로 생성된 함수 객체가 값으로 지정된다. 이 때 생성된 함수 객체는 [[scope]] 프로퍼티를 가진다. 이 때 [[scope]] 프로퍼티는 자신의 실행환경을 가지고 자신을 포함하는 외부 함수와 실행 환과 전역 객체를 가리킨다. 또한 자신을 포함하는 외부 함수의 실행 컨텍스트가 소멸하여도 [[scope]] 프로퍼티가 가리키는 외부함수 실행환경을 참조할 수 있는데 이것이 클로저다.</p><p>이후 변수 x를 처리하는데 var 변수는 선언과 초기화가 한 번에 이루어진다. 그 후 this value를 정한다. 이전에는 this가 전역 객체를 가리키다가, 함수 호출 패턴에 이해 this가 정해진다.</p><p><img src="https://poiemaweb.com/img/ec_9.png" alt="this까지"></p><p><a href="href=https://rootjang92.github.io/2018/09/10/jsfuncthis/}>https://rootjang92.github.io/2018/09/10/jsfuncthis/}</a></p>" title="<p>주의할 점은 아직 <strong>코드가 실행되지 않았다</strong>는 것이다.</p> <h2 id=코드-실행><a href=#코드-실행 class=headerlink title=코드 실행></a>코드 실행</h2><p>코드가 실행되면 우선 변수의 값을 할당하게 된다. 우선 전역 객체에 변수 x의 값이 할당되고 그 후 함수 foo가 실행된다.<br>그러면 다시 함수 foo의 스코프체인을 생성하고 초기화한다. 그 구조를 살펴보면 함수 foo를 실행한 직후 실행 컨텍스트의 스코프체인은 활성 객체(지금은 함수 foo)를 살피고 그 후 전역 객체를 살펴본다.</p> <p><img src=https://poiemaweb.com/img/ec_13.png alt=코드실행></p> <p>이를 통해 생성된 활성 객체가 변수 객체로서 변수 인스턴스화를 실행한다. 그 후에 과정은 위와 같으니 그림으로 대신하겠다.</p> <p><img src=https://poiemaweb.com/img/ec_16.png alt=foo><br>내부함수의 경우 this는 전역 객체를 가리킨다.</p> <p>이제 foo 함수를 실행되면, 변수 y의 값이 할당된다.<br>함수 bar의 과정도 위와 동일하다.</p> <ol> <li>스코프 체인의 생성과 초기화, 2. Variable Instantiation 실행, 3. this value 결정</li> </ol> <p><img src=https://poiemaweb.com/img/ec_19.png alt=최종></p> <h2 id=다른-예제><a href=#다른-예제 class=headerlink title=다른 예제></a>다른 예제</h2><p>다른 예제를 살펴보자<br>(참고 : 인사이드 자바스크립트)</p> <pre><code>var value = &quot;value1&quot;;function printValue() {  return value;}function printFunc(func) {  var value = &quot;value2&quot;;  console.log(func());}printFunc(printValue);</code></pre><p>항상 실행 컨텍스트를 생각해야 한다. 전역 실행 컨텍스트가 만들어지는 데 그 안에 동등한 함수 printValue와 printFunc가 존재한다.</p> <p>두 함수가 실행될 때의 [[scope]] 프로퍼티를 살펴보면 각각의 변수 객체를 만들고 그것을 참조하게 된다.</p> <p>printFunc를 실행하면 value: “value2”로 변수 객체가 생성된다. 또한 printValue의 변수 객체는 전역 객체에서 찾게 되므로 따로 변수 객체가 만들어지지 않는다.</p> <p>다음 시간에는 클로저에 대해 살펴보도록 하겠습니다.</p>">함수 호출 패턴 <a< a=""></a<></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;실행-컨텍스트와-스코프&quot;&gt;&lt;a href=&quot;#실행-컨텍스트와-스코프&quot; class=&quot;headerlink&quot; title=&quot;실행 컨텍스트와 스코프&quot;&gt;&lt;/a&gt;실행 컨텍스트와 스코프&lt;/h1&gt;&lt;h2 id=&quot;실행-컨텍스트란&quot;&gt;&lt;a href=&quot;#실행-컨텍
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="js, javascript, execution context, scope" scheme="http://rootjang92.github.io/tags/js-javascript-execution-context-scope/"/>
    
  </entry>
  
  <entry>
    <title>CSS의 기초 살펴보기</title>
    <link href="http://rootjang92.github.io/2018/09/12/cssbasic/"/>
    <id>http://rootjang92.github.io/2018/09/12/cssbasic/</id>
    <published>2018-09-12T02:04:28.000Z</published>
    <updated>2018-09-23T03:44:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="왜-css인가"><a href="#왜-css인가" class="headerlink" title="왜 css인가?"></a>왜 css인가?</h1><p>웹 문서에 텍스트만 있다면 어떤 느낌일 것 같은가? 물론 기존 html로 기초적인 스타일링은 할 수 있지만 지금은 2018년, 4차 산업 혁명 시대 아니겠는가? css는 우리가 보는 view라는 웹 문서를 꾸미는 언어라고 보면 된다.<br>css의 가장 큰 장점은 웹 문서를 건드리지 않고 단순히 <strong>디자인만 바꿀 수 있다.</strong>라는 정말 큰 장점이 있다.</p><a href="http://www.csszengarden.com" target="_blank" rel="noopener">참고할 만한 사이트</a><p>또한 웹 문서는 브라우저 기반이기 때문에 브라우저에 따라, 사용하는 기종에 따라 그 모습이 바뀐다.</p><ul><li>스타일 형식은?</li></ul><p>ex)<br>p{text-align: center;}</p><p>p태그의 글자를 가운데로 옮기는 css 문법이다. 여기서 p는 <strong>selector(선택자)</strong>, text-align은 <strong>Property(스타일 속성)</strong> center는 <strong>Property Value(속성 값)</strong> 이라고 한다.</p><ul><li>주석</li></ul><p>주석은 참 중요하지 않아보이지만 굉장히 중요하다. 물론 주석없이 바로바로 해석되는 게 정말 가독성이 좋은 코드라고 할 수 있지만, 모두가 그럴 순 없기에 <strong>이 코드가 어떻게 사용되었다.</strong>라는 걸 설명해 주는 것이 좋다. css의 주석은 /<em> </em>/ 사이에 텍스트를 작성한다.</p><ul><li>내부 스타일과 외부 스타일</li></ul><p>css는 html문서 안에서 작성할 수도 있다. 이를 내부 스타일 시트라고 하는데 보통 head태그 안에 title밑, style ~ /style 태그 사이에 작성한다. 반면 외부 스타일 시트는 css 파일을 따로 작성하여 html 문서에서 link태그를 사용하여 연결한다.</p><pre><code>&lt;link href=&quot;파일 경로&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</code></pre><p>보통 외부에 css 파일을 만들어 사용하는 것이 좋은데 필요한 경우에 따라 만들어 놓은 css를 가져다 사용할 수 있기 때문이다.</p><p>또한 html 태그안에 인라인 스타일로 작성할 수도 있다.</p><pre><code>&lt;p style=&quot;color:blue&quot;&gt;</code></pre><p>이런식으로 말이다.</p><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>스타일 속성을 작용하는 요소가 바로 선택자이다. 태그 하나에 지정할 수도, 여러개에 지정할 수도 있다.</p><ul><li>전체 선택자</li></ul><p>모든 요소에 적용할 때 사용하는 것이 전체 선택자 이다. 전체 선택자는 *를 사용한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/bnL3c5p9/1/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>태그 선택자</li></ul><p>해당 요소에 스타일을 적용할 때 사용한다. 해당 태그가 사용된 모든 요소에 적용된다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/r9k2v5ha/1/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>클래스 선택자</li></ul><p>해당 태그에 클래스를 지정하여 그 클래스가 지정된 요소에만 스타일이 적용되게 할 때 사용한다. 사용할 때에는 ‘.’을 사용한다. 특히 클래스는 중복이 가능하기 때문에 태그를 적요하고 싶은 태그만 골라 클래스를 적용하여 스타일을 적용할 수 있다. 다른 경우도 있다. 예를 들어 h2.bluetext라고 사용한다면 h2에 있는 bluetext 클래스에만 스타일이 적용된다. 참고로 부분적으로 적용하고 싶을 때에는 span 태그를 사용하면 된다.</p><ul><li>id 선택자</li></ul><p>클래스와 마찬가지로 특정 부분에 스타일을 적용하고 싶을 때 사용하지만, id는 중복이 허용되지 않는다. 또 다른점은 id는 #을 사용한다는 것이다.</p><ul><li>그룹 선택자</li></ul><p>따로따로 선언할 필요 없이 같은 스타일을 적용할 때에는 쉼표로 구분해주면 된다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/9kwurca7/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="Cascading"><a href="#Cascading" class="headerlink" title="Cascading"></a>Cascading</h2><p>캐스캐이딩의 의미는 선택자에 적용된 많은 스타일 중 어떤 스타일을 나타낼지를 결정한다는 의미이다. 스타일 간의 충돌을 막기 위해 무엇이 우선시 되어야 할 지 정하는 것이다. 그를 위해선</p><ol><li>스타일 우선순위</li><li>스타일 상속</li></ol><p>이 두가지 원칙에 대해서 알아야 한다.</p><ul><li>스타일 우선순위란?</li></ul><p>캐스캐이딩에 있어서 정말 중요한 개념이라고 할 수 있다. ‘어떤 스타일을 먼저 적용할까’를 결정하기 때문이다.<br>첫 번째로 중요도를 살펴봐야 한다.</p><ul><li>중요도</li></ul><ol><li>사용자 스타일 시트가 최우선이다.</li><li>!important (다른 어떤 것보다 최우선 되는 스타일)</li><li>기본 브라우저 스타일 시트</li></ol><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/5yhwnxdq/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>명시도</li></ul><p>명시도는 스타일의 적용 범위에 따라 우선순위를 정함을 말한다. 가장 중요한 것부터 말하자면</p><ol><li>인라인 스타일</li><li>id 스타일</li><li>클래스 스타일</li><li>태그 스타일</li></ol><p>의 순서로 중요도가 적용된다.</p><ul><li>소스 순서</li></ul><p>앞에 설명했던 중요도와 명시도가 같다면 먼저 온 스타일을 나중에 온 스타일이 겹친다. 위 예제에서 !important가 없다면 글자는 파란색이 될 것이다.</p><h2 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h2><p>스타일은 상속된다. 웹 문서에 사용되는 태그들은 서로 포함관계에 있다. 그 중에서는 부모요소 자식요소의 관계도 포함되어 있다.<br>자식 요소에 따로 스타일을 지정하지 않으면 부모 요소에 있는 스타일 속성이 전달된다. 이를 스타일 상속이라고 한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/abthmcod/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>부모 요소의 배경 이미지, 배경 색 등은 상속되지 않는다. 즉 부모 요소의 모든 스타일 요소가 상속되는 것은 아니다.</p><h2 id="CSS-Module"><a href="#CSS-Module" class="headerlink" title="CSS Module"></a>CSS Module</h2><a href="https://www.w3.org/Style/CSS" target="_blank" rel="noopener">css3참조하기</a><p>여러가지 css 규약이나 상태등을 볼 수 있다.</p><ul><li>prefix</li></ul><p>css 모듈에는 규약이 많고 아직 미완성 상태이기 떄문에 모든 브라우저에서 똑같이 적용되지 않는 경우도 있다. 또한 버전에 따라서도 지원이 되고 안되고의 차이가 있기 때문에 브라우저 접두사를 붙여서 사용한다. 이를 <strong>prefix</strong>라고 한다.</p><p>-webkit- (사파리, 크롬), -moz-(모질라, 파이어폭스), -o-(오페라), -ms-(IE)</p><pre><code>-webkit-column-count:3;</code></pre><p>앞에 접두사를 붙이고 속성을 사용하면 된다.</p><p>근데 귀찮다.(매우매우) 그래서 유용한 사이트를 소개하자면</p><a href="http://leaverou.github.io/prefixfree/" target="_blank" rel="noopener">prefix-free</a><p>에서 Only 2kb gzipped에서 js 파일을 받아 폴더에 넣어 script태그로 연결해주면 된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;왜-css인가&quot;&gt;&lt;a href=&quot;#왜-css인가&quot; class=&quot;headerlink&quot; title=&quot;왜 css인가?&quot;&gt;&lt;/a&gt;왜 css인가?&lt;/h1&gt;&lt;p&gt;웹 문서에 텍스트만 있다면 어떤 느낌일 것 같은가? 물론 기존 html로 기초적인 스타
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css,css3,css basic" scheme="http://rootjang92.github.io/tags/css-css3-css-basic/"/>
    
  </entry>
  
  <entry>
    <title>Todo app 만들기</title>
    <link href="http://rootjang92.github.io/2018/09/12/todo/"/>
    <id>http://rootjang92.github.io/2018/09/12/todo/</id>
    <published>2018-09-12T01:55:37.000Z</published>
    <updated>2018-09-12T01:58:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Todo-프로젝트-만들기"><a href="#Todo-프로젝트-만들기" class="headerlink" title="Todo 프로젝트 만들기."></a>Todo 프로젝트 만들기.</h1><p>이 프로젝트는 ES5와 ES6를 이용하여 만들었습니다. 그 외 Angular를 활용한 코드도 깃허브에 있으니 참조하여 보시면 감사하겠습니다.</p><div class="video-container"><iframe src="//www.youtube.com/embed/roupTOK6ZYo" frameborder="0" allowfullscreen></iframe></div><a href="https://github.com/Rootjang92/todos" target="_blank" rel="noopener">깃허브페이지</a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Todo-프로젝트-만들기&quot;&gt;&lt;a href=&quot;#Todo-프로젝트-만들기&quot; class=&quot;headerlink&quot; title=&quot;Todo 프로젝트 만들기.&quot;&gt;&lt;/a&gt;Todo 프로젝트 만들기.&lt;/h1&gt;&lt;p&gt;이 프로젝트는 ES5와 ES6를 이용하여 만
      
    
    </summary>
    
      <category term="Project" scheme="http://rootjang92.github.io/categories/Project/"/>
    
      <category term="todo" scheme="http://rootjang92.github.io/categories/Project/todo/"/>
    
    
      <category term="todo,todolist,front-end" scheme="http://rootjang92.github.io/tags/todo-todolist-front-end/"/>
    
  </entry>
  
  <entry>
    <title>프로토타입 체이닝</title>
    <link href="http://rootjang92.github.io/2018/09/11/jsprotochain/"/>
    <id>http://rootjang92.github.io/2018/09/11/jsprotochain/</id>
    <published>2018-09-11T05:40:20.000Z</published>
    <updated>2018-09-11T06:54:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="프로토타입-체이닝"><a href="#프로토타입-체이닝" class="headerlink" title="프로토타입 체이닝"></a>프로토타입 체이닝</h1><p>자바스크립트는 <strong>프로토타입 기반 객체지향 언어</strong>이다. 자바스크립트를 이해하기 위해서 무조건 알아가야 할 개념 중 하나가 이 프로토타입이다.<br>그래서 오늘은 상속의 개념을 구현하는 프로토타입과 프로토타입 체이닝에 대해 글을 써보려고 한다.</p><p>가장 중요한 건 <strong>자신을 생성한 생성자 함수의 prototype 프로퍼티가 가리키는 프로토타입 객체를 자신의 부모로 설정하는 [[prototype]]링크로 연결한다.</strong> 이다.</p><pre><code>function Person(name) {  this.name = name;}var foo = new Person(&apos;Jang&apos;);console.dir(Person);console.dir(foo);</code></pre><p>이 코드는 그림 한장으로 설명할 수 있다.</p><p><img src="https://poiemaweb.com/img/constructor_function_prototype_chaining.png" alt="프로토타입"></p><p>결국 prototype 프로퍼티나 [[prototype]]은 같은 객체를 가리키고 있다는 걸 알 수 있다.<br>즉, 객체를 생성하는 건 생성자 함수가 하지만 그 부모 역할을 하는 건 생성자의 prototype 프로퍼티가 가리키는 <strong>프로토타입 객체</strong>이다.</p><h2 id="객체-리터럴로-생성된-객체의-프로토타입-체이닝"><a href="#객체-리터럴로-생성된-객체의-프로토타입-체이닝" class="headerlink" title="객체 리터럴로 생성된 객체의 프로토타입 체이닝"></a>객체 리터럴로 생성된 객체의 프로토타입 체이닝</h2><p>프로토타입 체이닝이란 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티를 사용할 수 있는 것을 말한다.</p><pre><code>var myObj = {  name: &apos;Jang&apos;,  sayName: function() {    console.log(&apos;My name is &apos; + this.name);  }};myObj.sayName();console.log(myObj.hasOwnProperty(&apos;name&apos;));console.log(myObj.hasOwnProperty(&apos;nickName&apos;));myObj.sayNickname();</code></pre><p>출력결과</p><blockquote><p>My name is Jang<br>true<br>false<br>TypeError: myObj.sayNickname is not a function</p></blockquote><p>hasOwnProperty() 메서드는 호출한 객체에 인자로 넘긴 문자열 으림의 프로퍼티나 메서드가 있는지 체크하는 API 함수이다.<br>myObj에는 name 프로퍼티가 있기 때문에 true가 출력되었다. 하지만 myObj에서 hasOwnProperty()를 사용할 수 있는 이유는 [[prototype]] 링크로 연결된 Object.prototype 객체에 hasOwnProperty() 메서드가 존재하기 때문이다.</p><p>결국 프로토타입 체이닝은 해당 객체에 접근하려는 프로퍼티나 메서드가 없다면 <strong>[[prototype]]링크를 따라서 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티를 차례대로 검색하는 것</strong>을 말한다.</p><h2 id="생성자-함수로-생성된-객체의-프로토타입-체이닝"><a href="#생성자-함수로-생성된-객체의-프로토타입-체이닝" class="headerlink" title="생성자 함수로 생성된 객체의 프로토타입 체이닝"></a>생성자 함수로 생성된 객체의 프로토타입 체이닝</h2><pre><code>function Person(name, age, hobby) {  this.name = name;  this.age = age;  this.hobby = hobby;}var foo = new Person(&apos;Jang&apos;, 27, &apos;Soccer&apos;);console.log(foo.hasOwnProperty(&apos;name&apos;));console.dir(Person.prototype);</code></pre><p>출력결과</p><blockquote><p>true<br>Person {}(Object)</p></blockquote><p>Person() 함수가 생성한 foo 객체의 프로토타입 객체는 Person.prototype이 된다. 하지만 Person.prototype에는 hasOwnProperty 메서드가 없다. 하지만 결과값은 true가 나오는데 그 이유는 프로토타입 체이닝의 종점인 Object.prototype 객체에 존재하기 떄문이다.<br>Person.prototype 역시 객체이기 때문에 <strong>Object.prototype을 프로토타입 객체로 가진다.</strong></p><p><img src="https://poiemaweb.com/img/constructor_function_prototype_chaining.png" alt="프로토타입체이닝"></p><h2 id="기본-데이터-타입-확장"><a href="#기본-데이터-타입-확장" class="headerlink" title="기본 데이터 타입 확장"></a>기본 데이터 타입 확장</h2><p>숫자, 문자열, 배열 등이 사용하는 표준 메서드는 그들의 프로토타입에 정의되어 있다. 또한 기본 내장 프로토타입도 Object.prototype을 자신의 프로토타입으로 가지고 있다.(알면 알수록 놀랍습니다…) 또한 자바스크립트는 표준 빌트인 프로토타입 객체에도 사용자가 직접 정의한 메서드를 추가할 수 있다.</p><pre><code>String.prototype.testMethod = function() {  console.log(&apos;Testing method in String.prototype.testMethod()&apos;);};var str = &quot;this is test&quot;;str.testMethod();console.dir(String.prototype);</code></pre><p>출력 결과</p><blockquote><p>Testing method in String.prototype.testMethod()<br>{ [String: ‘’] testMethod: [Function] }</p></blockquote><p>구글 크롬의 브라우저 출력화면을 보면 다양한 메서드가 쭉 나오는데 testMethod가 추가된 것을 볼 수 있을 것이다.(꼭 해보시길!)</p><h2 id="프로토타입-메서드와-this"><a href="#프로토타입-메서드와-this" class="headerlink" title="프로토타입 메서드와 this"></a>프로토타입 메서드와 this</h2><p>앞에서 봤던 <a href="https://rootjang92.github.io/2018/09/10/jsfuncthis">객체의 메서드를 호출할 때 this바인딩</a><br>의 규칙과 같다. 그 메서드를 호출한 객체에 바인딩 된다.</p><h2 id="디폴트-프로토타입"><a href="#디폴트-프로토타입" class="headerlink" title="디폴트 프로토타입"></a>디폴트 프로토타입</h2><p>디폴트 프로토타입은 한 마디로 함수가 생성될 때 같이 생성된다. 자바스크립트에서는 이러한 디폴트 프로토타입을 다른 일반 객체로 변환할 수 있다.<br>단, 변경된 시점에서 생성된 객체들은 변경된 프로토타입 객체로 [[prototype]] 링크를 연결한다.</p><pre><code>function Person(name) {  this.name = name;}console.log(Person.prototype.constructor); // 1var foo = new Person(&apos;Jang&apos;);console.log(foo.country); // 2Person.prototype = {  country : &apos;Republic of Korea&apos;};console.log(Person.prototype.constructor); //3var bar = new Person(&apos;Lee&apos;);console.log(foo.country); //4console.log(bar.country); //5console.log(foo.constructor); //6console.log(bar.constructor); //7</code></pre><p>출력결과</p><blockquote><p>[Function: Person] // 1<br>undefined // 2<br>[Function: Object] // 3<br>undefined // 4<br>Republic of Korea // 5<br>[Function: Person] // 6<br>[Function: Object] // 7</p></blockquote><p>2번을 살펴보자 foo 객체에는 country 프로퍼티가 없고 Person.prototype객체도 마찬가지이다. 체이닝이 일어나도 결국 undefined<br>3번을 살펴보자 country라는 프로퍼티를 가진 객체로 변화시켰다. 그 결과로 이 객체에는 constructor가 존재하지 않는다. 일반 객체로 변화했기 때문이다. 일반 객체는 Object.prototype 객체로 프로토타입 체이닝이 발생하고 그 결과 그 constructor는 Object로 출력된다.<br>또한 생성된 bar 프로퍼티도 새로 변경된 프로토타입 객체를 가리킨다. 그렇기 때문에 서로 다른 결과값이 발생하는 것이다.</p><p><img src="https://poiemaweb.com/img/changing_prototype.png" alt="디폴트"></p><h2 id="주의할-점"><a href="#주의할-점" class="headerlink" title="주의할 점"></a>주의할 점</h2><p>프로토타입은 특정 프로퍼티를 <strong>읽거나</strong>, <strong>메서드를 실행할 때</strong> 발생한다. 다른 객체에 있는 특정 프로퍼티를 쓰려고 할 때에는 프로토타입 체이닝이 동작하지 않고 동적으로 프로퍼티를 생성한다.</p><pre><code>function Person(name) {  this.name = name;}Person.prototype.country = &apos;Republic of Korea&apos;;var foo = new Person(&apos;foo&apos;);var bar = new Person(&apos;bar&apos;);console.log(foo.country);console.log(bar.country);foo.country = &apos;USA&apos;;console.log(foo.country);console.log(bar.country);</code></pre><p>출력결과</p><blockquote><p>Republic of Korea<br>Republic of Korea<br>USA<br>Republic of Korea</p></blockquote><p>foo.country 값에 ‘USA’를 지정하면 foo 객체 자체에 country 프로퍼티가 동적으로 생성된다. 그래서 bar 객체는 프로토타입 체이닝을 거쳐 ‘Republic of korea’가 출력된다.</p><p>다음 시간에는 실행 컨텍스트와 클로저에 대해 알아보겠습니다!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;프로토타입-체이닝&quot;&gt;&lt;a href=&quot;#프로토타입-체이닝&quot; class=&quot;headerlink&quot; title=&quot;프로토타입 체이닝&quot;&gt;&lt;/a&gt;프로토타입 체이닝&lt;/h1&gt;&lt;p&gt;자바스크립트는 &lt;strong&gt;프로토타입 기반 객체지향 언어&lt;/strong&gt;이
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="Javascript, JS prototype, prototype chain" scheme="http://rootjang92.github.io/tags/Javascript-JS-prototype-prototype-chain/"/>
    
  </entry>
  
  <entry>
    <title>Input 태그</title>
    <link href="http://rootjang92.github.io/2018/09/10/htmlinput/"/>
    <id>http://rootjang92.github.io/2018/09/10/htmlinput/</id>
    <published>2018-09-10T06:30:48.000Z</published>
    <updated>2018-09-11T05:39:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="태그"><a href="#태그" class="headerlink" title=" 태그"></a><input> 태그</h1><h2 id="Input-태그란"><a href="#Input-태그란" class="headerlink" title="Input 태그란?"></a>Input 태그란?</h2><p>Input 태그는 기본적으로 입력 항목을 만드는 태그다.<br>체크박스 등의 클릭하는 버튼도 input 태그를 활용해 만든다.<br>원래는 form 태그 안에 속해야 하지만 ajax통신에서는 그러지 않아도 된다.</p><ul><li>id 속성을 사용하면 label 태그를 사용할 수 있다.</li></ul><ul><li>Input 태그의 type 속성에 사용 하는 유형.<a href="http://aboooks.tistory.com/294" target="_blank" rel="noopener">input type태그속성</a></li></ul><p>하지만 브라우저마다 지원이 다르기 때문에 이 사이트를 참조하여 얼마나 지원하는 지 알아보면 좋다.</p><a href="http://caniuse.com" target="_blank" rel="noopener">브라우저지원확인</a><h2 id="Input-태그-사용하기"><a href="#Input-태그-사용하기" class="headerlink" title="Input 태그 사용하기."></a>Input 태그 사용하기.</h2><ul><li><p>type=”hidden”<br>히든필드는 관리자가 알아야 할 정보를 입력할 때 사용합니다. 그렇기 떄문에 사용자에게는 보이지 않는다.(view상에서)</p>  <input type="hidden" name="이름" value="서버로 넘길 값"></li></ul><ul><li><p>type=”text”<br>텍스트 필드를 만들 때 사용한다. 폼에서 가장 많이 사용한다고 볼 수 있다.</p><p>  &lt;input type=”text” [속성=”속성값”]&gt;</p></li></ul><p>속성에는 name, size(필드 길이 지정), value(화면에 표실될 내용), maxlength(최대 길이)가 있다.</p><ul><li><p>type=”password”<br>비밀번호를 입력하는 창을 만들 때 사용한다.</p><p>  &lt;input type=”password” [속성=”속성값”]&gt;</p></li></ul><ul><li>type=”search”,”url”,”email”,”tel”</li></ul><p>각각, 검색 상자, URL 입력, 메일 주소 입력, 전화번호 입력 창을 만들 때 사용한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/j269fowt/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>type=”number”</li></ul><p>사용자가 입력한 내용을 숫자로 인식하는 창이다. 스핀 박스를 사용해 갯수를 조정할 수 있다.</p><ul><li>type=”range”</li></ul><p>슬라이드 막대로 범위를 지정할 수 있다. 이 속성은 브라우저 지원 버전을 확인 후 사용하여야 한다.</p><p>number, range모두 min,max,step(짝수,홀수 등 특정 숫자 지정),value 속성을 사용할 수 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/mk0jtfw6/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>type=”radio”, “checkbox”</li></ul><p>라디오 버튼과 체크박스 버튼을 생성한다. 이 둘은 여러항목 중 자신이 원하는 항목을 선택할 때 사용한다.<br>한 개만 선택할 경우 라디오 버튼, 중복 체크가 가능하도록 할 때는 체크박스 버튼을 사용한다.</p><p>속성으로는 name, value, checked(기본으로 선택해 놓을 화면) 속성이 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/wyLp1r2h/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>type=”color”</li></ul><p>색상을 선택할 수 있게 창을 만들어준다. 색상은 16진수로 표시되기 때문에 텍스트로 색상을 선택할 수는 없다.</p><pre><code>&lt;input type=&quot;color&quot; value=&quot;기본색&quot;&gt;</code></pre><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/go9jw6br/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>type=”date”, “month”, “week”</li></ul><p>날짜를 표시하는 속성이다.</p><pre><code>&lt;input type=&quot;date | month | week&quot; [value=&quot;기본값&quot; 속성=&quot;속성값&quot;]&gt;</code></pre><p>date로 지정하면 yyyy-mm-dd 형식으로 month는 yyyy-mm, week는 yyyy-w24로 표시된다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/5347u2xz/embedded/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>type=”time”,”datetime”,”datetime-local”</li></ul><p>시간 지정하는 속성이다. 시간을 지정할 때는 time, 날짜와 시간은 datetime,datetime-local을 사용하면 된다.<br>min,max,step,value를 사용할 수 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/yb63w1df/1/embedded/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>type=”submit”,”reset”</li></ul><p>서버 전송과 리셋하기 버튼이다. submit은 서버로 전송하는 버튼으로 form태그에서 지정한 폼 처리 프로그램에 넘겨진다.</p><ul><li>type=”image”</li></ul><p>submit버튼 대신 전송 이미지를 넣을 수 있다.</p><ul><li>type=”button”</li></ul><p>폼 안에 버튼 형태를 만들 수 있다. 스크립트 함수를 넣어서 사용하여야 한다.</p><ul><li>type=”file”</li></ul><p>파일을 첨부할 수 있다.</p><h2 id="Input-태그-속성들"><a href="#Input-태그-속성들" class="headerlink" title="Input 태그 속성들"></a>Input 태그 속성들</h2><ul><li>autofocus</li></ul><p>원하는 요소에 입력 커서를 표시할 수 있다.</p><ul><li>placeholder</li></ul><p>텍스트를 입력할 때 힌트를 표시할 수 있다. 필드안에 그 속성에 어떠한 값을 입력해야 하는 지 알려줄 수 있다.</p><ul><li>readonly</li></ul><p>읽게만 만드는 창을 만들 때 사용하는 속성이다. true, false값을 지정해도 되고 readonly=”readonly”라고 적어도 된다.</p><ul><li>required 속성</li></ul><p>필수적으로 입력하여야 하는 곳에 사용한다.</p><ul><li>min,max,step 속성</li></ul><p>최솟값, 최대값, 허용 범위를 설정한다.</p><ul><li>size,minlength,maxlength</li></ul><p>텍스트 길이, 최솟값, 최대값을 설정한다.</p><h2 id="실습-상품-주문서-만들기"><a href="#실습-상품-주문서-만들기" class="headerlink" title="실습(상품 주문서 만들기)"></a>실습(상품 주문서 만들기)</h2><ul><li>이 예제는 Do it! HTML5 + CSS3 웹 표준의 정석 책을 참고하였습니다.</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/05pk3vqj/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;태그&quot;&gt;&lt;a href=&quot;#태그&quot; class=&quot;headerlink&quot; title=&quot; 태그&quot;&gt;&lt;/a&gt;&lt;input&gt; 태그&lt;/h1&gt;&lt;h2 id=&quot;Input-태그란&quot;&gt;&lt;a href=&quot;#Input-태그란&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="HTML" scheme="http://rootjang92.github.io/categories/HTML-CSS/HTML/"/>
    
    
      <category term="html, html input" scheme="http://rootjang92.github.io/tags/html-html-input/"/>
    
  </entry>
  
  <entry>
    <title>함수의 this</title>
    <link href="http://rootjang92.github.io/2018/09/10/jsfuncthis/"/>
    <id>http://rootjang92.github.io/2018/09/10/jsfuncthis/</id>
    <published>2018-09-10T05:15:07.000Z</published>
    <updated>2018-09-10T06:29:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><h2 id="this-1"><a href="#this-1" class="headerlink" title="this"></a>this</h2><ul><li>arguments 객체<br>자바스크립트는 인자의 갯수를 달리해도 오류가 발생하지 않는다. 넘겨지지 않은 인자는 undefined, 갯수가 많을 경우에는 무시된다.<br>이렇기 때문에 런타임 시 인자의 갯수를 확인하여 동작을 다르게 해줘야 하는데 이를 가능하게 하는 것이 arguments 객체이다.</li></ul><pre><code>function add(a,b) {  console.dir(arguments);  return a+b;}console.log(add(1));console.log(add(1,2));VM156:2Arguments(1)0: 1 callee: ƒ add(a,b) length: 1 Symbol(Symbol.iterator): ƒ values()__proto__: ObjectVM156:6 NaNVM156:2 Arguments(2)VM156:7 3</code></pre><p>arguments는 유사 배열 객체이기 때문에 length를 가지고 있다. 이를 활용한 함수를 구현하자면…</p><ul><li><p>예시<br>ㅡ</p><p>  function sum() {</p><pre><code>var res = 0;for(var i = 0; i &lt; arguments.length; i++) {  res += arguments[i];}return res;</code></pre><p>  }</p><p>  console.log(sum(1));<br>  console.log(sum(1,2,3,4,5,6,7,8,9));</p></li></ul><p>출력결과</p><blockquote><p>1<br>45</p></blockquote><h2 id="this-바인딩"><a href="#this-바인딩" class="headerlink" title="this 바인딩"></a>this 바인딩</h2><p>자바스크립트의 this는 타 언어와 달리 함수 호출 패턴에 따라 this가 참조하는 객체가 달라진다. (후…)</p><ul><li>객체 메서드 호출 시 this</li></ul><p>이 떄에는 <strong>해당 메서드를 호출한 객체</strong>로 바인딩 된다.</p><pre><code>var myObj = {  name: &apos;Jang&apos;,  sayName: function() {    console.log(this.name);  }};var Obj = {  name: &apos;Geun&apos;};Obj.sayName = myObj.sayName;myObj.sayName(); // 1Obj.sayName(); // 2</code></pre><p>출력결과</p><blockquote><p>Jang<br>Geun</p></blockquote><p>우리는 sayName()이 호출되는 지점을 봐야 한다. 이 메서드의 this는 자신을 호출한 객체로 바뀌기 때문에 1에서는 Jang이 2에서는 Geun이 출력되는 것이다.</p><ul><li>함수를 호출할 때 this</li></ul><p>이 때의 <strong>this는 전역 객체</strong>에 바인딩 된다. (브라우저의 경우 window 객체, 런타임 환경의 경우 global)</p><pre><code>var test = &apos;test&apos;;console.log(window.test);var sayBar = function() {  console.log(this.test);};sayBar();</code></pre><p>출력결과</p><blockquote><p>test<br>test</p></blockquote><p>test 변수는 전역 변수이기 때문에 window로 접근이 가능하다. 또한 sayBar 함수에서 this는 전역을 가리키기 때문에 window에 바인딩되어 test가 호출된다.</p><pre><code>var num = 100;var myObj = {  num: 1,  func1: function() {    this.num += 1;    console.log(&apos;func1() called. this.num : &apos; + this.num);    // func2    func2 = function() {      this.num += 1;      console.log(&apos;func2() called. this.num : &apos; + this.num);    }    func2();  }};myObj.func1();</code></pre><p>출력결과</p><blockquote><p>func1() called. this.num : 2<br>func2() called. this.num : 101</p></blockquote><p>우리가 생각했던 방식은 부모 요소의 객체와 같은 거라고 예상했기에 2,3이 떠야 하지만 결과는 2와 101이 떴다. 그 이유는 내부 함수의 호출 패턴을 지정하지 않았기 때문이다. 내부 함수의 this는 전역 객체에 바인딩되기 때문에 부모 함수의 this를 다른 변수에 저장해야 한다.</p><pre><code>var num = 100;var myObj = {  num: 1,  func1: function() {    var that = this;    this.num += 1;    console.log(&apos;func1() called. this.num : &apos; + that.num);    // func2    func2 = function() {      that.num += 1;      console.log(&apos;func2() called. this.num : &apos; + that.num);    }    func2();  }};myObj.func1();</code></pre><p>출력결과</p><blockquote><p>func1() called. this.num : 2<br>func2() called. this.num : 3</p></blockquote><p>this를 that 변수에 저장하여 내부함수가 부모 함수의 변수에 접근이 가능하게 만들었다.</p><ul><li>생성자 함수 호출 시 this</li></ul><p>복습하자면 생성자 함수는 기존 함수에 new 연산자를 붙이는 방법이다. 또한 함수 이름 첫 글자를 대문자로 쓰기를 권한다. 많은 책이나 블로그에서 중요하게 여기는 것이 생성자 함수의 this바인딩을 이해하기 위해선 생성자 함수의 동작 방식을 이해해야 한다고 설명하고 있다.</p><ol><li><p>빈 객체 생성 및 this 바인딩<br>이 빈 객체가 this로 바인딩 된다. 단 이 생성자 함수가 생성한 객체는 생성자 함수 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체로 설정한다.</p></li><li><p>this를 통해 프로퍼티 생성<br>this를 사용해서 생성된 빈 객체에 동적으로 프로퍼티나 메서드를 생성할 수 있다.</p></li><li><p>생성된 객체 리턴<br>일반적으로는 this에 바인딩된 새롭게 생성된 객체가 리턴된다.(일반 함수에서는 undefined) 그러나 다른 객체를 반환한다면 해당 객체가 리턴된다.</p></li></ol><pre><code>var Person = function (name) {  this.name = name;};var foo = new Person(&apos;Jang&apos;);console.log(foo.name);</code></pre><p>출력 결과</p><blockquote><p>Jang</p></blockquote><p>Person() 생성자 함수가 빈 객체를 생성하며 Person.prototype을 [[prototype]]링크로 연결하여 자신의 프로토타입으로 설정한다.<br>그러면서 this에 name이라는 동적 프로퍼티를 생성하여 리턴을 받환하여 foo 변수에 저장한다.</p><ul><li>객체 리터럴 방식과 생성자 함수의 차이점.</li></ul><p>둘의 가장 큰 차이점은 바로 프로토타입 객체다. 객체 리터럴은 Object(), 생성자 함수는 생성자함수 이름이 프로토타입 객체가 된다.<br>그 이유는 둘의 생성자가 다르기 때문이다. 객체 리터럴의 경우 생성자가 Object()이기 때문이다.</p><ul><li>call과 apply 메서드를 사용한 this</li></ul><p>이 방법은 명시적으로 this를 바인딩시키는 방법이다. 단 이 메서드들은 Function.prototype 객체의 메서드이다.</p><p>function.apply(thisArg, argArray)</p><p>주의할 점은 결국 apply() 메서드를 호출하는 것은 함수이고, 본질적인 기능이 함수 호출이라는 점이다. 첫번째 인자는 this에 바인딩할 객체를 가리키고 두 번째 인자는 함수를 호출할 때 넘길 인자들의 배열을 가리킨다.</p><pre><code>function Person(name, age, gender) {  this.name = name;  this.age = age;  this.gender = gender;}var foo = {};Person.apply(foo,[&apos;Jang&apos;, 27, &apos;man&apos;]);console.dir(foo);</code></pre><blockquote><p>Object age: 27 gender: “man” name: “Jang” <strong>proto</strong>: Object</p></blockquote><p>결론적으로 이 코드는 Person(‘Jang’,27,’man’) 함수를 호출하여 this를 foo 객체에 명시적으로 바인딩한 것이다.</p><p>이들을 활용하는 것의 장점은 유사 배열 객체에 배열 메서드를 사용하는 경우에 나타난다.</p><pre><code>function myFunction() {  console.dir(arguments);  // arguments.shift(); -&gt; error  var arg = Array.prototype.slice.apply(arguments);  // Array.prototype.slice() 메서드를 호출하고 this는 arguments객체에 할당해라.  console.dir(arg);}myFunction(1,2,3);</code></pre><p>출력결과</p><blockquote><p>[Arguments] { ‘0’: 1, ‘1’: 2, ‘2’: 3 }<br>[ 1, 2, 3 ]</p></blockquote><h2 id="함수-리턴"><a href="#함수-리턴" class="headerlink" title="함수 리턴"></a>함수 리턴</h2><p>함수는 항상 리턴값을 반환한다. 라는게 포인트이다. 만약 리턴문이 없다면 undefined값이 리턴된다.</p><ul><li>생성자 함수에서 리턴값을 지정하지 않으면 생성된 객체가 리턴된다.</li></ul><p>생성자 함수에서 별도의 리턴값을 지정하지 않으면 this에 바인딩된 객체가 리턴되기 때문에 일반적으로 리턴문을 사용하지 않는다.<br>만약 명시적으로 리턴값을 지정한다면 객체 외에 경우에는 리턴값을 무시하지만 객체를 지정할 경우 그 객체가 반환된다.</p><p>다음 시간에는 프로토타입 체이닝에 대해서 알아보겠습니다~!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;this&lt;/h1&gt;&lt;h2 id=&quot;this-1&quot;&gt;&lt;a href=&quot;#this-1&quot; class=&quot;headerlink&quot; title=&quot;this&quot;
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="Javascript, js, js this, this, prototype chain" scheme="http://rootjang92.github.io/tags/Javascript-js-js-this-this-prototype-chain/"/>
    
  </entry>
  
  <entry>
    <title>자바스크립트의 함수</title>
    <link href="http://rootjang92.github.io/2018/09/09/jsfunction/"/>
    <id>http://rootjang92.github.io/2018/09/09/jsfunction/</id>
    <published>2018-09-09T06:52:11.000Z</published>
    <updated>2018-09-10T05:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="함수란"><a href="#함수란" class="headerlink" title="함수란?"></a>함수란?</h1><h2 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h2><p>자바스크립트에서 가장 중요한 것이 무엇이냐고 했을 때 십중팔구는 <strong>함수</strong>를 이야기 할 것이다. 자바스크립트의 함수는 모듈화, 클로져, 객체 생성, 함수형 프로그래밍 지향에 있어서 정말 중요한 개념이고 잘 이해하여야 한다.(그런 의미에서 나는 아직 멀었다.)</p><h3 id="함수의-생성방법"><a href="#함수의-생성방법" class="headerlink" title="함수의 생성방법"></a>함수의 생성방법</h3><p>함수 생성방법은 객체 생성방법과 비슷하게 3가지가 있다. 함수 선언문, 함수 표현식, Function() 생성자 함수 이 세가지 이다.</p><ul><li>함수 리터럴</li></ul><p>계속 강조하지만 함수도 결국 객체이다.(일급 객체라서 중요하다!) 그렇기 때문에 함수 리터럴 방식이 존재한다.</p><pre><code>function multiply(x,y) {  return x * y;}</code></pre><p>함수 키워드, 함수 명, 매개변수 리스트로 구성되어 있다.</p><ul><li>함수 선언문</li></ul><p>함수 리터럴과 형태는 같지만 주의할 점은 <strong>반드시 함수명이 있어야 한다는 점이다.</strong></p><pre><code>function multiply(x,y) {  return x * y;}console.log(multiply(3,4));</code></pre><p>출력결과</p><blockquote><p>12</p></blockquote><ul><li>함수 표현식</li></ul><p>함수 표현식은 함수 리터럴로 함수를 생성하여 생성된 함수를 변수에 할당하는 형태이다.</p><pre><code>var mul = function (x,y) {  return x * y;}console.log(mul(3,4));</code></pre><p>출력결과</p><blockquote><p>12</p></blockquote><p>이렇게 이름이 없는 함수 형태를 익명함수라고 부른다. 즉 변수 mul을 통해 함수를 할당한 것을 익명 함수를 이용한 함수 표현식이라고 한다.<br>위 예제는 기명 함수 표현식으로도 가능하다. 다만 함수 표현식에서 사용된 함수 이름은 <strong>외부 코드에서의 참조</strong>가 불가능하다.</p><p>이를 활용해서 팩토리얼 함수를 만들어 보도록 하자.</p><pre><code>var factorial = function factorial(n) {  if ( n &lt;= 1) { return 1; }  return n * factorial(n-1);}console.log(factorial(3));console.log(factorial(1));</code></pre><p>출력결과</p><blockquote><p>6<br>1</p></blockquote><p>이는 재귀 호출을 이용한 방법으로 함수를 선언한 후 함수 내부에서 재귀호출하여 함수를 처리하였다.</p><ul><li>Function() 생성자 함수</li></ul><p>자바스크립트의 함수도 결국 Function()이라는 내장 생성 함수에서 생성된 것이다. (축약 표현일 뿐이다.)</p><pre><code>var add = new Function(&apos;x&apos;, &apos;y&apos;, &apos;return x + y&apos;);console.log(add(3,4));</code></pre><p>출력결과</p><blockquote><p>7</p></blockquote><h3 id="함수-호이스팅"><a href="#함수-호이스팅" class="headerlink" title="함수 호이스팅"></a>함수 호이스팅</h3><p>자바스크립트의 권위자 인 더글라스 크락포드는 함수 생성에서 함수 표현식만을 사용할 것을 권하고 있는 데 그 이유가 바로 호이스팅 때문이다.</p><pre><code>// 함수 호이스팅으로 인한 호출 가능.var res = square(5);function square(number) {  return number * number;}// TypeErrorvar res = square(5);var square = function(number) {  return number * number;}</code></pre><p>함수 표현식은 <strong>변수 호이스팅</strong>이 발생하기 때문에 함수 호이스팅 처럼 변수생성, 초기화, 할당이 한 번에 일어나는 것이 아니라 변수 호이스팅 처럼 생성과 초기화만 동시에 일어난다.<br>결론적으로 <strong>함수 호출 전에는 반드시 함수를 선언하여야 한다.</strong></p><h2 id="함수-객체"><a href="#함수-객체" class="headerlink" title="함수 = 객체"></a>함수 = 객체</h2><p>자바스크립트의 함수는 결국 <strong>객체</strong>이기 떄문에 일반 객체처럼 프로퍼티들을 가질 수 있다. 그렇기 때문에 위에서 설명한 것처럼 리터럴에 의한 생성, 변수나 배열 요소, 객체 프로퍼티 할당 가능, 함수의 인자로 전달 가능, 함수의 리털값으로 사용 가능, 동적으로 프로퍼티 생성 및 할당 가능 등 객체와 똑같이 적용된다.</p><p>위에 나열한 기능이 모두 가능하기 때문에 함수를 <strong>일급 객체</strong>라고 부르는 것이다.</p><ul><li>변수나 프로퍼티에 할당.</li></ul><p>함수도 변수나 프로퍼티에 할당할 수 있다.</p><pre><code>var foo = 100;var bar = function() { return 100; };console.log(bar());var obj = {};obj.baz = function () { return 200; };console.log(obj.baz());</code></pre><p>출력결과</p><blockquote><p>100<br>200</p></blockquote><ul><li>함수 인자로 전달.</li></ul><p>다른 함수의 인자로 전달 가능하다.</p><pre><code>var foo = function(func) {  func();};foo(function() {  console.log(&apos;kkk&apos;);});</code></pre><p>출력결과</p><blockquote><p>kkk</p></blockquote><ul><li>리턴값으로 활용</li></ul><p>다른 함수의 리턴값으로도 활용할 수 있다.</p><pre><code>var a = function() {  return function() {    console.log(&apos;apple&apos;)  };};var b = a();b();</code></pre><p>출력결과</p><blockquote><p>apple</p></blockquote><p>변수 b에 함수 a를 호출하면 리턴값으로 전달되는 함수가 b 변수에 저장되어 apple이 출력된다.</p><ul><li>기본 프로퍼티</li></ul><p>정말 중요하다. <strong>함수는 객체다.</strong> (일급객체) 또한 함수 객체만의 프로퍼티를 가지고 있다. 크롬 검사도구에서 함수를 살펴보면 arguments,caller, length 등과 같은 프로퍼티가 보인다는 것을 알 수 있다. (console.dir로 호출해 보시길)<br>또한 객체이기 때문에 prototype을 갖는다. 함수 객체의 프로토타입은 <strong>Function.prototype</strong> 객체이다.</p><ul><li>prototype과 [[prototype]]</li></ul><p>이 둘은 많이 헷갈릴 수 있는 개념이다. 하지만 둘은 엄연히 다른 개념이다. 물론 두 프로퍼티가 모두 프로토타입 객체를 가리킨다. 하지만 <strong>보는 관점</strong>에서 차이가 있다.</p><ol><li><p>[[prototype]]<br>객체 입장에서 자신의 부모 역할을 수행하는 프로토타입 객체를 가리킨다.</p></li><li><p>prototype<br>함수가 생성자일 때 <strong>함수를 통해 생성된 객체의 부모 역할을 하는 개체</strong>를 가리킨다. 그래서 함수를 생성할 때 만들어지고 constructor 프로퍼티 하나만 있는 객체를 말한다.</p></li></ol><p><img src="https://poiemaweb.com/img/object_literal_prototype_chaining.png" alt="프로토타입"></p><h2 id="함수-형태"><a href="#함수-형태" class="headerlink" title="함수 형태"></a>함수 형태</h2><ul><li>콜백 함수<br>익명 함수가 사용되는 대표적인 용도가 콜백함수이다. 콜백 함수는 어떤 이벤트가 발생했을 때 시스템에서 호출되는 함수이다.<br>대표적인 예로 이벤트 핸들러 처리가 있다.</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/7drpbwmL/embedded/js,html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li><p>즉시 실행 함수<br>Immediate function은 정의와 동시에 출력되는 함수이다.</p><p>  (function (name) {</p><pre><code>console.log(&apos;welcome -&gt; &apos; + name);</code></pre><p>  })(‘Jang’);</p></li></ul><p>출력결과</p><blockquote><p>welcome -&gt; Jang</p></blockquote><p>즉시시행함수는 바로 시행되지만 다시 호출할 수 없기 때문에 한 번만 실행하는 초기화 실행 같은 코드에 적합하다.<br>(추후에 즉시실행함수에 대해 한 번 다뤄보도록 하겠습니다.)</p><ul><li><p>내부 함수<br>자바스크립트 함수는 내부에서도 함수를 정의할 수 있다. 이를 내부함수라고 한다.</p><p>  function parent() {</p><pre><code>var a = 100;var b = 200;function child() {  var b = 300;  console.log(a);  console.log(b);}child();</code></pre><p>  }<br>  parent();<br>  child();</p></li></ul><p>출력결과</p><blockquote><p>100<br>300<br>ReferenceError: child is not defined</p></blockquote><p>100이 출력되는 이유는 스코프 체이닝에 의해서 child함수의 부모인 parent 함수에서 변수 a의 값을 찾았기 때문에 가능한 것이다.<br>또한 내부 함수는 자신을 둘러싼 외부 함수에서 접근이 가능하지만 그 내부에서만 호출이 가능하기 때문에 레퍼런스 에러가 발생했다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;함수란&quot;&gt;&lt;a href=&quot;#함수란&quot; class=&quot;headerlink&quot; title=&quot;함수란?&quot;&gt;&lt;/a&gt;함수란?&lt;/h1&gt;&lt;h2 id=&quot;함수&quot;&gt;&lt;a href=&quot;#함수&quot; class=&quot;headerlink&quot; title=&quot;함수&quot;&gt;&lt;/a&gt;함수&lt;/h2&gt;
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="js, javascript, javascript function, 자바스크립트 함수" scheme="http://rootjang92.github.io/tags/js-javascript-javascript-function-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%95%A8%EC%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Form 태그에 대하여</title>
    <link href="http://rootjang92.github.io/2018/09/09/htmlform/"/>
    <id>http://rootjang92.github.io/2018/09/09/htmlform/</id>
    <published>2018-09-09T06:15:24.000Z</published>
    <updated>2018-09-09T06:51:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML-폼-태그에-대하여"><a href="#HTML-폼-태그에-대하여" class="headerlink" title="HTML 폼 태그에 대하여"></a>HTML 폼 태그에 대하여</h1><p>폼 태그란 특정 형식에 사용자가 무언가를 입력하는 형태로 이루어져 있다. 로그인이나 회원가입 창이 그 예이다.<br>웬만한 페이지에서는 형식에 구해받지 않고 이런 폼 태그를 볼 수 있다. 우리가 많이 사용하는 SNS에서도 회원가입을 하기 위해서 입력하는 정보들도 폼이다.</p><p>로그인을 예로 들면 우리가 클라리언트에서 정보를 입력하여 서버로 보내면 그 서버에서 DB를 확인하여 다시 보내주는 형태로 반응한다. 그 방법에는 여러가지가 있는데 흔히 ASP, PHP, JSP등을 사용할 수도 있고 최근 라이브러리나 프레임워크를 사용하면서 axios나 rxjs등의 여러가지 형태로도 가능하다.</p><h2 id="폼태그"><a href="#폼태그" class="headerlink" title="폼태그"></a>폼태그</h2><pre><code>&lt;form [속성=&quot;속성값&quot;]&gt;&lt;/form&gt;</code></pre><p>폼 택의 기본적인 형태는 이렇다. 하지만 그 속성은 정말 다양하게 존재한다.</p><ul><li><p>method<br>서버 쪽에 넘겨줄 <strong>방법</strong>을 지정하는 속성이다. 보통 get, post를 사용하는 데 get은 url자체에 담아서 넘겨줘 데이터 용량에 제한이 있지만 우리가 보통 사용하는 post 방식은 표준 입력으로 제한이 없고 정보가 노출되지 않는다.</p></li><li><p>name<br>폼의 이름을 지정한다.</p></li><li><p>action<br>서버 상의 프로그램을 지정한다.</p></li><li><p>target<br>스크립트 파일을 현재창에 띄울 지 다른 위치에서 열지 지정한다.</p></li><li><p>autocomplete<br>자동완성 속성이다. 우리가 검색창에서 어떤 검색어를 입력할 때 자동완성 되는 경험을 해본 적이 있을 것이다. 기본값은 on으로 지정되어 있다.</p></li></ul><h2 id="label-태그"><a href="#label-태그" class="headerlink" title="label 태그"></a>label 태그</h2><pre><code>&lt;label [속성=&quot;속성값&quot;]&gt;&lt;/label&gt;</code></pre><p>label 태그는 폼 요소에 레이블을 붙이기 위한 태그이다. 직접 텍스트를 입력할 수도 있고 for 속성을 사용하여 지정할 수도 있다. 또한 라벨 태그를 input 태그에 checkbox나 radio 버튼과 연결하면 텍스트를 클릭해도 항목이 클릭되게 만들 수도 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/zx4heatq/2/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="fieldset과-legend-태그"><a href="#fieldset과-legend-태그" class="headerlink" title="fieldset과 legend 태그"></a>fieldset과 legend 태그</h2><p>이 두 태그는 폼 요소를 그룹으로 묶을 때 사용한다. 이 태그를 사용하면 하나의 그룹으로 묶고 외곽선을 그려준다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/nwxmroj0/5/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="input-태그"><a href="#input-태그" class="headerlink" title="input 태그"></a>input 태그</h2><p>쉽게 말해서 우리가 입력할 수 있는 <strong>텍스트 상자</strong>나 <strong>로그인 버튼</strong> 등을 만들어 내는 태그가 바로 input 태그이다.</p><pre><code>&lt;input type=&quot;유형&quot; [속성=&quot;속성값&quot;]&gt;</code></pre><p>위 예제에서 봤듯이 input태그에서 id 속성을 사용하면 label 태그를 통해 속성을 붙이기도 하고 css에서도 사용할 수 있다.</p><a href="http://aboooks.tistory.com/294" target="_blank" rel="noopener">input태그 속성</a><p>다음 시간에는 input 태그의 사용법에 대해서 예제와 함께 살펴보도록 하겠습니다. (찡긋)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTML-폼-태그에-대하여&quot;&gt;&lt;a href=&quot;#HTML-폼-태그에-대하여&quot; class=&quot;headerlink&quot; title=&quot;HTML 폼 태그에 대하여&quot;&gt;&lt;/a&gt;HTML 폼 태그에 대하여&lt;/h1&gt;&lt;p&gt;폼 태그란 특정 형식에 사용자가 무언가를
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="HTML" scheme="http://rootjang92.github.io/categories/HTML-CSS/HTML/"/>
    
    
      <category term="HTML, html, html form, form tag" scheme="http://rootjang92.github.io/tags/HTML-html-html-form-form-tag/"/>
    
  </entry>
  
  <entry>
    <title>프로토타입과 배열 그리고 연산자</title>
    <link href="http://rootjang92.github.io/2018/09/05/jsprototype/"/>
    <id>http://rootjang92.github.io/2018/09/05/jsprototype/</id>
    <published>2018-09-05T07:27:24.000Z</published>
    <updated>2018-09-05T08:48:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="프로토타입"><a href="#프로토타입" class="headerlink" title="프로토타입"></a>프로토타입</h2><p>자바스크립트의 모든 객체는 자신의 부모 역할을 하는 객체와 연결되어 있다. 이를 통해 자바스크립트에서는 상속 개념을 구현할 수 있다. 이를 프로토타입 객체라고 한다.</p><pre><code>var foo = {  name: &apos;Jang&apos;,  age: 27};console.log(foo.toString());console.dir(foo);</code></pre><p>코드를 한 번 살펴보자. 사실상 1번 콘솔로그에서 toString이라는 메서드가 없어 오류가 발생해야 하지만 정상적으로 작동한다.<br>즉, foo 객체의 부모 역할을 하는 프로토타입에 toString() 메서드가 이미 정의되어 있기 때문에 호출이 가능한 것이다.</p><p>출력결과</p><blockquote><p>[object Object]<br>{ name: ‘Jang’, age: 27 }</p></blockquote><p>즉 모든 객체는 자신의 프로토타입을 가리키는 [[Prototype]]이라는 숨겨진 프로퍼티를 가진다. (크롬 브라우저의 <code>_proto_</code>)<br>여기서 foo 객체는 자신의 부모 객체를 <code>_proto_</code>라는 내부 프로퍼티로 연결하고 있다.<br>자세한 내용은 프로토타입 체이닝에서 더 다루겠지만, 결론적으로 객체 리터럴로 생성한 객체의 경우 Object.prototype 객체가 프로토타입 객체이다.</p><h2 id="배열"><a href="#배열" class="headerlink" title="배열"></a>배열</h2><ul><li><p>배열 리터럴<br>배열 리터럴은 ‘[]’를 사용해서 배열을 만든다.</p><p>  var colorArr = [‘orange’, ‘red’, ‘yellow’, ‘green’];<br>  console.log(colorArr[0]);<br>  console.log(colorArr[1]);</p></li></ul><p>출력결과</p><blockquote><p>orange<br>red</p></blockquote><p>배열은 인덱스 값으로 접근할 수 있다. 배열 내 인덱스는 0부터 시작한다. 즉 첫번째 값의 인덱스는 0인 것이다.</p><ul><li><p>배열 요소 생성<br>배열도 다른 객체와 마찬가지로 동적으로 배열 원소를 동적으로 추가할 수 있다.</p><p>  var empty = [];<br>  console.log(empty);</p><p>  empty[0] = 100;<br>  empty[3] = ‘four’;<br>  console.log(empty);<br>  console.log(empty.length);</p></li></ul><p>출력 결과</p><blockquote><p>[]<br>[ 100, undefined x 2, four ]<br>4</p></blockquote><p>자바스크립트의 배열은 인덱스 순서와 상관없이 할당이 가능하다. 값이 없다면 undefined가 뜬다.<br>또한 중요한 점은 <strong>자바스크립트가 배열의 크기를 배열 인덱스 중 가장 큰 값을 기준으로 정한다.</strong>는 것이다.<br>또한 length 프로퍼티를 이용하여 배열의 길이를 구할 수 있다. 배열의 길이 값은 가장 큰 인덱스에 +1을 한 값이다.(인덱스의 시작이 0 이기 때문이다.)</p><ul><li>length<br>길이값은 위에서 설명했지만, 중요한 것은 길이값을 명시적으로 변경할 수 있고 그 길이를 초과하는 값은 삭제된다는 점이다.<br>위 예제에서 empty의 length값은 4이지만 length값을 2로 설정하면,  100과 undefined를 제외한 뒤의 값은 삭제된다.</li></ul><ul><li>배열과 객체<br>배열과 객체는 모두 객체이지만 몇 가지 차이점이 있다. 우선 length 프로퍼티는 배열에만 존재한다. 두 번째로는 프로토타입의 차이이다.<br>일반 객체는 push와 같은 표준 배열 메서드를 사용할 수 없는데 둘의 프로토타입 체이닝에 의한 부모 프로토타입 객체가 서로 다르기 때문이다.</li></ul><blockquote><p>객체 - <code>_proto_</code> - Object.prototype<br>배열 - <code>_proto_</code> - Array.prototype - <code>_proto_</code> - Object.prototype</p></blockquote><h2 id="배열의-프로퍼티-열거"><a href="#배열의-프로퍼티-열거" class="headerlink" title="배열의 프로퍼티 열거"></a>배열의 프로퍼티 열거</h2><p>객체는 for in 문으로 객체를 열거할 수 있는데 배열은 for in문을 사용하면 불필요한 프로퍼티가 출력될 수 있으므로 for문을 사용하는 것이 좋다.</p><pre><code>var arr = [&apos;zero&apos;, &apos;one&apos;, &apos;two&apos;];console.log(arr.length);arr[3] = &apos;red&apos;;console.log(arr.length);for (var i = 0; i &lt; arr.length; i++) {  console.log(i, arr[i]);}</code></pre><p>출력 결과</p><blockquote><p>3<br>4<br>for문 결과값<br>0 ‘zero’<br>1 ‘one’<br>2 ‘two’<br>3 ‘red’</p></blockquote><h2 id="배열-요소-삭제"><a href="#배열-요소-삭제" class="headerlink" title="배열 요소 삭제"></a>배열 요소 삭제</h2><p>배열도 객체이므로 delete 연산자를 사용할 수 있지만, 이는 해당 요소를 undefined처리할 뿐이다. 그래서 배열에서는 splice()배열 메서드를 사용한다.</p><h2 id="splice-배열-메서드"><a href="#splice-배열-메서드" class="headerlink" title="splice() 배열 메서드"></a>splice() 배열 메서드</h2><p>splice(start, deleteCount, item…)</p><ul><li><p>start : 배열에서 시작 위치, deleteCount : 삭제할 요소의 수 item : 삭제할 위치에 추가할 요소<br>ㅡ</p><pre><code>var arr = [&apos;zero&apos;, &apos;one&apos;, &apos;two&apos;, &apos;three&apos;];arr.splice(2,1); // 1console.log(arr);console.log(arr.length);</code></pre></li></ul><p>즉 1의 의미는 arr배열의 2번째부터 1개 요소를 삭제하겠다는 의미이다. 즉 arr 요소에서 ‘two’가 삭제되는 것이다.</p><p>출력 결과</p><blockquote><p>[ ‘zero’, ‘one’, ‘three’ ]<br>3</p></blockquote><h2 id="Array-생성자-함수"><a href="#Array-생성자-함수" class="headerlink" title="Array() 생성자 함수"></a>Array() 생성자 함수</h2><p>배열은 배열 리터럴로 생성하지만 배열 리터럴도 결국 Array()생성자 함수로 배열을 생성하는 것을 단수화한 것이다.<br>생성자 함수로 배열을 생성할 때에는 new 연산자를 사용하여야 한다.</p><pre><code>var foo = new Array(3);console.log(foo);console.log(foo.length);var bar = new Array(1,2,3);console.log(bar);console.log(bar.length);</code></pre><p>호출할 때 인자가 1개이면 호출된 인자를 lenth로 갖는 빈 배열을 생성하고 그 외에는 호출된 인자를 요소로 같는다.</p><p>출력 결과</p><blockquote><p>[ undefined x 3]<br>3<br>[1,2,3]<br>3</p></blockquote><h2 id="유사-배열-객체"><a href="#유사-배열-객체" class="headerlink" title="유사 배열 객체"></a>유사 배열 객체</h2><p>length 프로퍼티는 배열의 동작에 있어서 정말 중요하다. 그런데 일반 객체에서도 length를 사용할 수 있는 경우가 있으니 이를 유사 배열객체라고 한다.</p><pre><code>var arr = [&apos;bar&apos;];var obj = { name: &apos;Jang&apos;, length : 1};arr.push(&apos;baz&apos;);console.log(arr);Array.prototype.push.apply(obj, [&apos;baz&apos;]);console.log(obj);</code></pre><p>원래의 경우라면 변수 obj에는 push()메서드를 사용할 수 없으나, apply() 메서드를 사용하면 객체라도 표준 배열 메서드를 사용할 수 있다.<br>후에 더 자세히 살펴볼 것이다. (call, apply 메서드)</p><p>출력 결과</p><blockquote><p>[ ‘bar’, ‘baz’ ]<br>{ ‘1’: ‘baz’, name: ‘Jang’, length: 2 }</p></blockquote><h2 id="기본-타입과-표준-메서드"><a href="#기본-타입과-표준-메서드" class="headerlink" title="기본 타입과 표준 메서드"></a>기본 타입과 표준 메서드</h2><p>기본 타입의 경우 어떻게 표준 메서드를 호출하는가? 자바스크립트에서는 기본값을 객체로 변화한 다음 각 타입의 표준 메서드를 불러온다.</p><h2 id="연산자"><a href="#연산자" class="headerlink" title="연산자"></a>연산자</h2><ul><li><ul><li>연산자</li></ul></li></ul><p>+연산자는 더하기 연산과 문자열 연결 연산을 수행한다. 두 연산자가 모두 숫자인 경우에는 더하기 연산을 실시한다.</p><ul><li>typeof 연산자</li></ul><p>피연산자의 타입을 문자열 형태로 리턴하는 연산자이다. 유의할 점은 null의 경우 object로 표시된다는 점(자바스크립트 개발단 오류)<br>함수는 function이라는 점에 유의하여야 한다.</p><ul><li>동등연산자와 일치연산자.</li></ul><p>동등연사자의 경우(==) 피연사자의 타입이 다를 경우 이를 변경하여 비교하고 일치연산자의 경우(===) 타입을 변경하지 않는다.</p><pre><code>console.log(1 == &apos;1&apos;) // trueconsole.log(1 === &apos;1&apos;) // false</code></pre><ul><li>!! 연산자</li></ul><p>!!연산자는 피연산자를 불리언값으로 변환한다. 값이 0이나 없다면 false, 그 외의 빈 객체, 배열, 문자열 등은 true로 표시된다.</p><p>다음 시간에는 <strong>함수와 프로토타입 체이닝</strong>에 대해서 알아보겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;프로토타입&quot;&gt;&lt;a href=&quot;#프로토타입&quot; class=&quot;headerlink&quot; title=&quot;프로토타입&quot;&gt;&lt;/a&gt;프로토타입&lt;/h2&gt;&lt;p&gt;자바스크립트의 모든 객체는 자신의 부모 역할을 하는 객체와 연결되어 있다. 이를 통해 자바스크립트에서는 
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="Javascript, js, es5, ES5, prototype, js prototype" scheme="http://rootjang92.github.io/tags/Javascript-js-es5-ES5-prototype-js-prototype/"/>
    
  </entry>
  
  <entry>
    <title>이미지와 하이퍼텍스트링크</title>
    <link href="http://rootjang92.github.io/2018/09/05/htmlimage/"/>
    <id>http://rootjang92.github.io/2018/09/05/htmlimage/</id>
    <published>2018-09-05T01:37:02.000Z</published>
    <updated>2018-09-05T07:26:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="이미지와-하이퍼텍스트-링크"><a href="#이미지와-하이퍼텍스트-링크" class="headerlink" title="이미지와 하이퍼텍스트 링크"></a>이미지와 하이퍼텍스트 링크</h1><h2 id="웹에서-사용되는-이미지-파일-형식은"><a href="#웹에서-사용되는-이미지-파일-형식은" class="headerlink" title="웹에서 사용되는 이미지 파일 형식은?"></a>웹에서 사용되는 이미지 파일 형식은?</h2><p>웹 페이지는 기본적으로 설명은 텍스트, 메뉴나 로고 등은 이미지로 처리 한다. 웹 페이지의 경우 크기가 작고 화질이 좋은 파일 형식을 사용하여야 하는데 웹에서 사용할 수 있는 파일 형식은 GIF, JPG/JPEG, PNG 파일이 있다.</p><a href="https://ko.wikipedia.org/wiki/%EC%9D%B4%EB%AF%B8%EC%A7%80_%ED%8C%8C%EC%9D%BC_%ED%98%95%EC%8B%9D" target="_blank" rel="noopener">이미지 파일 형식</a><h2 id="img-태그"><a href="#img-태그" class="headerlink" title="img 태그"></a>img 태그</h2><p>HTML에서 이미지를 삽입하는 태그는 <img> 태그이다. 이 때 src 속성을 사용하여 해당 이미지의 주소를 넣는다.</p><p><img src="./images/image.png" alt="img태그"></p><p>img 태그에는 src속성과 alt속성이 있는데 src는 해당 이미지의 주소, alt는 설명이 들어간다.<br>다시 돌아가 파일 경로에 대해 살펴보자. 내 컴퓨터에 있는 이미지를 사용한다면 그에 맞는 파일명, 다른 폴더에 있는 경우 하위 폴더와 함께 적어주면 된다. ‘/‘는 하위폴더를 나타낸다.(한단계 위는 ‘..’을 사용한다.)</p><p>웹 상의 이미지 또한 링크 주소를 받아 붙여넣을 수 있다. 해당 사이트가 닫히지 않는 이상 사용할 수 있다. 단 이 경우 저작권에 주의하여야 한다.</p><p>alt는 이미지를 설명하는 대체 텍스트를 달 때 사용하는 속성이다. 이를 사용할 경우 시각 장애인에게 화면 낭독기가 이미지를 설명해 줄 수 있다.</p><p>width, height 속성은 너비와 높이를 조정하는 속성이다.</p><h2 id="img의-기타-속성들"><a href="#img의-기타-속성들" class="headerlink" title="img의 기타 속성들"></a>img의 기타 속성들</h2><ul><li>figure, figcaption : 설명 속성 태그</li></ul><p>이미지에 설명을 함께 붙이고 싶을 때 사용하는 태그이다. figure태그는 설명 글을 붙일 대상을 지정합니다. 예를 들어 figure태그 안에 img태그와 figcaption태그를 넣게 되면 이미지 밑에 캡션이 달리게 됩니다.</p><h2 id="링크"><a href="#링크" class="headerlink" title="링크"></a>링크</h2><p>텍스트를 클릭하면 연결된 주소로 즉시 이동하게 하는 기능이 링크이다.</p><ul><li>a태그와 href 속성.</li></ul><p>사실상 링크에서 가장 중요한 두 요소이다. a태그를 이용하여 링크를 걸고 href 속성에 주소를 넣는다. 그 외에 속성으로는<br>target(링크한 내용이 표실될 위치, 현재 창 혹은 새 창), download(링크 다운로드), rel(관계 알리기), hreflang(링크한 문서 언어 설정), type(파일 유형)</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/2yv75k3u/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="SVG-이미지"><a href="#SVG-이미지" class="headerlink" title="SVG 이미지"></a>SVG 이미지</h2><p>최근 웹 브라우저에서 svg 파일을 지원하면서 아이콘이나 로고에 많이 사용되고 있다. 이미지를 확대, 축소해도 깨끗한 상태로 유지되는 것이 바로 벡터 이미지이고 그 확장자명이 svg이다.</p><p>다음 시간에는 폼 태그에 대해 다루겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;이미지와-하이퍼텍스트-링크&quot;&gt;&lt;a href=&quot;#이미지와-하이퍼텍스트-링크&quot; class=&quot;headerlink&quot; title=&quot;이미지와 하이퍼텍스트 링크&quot;&gt;&lt;/a&gt;이미지와 하이퍼텍스트 링크&lt;/h1&gt;&lt;h2 id=&quot;웹에서-사용되는-이미지-파일-형
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="HTML" scheme="http://rootjang92.github.io/categories/HTML-CSS/HTML/"/>
    
    
      <category term="HTML, html, HTML basic syntax, HTML hyperlink, html link" scheme="http://rootjang92.github.io/tags/HTML-html-HTML-basic-syntax-HTML-hyperlink-html-link/"/>
    
  </entry>
  
  <entry>
    <title>Object</title>
    <link href="http://rootjang92.github.io/2018/09/04/jsobject/"/>
    <id>http://rootjang92.github.io/2018/09/04/jsobject/</id>
    <published>2018-09-04T01:38:52.000Z</published>
    <updated>2018-09-05T01:36:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="객체-프로퍼티와-참조-그리고-프로토타입"><a href="#객체-프로퍼티와-참조-그리고-프로토타입" class="headerlink" title="객체 프로퍼티와 참조 그리고 프로토타입"></a>객체 프로퍼티와 참조 그리고 프로토타입</h1><h2 id="객체-프로퍼티-읽기와-쓰기-그리고-갱신"><a href="#객체-프로퍼티-읽기와-쓰기-그리고-갱신" class="headerlink" title="객체 프로퍼티 읽기와 쓰기 그리고 갱신"></a>객체 프로퍼티 읽기와 쓰기 그리고 갱신</h2><p>우선 프로퍼티에 접근하는 방법을 알아야 하는데 그 방법에는 대괄호 표기법과 마침표 표기법 두가지가 있다.</p><h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><pre><code>var foo = {  name : &apos;Jang&apos;,  major : &apos;Computer science&apos;};// 객체 프로퍼티 읽기console.log(foo.name);console.log(foo[&apos;name&apos;]);console.log(foo.nickname);foo.major = &apos;electronics Business&apos;;console.log(foo.major);console.log(foo[&apos;major&apos;]);foo.age = 27;console.log(foo.age);foo[&apos;full-name&apos;] = &apos;Jang Geun-ho&apos;;console.log(foo[&apos;full-name&apos;]);console.log(foo.full);</code></pre><p>출력 결과</p><blockquote><p>Jang<br>Jang<br>undefined<br>electronics Business<br>electronics Business<br>27<br>Jang Geun-ho<br>undefined</p></blockquote><p>마침표 표기법은 객체 다음에 마침표를 찍고 원하는 속성값을 적으면 된다. 대괄호 표기법은 객체의 프로퍼티를 문자열 형태로 만들어 대괄호 안에 넣으면 된다. 만약 문자화하지 않으면 값은 undefined가 나타난다.</p><p>또한 대괊호 표기법을 이용하여 기존 프로퍼티값을 갱신할 수 있다. 예제에서 살펴봤던 foo[‘major’]의 형태처럼 말이다.<br>JS의 특징 중 하나가 프로퍼티의 동적 생성인데 보시다시피 foo.age라는 프로퍼티는 아직 존재하지 않지만 이걸 동적으로 생성하여 27이라는 숫자값을 할당해준다.</p><p><strong>즉 기존에 있는 값은 갱신되고 없는 프로퍼터의 경우 동적 생성된 후 값이 할당된다는 의미이다.</strong></p><p>주의할 점은 연산자가 포함되있는 경우라면 <strong>대괄호 표기법</strong>을 사용하여야 한다는 것이다.<br>또한 객체 프로퍼티는 delete 연산자를 이용해 삭제할 수 있다. 단 delete 연산자는 프로퍼티만 삭제한다.</p><h3 id="예제2"><a href="#예제2" class="headerlink" title="예제2"></a>예제2</h3><pre><code>var foo = {  name : &apos;Jang&apos;,  major : &apos;Computer science&apos;};var prop;for (prop in foo) {  console.log(prop, foo[prop]);}</code></pre><p>출력결과</p><blockquote><p>name Jang<br>major Computer science</p></blockquote><p>for in 문을 이용해서 foo라는 개체에 루프를 돌렸다. prop 변수에 foo 객체의 프로퍼티가 하나씩 할당되면서 대괄호 표기법을 사용해 모든 요소가 출력된다.</p><h2 id="참조-타입의-특성"><a href="#참조-타입의-특성" class="headerlink" title="참조 타입의 특성"></a>참조 타입의 특성</h2><p>객체는 JS에서 참조 타입이라고 부른다. 객체의 연산은 참조값으로 처리가 되기 때문이다.</p><pre><code>var A = {  val : 40};var B = Aconsole.log(A.val);console.log(B.val);B.val = 50;console.log(A.val);console.log(B.val);</code></pre><p>A, B두 객체를 객체 리터럴 방식으로 생성해 보았다. 이 때 각 콘솔 로그의 값은 어떻게 찍힐까?</p><p>출력 결과</p><blockquote><p>40<br>40<br>50<br>50</p></blockquote><p>변수 A와 B는 동일한 객체를 가리키는 참조값을 가지기 때문에 B의 val 값을 50으로 변경하면 변수 A의 값도 변한다.<br>즉 <strong>A는 실제로 객체를 참조하는 값을 저장하는 것이지 실제 객체를 나타내지는 않는다</strong>는 점이다.<br><strong>A 객체는 참조 변수 A가 가리키는 객체!</strong></p><h2 id="객체-비교"><a href="#객체-비교" class="headerlink" title="객체 비교"></a>객체 비교</h2><p>JS에서의 동등 연산자(==)는 객체의 프로퍼티 값이 아니라 참조값을 비교한다.</p><pre><code>var a = 100;var b = 100;var objA = { value: 100 };var objB = { value: 100 };var objC = objBconsole.log(a == b);console.log(objA == objB);console.log(objB == objC);</code></pre><p>출력 결과를 예상해보자. 당연히 모두 true를 예상했겠지만(처음에는 저도…) 답은…</p><p>출력결과</p><blockquote><p>true<br>false<br>true</p></blockquote><p>변수 objA와 objB는 다른 참조값을 가진다. a,b처럼 기본 타입의 경우는 단순히 값을 비교하지만 객체의 경우 참조값을 비교하기 때문에 각각 다른 값을 참조하고 있는 두 변수는 동등 연산자를 사용했을 때 <strong>false</strong>가 나오는 것이다.</p><h2 id="함수-호출-방식"><a href="#함수-호출-방식" class="headerlink" title="함수 호출 방식."></a>함수 호출 방식.</h2><p>기본 타입과 참조 타입은 함수 호출 방식이 다르다.</p><ul><li><p>기본타입<br>call by value(값에 의한 호출) : 기본 타입의 값을 인자로 넘길 경우 호출된 함수의 매개변수로 <strong>복사된 값</strong>이 전달된다.<br>그렇기 때문에 함수 내 매개변수로 값을 변경해도 실제로 변수의 값은 변하지 않는다.</p></li><li><p>참조타입<br>call by reference(참조에 의한 호출) : 함수 호출 시 인자로 넘긴 객체의 참조값이 그대로 함수로 전달된다. 그렇기 때문에 함수 내부에서 참조값을 변경하면 실제 객체의 값도 변경된다.</p></li></ul><pre><code>var a = 100;var objA = { value: 100 };function changeArg(num, obj) {  num = 200;  obj.value = 200;  console.log(num);  console.log(obj);}changeArg(a, objA);console.log(a);console.log(objA);</code></pre><p>출력 결과</p><blockquote><p>200<br>{ value: 200 }<br>100<br>{ value: 200 }</p></blockquote><p>함수를 호출하면서 기본 타입인 변수 a의 값은 변화하지 않았지만, 객체 타입인 objA의 값은 변화하였다.</p><p><img src="https://poiemaweb.com/img/call-by-val&amp;ref.png" alt="value refer"></p><a href="https://poiemaweb.com/js-function" target="_blank" rel="noopener">참고자료</a><p>다음 시간에는 프로토타입과 배열에 대해 살펴보겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;객체-프로퍼티와-참조-그리고-프로토타입&quot;&gt;&lt;a href=&quot;#객체-프로퍼티와-참조-그리고-프로토타입&quot; class=&quot;headerlink&quot; title=&quot;객체 프로퍼티와 참조 그리고 프로토타입&quot;&gt;&lt;/a&gt;객체 프로퍼티와 참조 그리고 프로토타입&lt;/
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="Javascript, js, es5, ES5, object, js object" scheme="http://rootjang92.github.io/tags/Javascript-js-es5-ES5-object-js-object/"/>
    
  </entry>
  
  <entry>
    <title>목록을 생성하는 HTML 태그</title>
    <link href="http://rootjang92.github.io/2018/09/04/htmllist/"/>
    <id>http://rootjang92.github.io/2018/09/04/htmllist/</id>
    <published>2018-09-04T01:12:31.000Z</published>
    <updated>2018-09-04T08:14:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="목록을-생성하는-태그"><a href="#목록을-생성하는-태그" class="headerlink" title="목록을 생성하는 태그"></a>목록을 생성하는 태그</h1><p>HTML 문서를 작성할 때 많이 쓰이는 태그 중 하나가 바로 목록을 생성하는 태그다. 웹 표준이 정의화된 후에는 이미지나 텍스트에 구애받지 않고 어떤 것이든 목록화 시킬 수 있다. 특히 CSS를 적용한다면 메뉴나 본문 내용 등으로 사용할 수 있으니 table 태그가 거의 안쓰이는 이유가 되기도 했다.</p><h2 id="ul태그-li태그"><a href="#ul태그-li태그" class="headerlink" title="ul태그, li태그"></a>ul태그, li태그</h2><p>이 두 태그는 ‘순서 없는’ 목록을 만들 때 사용되는 태그이다. ul태그 안에 li태그를 사용하여 목록화 시킨다.</p><h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/ctfadnky/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="ol태그-li태그"><a href="#ol태그-li태그" class="headerlink" title="ol태그, li태그"></a>ol태그, li태그</h2><p>ol 태그는 순서가 필요한 목록을 만들 때 사용한다. ol은 타입을 지정할 수 있는데 1은 숫자를 나타내며 기본값으로 설정되어 있다.<br>그 외에 a(영소문자),A(영대문자),i(로마숫자 소문자),I(로마숫자 대문자)로 이루어져 있다. CSS로도 대체 가능하다.</p><h3 id="에제"><a href="#에제" class="headerlink" title="에제"></a>에제</h3><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/0y4vn2fj/1/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="dl-dt-dd-태그"><a href="#dl-dt-dd-태그" class="headerlink" title="dl,dt,dd 태그"></a>dl,dt,dd 태그</h2><p>자주 쓰이는 태그는 아니지만 설명 목록을 만들 때 주로 쓰이는 태그이다. 경험이 적어서 그런건진 몰라도 이 태그 쓰는 사이트를 본 기억이 드물다. 위키트리에서는 쓰일 수도 있겠다… 여튼 dl태그로 묶고 dt 태그에 제목을 dd 태그에 설명을 표시한다.</p><p>지금까지 배운 자료를 가지고 본인만의 간단한 프로필 웹 페이지를 만들어 보는 것도 좋을 것 같다.</p><h3 id="참고할-만한-사이트"><a href="#참고할-만한-사이트" class="headerlink" title="참고할 만한 사이트."></a>참고할 만한 사이트.</h3><p><a href="https://validator.w3.org/" target="_blank" rel="noopener">HTML 온라인 검사기</a></p><p>이 사이트는 파일을 업로드하면 자동으로 HTML 문서 상 오류가 있는 지 검사해주는 사이트다. 웹 페이지를 제작할 때 꽤 유용하다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;목록을-생성하는-태그&quot;&gt;&lt;a href=&quot;#목록을-생성하는-태그&quot; class=&quot;headerlink&quot; title=&quot;목록을 생성하는 태그&quot;&gt;&lt;/a&gt;목록을 생성하는 태그&lt;/h1&gt;&lt;p&gt;HTML 문서를 작성할 때 많이 쓰이는 태그 중 하나가 바로 
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="HTML" scheme="http://rootjang92.github.io/categories/HTML-CSS/HTML/"/>
    
    
      <category term="HTML, html, HTML basic syntax, htmltag, ul, li" scheme="http://rootjang92.github.io/tags/HTML-html-HTML-basic-syntax-htmltag-ul-li/"/>
    
  </entry>
  
  <entry>
    <title>자바스크립트 데이터 타입과 연산자.</title>
    <link href="http://rootjang92.github.io/2018/09/03/jsdatatype/"/>
    <id>http://rootjang92.github.io/2018/09/03/jsdatatype/</id>
    <published>2018-09-03T09:04:58.000Z</published>
    <updated>2018-09-04T08:05:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="자바스크립트-데이터-타입"><a href="#자바스크립트-데이터-타입" class="headerlink" title="자바스크립트 데이터 타입"></a>자바스크립트 데이터 타입</h3><p>자바스크립트의 데이터 타입에는 기본 타입과 참조 타입이 있다. 기본타입은 숫자, 문자열, boolean, undefined, null 값이 있고<br>참조형에는 객체(배열, 함수, 정규 표현식)이 있다.</p><h2 id="자바스크립트-기본-타입"><a href="#자바스크립트-기본-타입" class="headerlink" title="자바스크립트 기본 타입"></a>자바스크립트 기본 타입</h2><p>기본 타입에는 Nmber, String, Boolean, null, undefined가 있다.<br>이들 타입의 특징은 <strong>그 자체가 하나의 값</strong>을 나타낸다는 것이다. 자바스크립트는 느슨한 타입의 언어이기 때문에 변수를 선언할 때 타입을 미리 지정하지 않고 var(es5)라는 키워드로 변수를 선언하여 어떠한 값이라도 데이터를 저장할 수 있다.</p><pre><code>var intNum = 10;var floatNum = 0.1;var singleQuoteStr = &apos;single quote string&apos;;var boolVar = true;var emptyVar;var nullVar = null;console.log(typeof intNum, typeof floatNum, typeof singleQuoteStr, typeof boolVar,        typeof emptyVar, typeof nullVar);</code></pre><p>출력 결과</p><blockquote><p>number number string boolean undefined object</p></blockquote><h2 id="숫자"><a href="#숫자" class="headerlink" title="숫자"></a>숫자</h2><p>다른 언어와 달리 JS에서는 하나의 숫자형만 존재한다. (모든 숫자를 64비트 부동 소수점 형태로 저장한다.)<br>또한 모든 숫자를 실수로 처리하므로 나눗셈 연산에 주의하여야 한다.</p><pre><code>var num = 5 / 2;console.log(num);console.log(Math.floor(num));</code></pre><p>출력 결과</p><blockquote><p>2.5<br>2</p></blockquote><p>Math.floor 메서드는 정수 부분만 구하는 JS의 메서드이다.</p><h2 id="문자열"><a href="#문자열" class="headerlink" title="문자열"></a>문자열</h2><p>문자열은 작은 따옴표나 큰 따옴표를 이용해서 생성한다. 또한 JS의 문자열은 문자 배열처럼 인덱스를 이용할 수 있다. 또한 한 번 생선된 문자열은 수정이 불가능 하다.</p><pre><code>var str = &apos;easy&apos;;console.log(str[0], str[1], str[2], str[3]);str[0] = &apos;E&apos;;console.log(str);</code></pre><p>출력 결과</p><blockquote><p>e a s y<br>easy</p></blockquote><h2 id="boolean값"><a href="#boolean값" class="headerlink" title="boolean값"></a>boolean값</h2><p>JS에서 사용하는 true, false 값이다.</p><h2 id="null과-undefined"><a href="#null과-undefined" class="headerlink" title="null과 undefined"></a>null과 undefined</h2><p>두 타입 모두 ‘값이 비어 있다.’를 나타내기 위해 사용된다. <strong>값이 할당되지 않은</strong> 변수는 undefined이며 이는 변수 자체의 값이 undefined이다. (타입이자 값이다.) 여기 주의할 점은 null의 타입이 object라는 것인데 이 때문에 타입 변수인자를 확인할 때에는 일치 연산자를 사용하여야 한다. (===)</p><pre><code>var nullVar = null;console.log(typeof nullVar === null);console.log(nullVar === null);</code></pre><p>출력 결과</p><blockquote><p>false<br>true</p></blockquote><h2 id="JS-객체-타입"><a href="#JS-객체-타입" class="headerlink" title="JS 객체 타입"></a>JS 객체 타입</h2><p>JS에서 기본 타입을 제외한 모든 것은 객체이다. 배열, 함수, 정규표현식 들도 마찬가지이다. 객체는 단순히 이름(key):값(value)를 저장하는 형태이다. 기본 타입은 하나의 값마늘 가지는 데에 반해 겍체는 여러 개의 프로퍼티를 포함할 수 있다. 그래서 기본 타입을 포함하거나 다른 객체를 가리킬 수도 있다. 또한 프로퍼티의 성질에 따라 함수로 포함시킬 수도 있으며 이러한 프로퍼티를 <strong>메서드</strong>라고 부른다.</p><h2 id="JS-객체-생성-방법"><a href="#JS-객체-생성-방법" class="headerlink" title="JS 객체 생성 방법."></a>JS 객체 생성 방법.</h2><p>객체 생성 방법에는 3가지가 있다. 그 방법들에 대해 알아보자</p><h3 id="Object-생성자-함수"><a href="#Object-생성자-함수" class="headerlink" title="Object() 생성자 함수."></a>Object() 생성자 함수.</h3><p>JS에서는 객체를 생성할 때 내장 Object() 생성자 함수를 제공한다. 예제를 통해 살펴보자.</p><pre><code>var foo = new Object();// foo property make upfoo.name = &apos;Jang&apos;;foo.age = 27;foo.gender = &apos;male&apos;;console.log(typeof foo);console.log(foo);</code></pre><p>출력 결과</p><blockquote><p>object<br>{ name: ‘Jang’, age: 27, gender: ‘male’ }</p></blockquote><p>Object() 생성자 함수를 통해 객체를 생성하였고 그 타입은 object이고 변수 foo에 3가지 프로퍼티가 추가되었음을 알 수 있다.</p><h3 id="객체-리터럴-방식"><a href="#객체-리터럴-방식" class="headerlink" title="객체 리터럴 방식."></a>객체 리터럴 방식.</h3><p>리터럴이란 표기법을 의미한다. 즉 간단한 표기법으로 객체를 생성하는 방식이다.</p><pre><code>var foo = {  name : &apos;Jang&apos;,  age : 27,  gender : &apos;male&apos;};console.log(typeof foo);console.log(foo);</code></pre><p>출력 결과</p><blockquote><p>object<br>{ name: ‘Jang’, age: 27, gender: ‘male’ }</p></blockquote><h3 id="생성자-함수-이용"><a href="#생성자-함수-이용" class="headerlink" title="생성자 함수 이용."></a>생성자 함수 이용.</h3><p>객체를 함수를 통해서도 생성할 수 있다. 생성자 함수라고 하는데 다음에 더 자세히 다루도록 하겠다.</p><p>다음 시간에는 객체 프로퍼티 표기법과 참조타입의 특성에 대해 살펴보겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;자바스크립트-데이터-타입&quot;&gt;&lt;a href=&quot;#자바스크립트-데이터-타입&quot; class=&quot;headerlink&quot; title=&quot;자바스크립트 데이터 타입&quot;&gt;&lt;/a&gt;자바스크립트 데이터 타입&lt;/h3&gt;&lt;p&gt;자바스크립트의 데이터 타입에는 기본 타입과 참조
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="Javascript, js, es5, ES5, data, datatype" scheme="http://rootjang92.github.io/tags/Javascript-js-es5-ES5-data-datatype/"/>
    
  </entry>
  
  <entry>
    <title>HTML 텍스트 관련된 태그들</title>
    <link href="http://rootjang92.github.io/2018/09/03/htmltext/"/>
    <id>http://rootjang92.github.io/2018/09/03/htmltext/</id>
    <published>2018-09-03T08:02:35.000Z</published>
    <updated>2018-09-04T08:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML-텍스트-관련-태그들"><a href="#HTML-텍스트-관련-태그들" class="headerlink" title="HTML 텍스트 관련 태그들."></a>HTML 텍스트 관련 태그들.</h3><p>HTML 문서를 작성할 때 가장 많이 쓰이는 태그는 무엇일까?? 바로 텍스트 관련 태그들이다.<br>p, strong, table,em,ul,li 태그 등 꽤 많은 태그가 쓰이는 데 그 중에서 정말 자주 쓰이는 태그만 알아보자.araboza</p><h2 id="h-관련-태그"><a href="#h-관련-태그" class="headerlink" title="h 관련 태그"></a>h 관련 태그</h2><p>HTML 문서에서 제목을 붙이고 싶을 때는 h관련 태그(제목 텍스트)를 쓰면 된다. h 태그를 사용하면 글씨가 크고 굵어진다.<br>h1 ~ h6까지 사용 가능하다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/7dao64g5/10/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="p-태그"><a href="#p-태그" class="headerlink" title="p 태그"></a>p 태그</h2><p>쉽게 말하면 단락 만들기 태그이다. 단락은 앞뒤에 줄바꿈이 있는 덩어리를 말한다.</p><h2 id="br-태그"><a href="#br-태그" class="headerlink" title="br 태그"></a>br 태그</h2><p>줄바꿈 태그이다. 이 태그 없이 줄바꿈을 하더라도 줄이 바뀌지 않는다. (텍스트만 사용 시)</p><h2 id="hr-태그"><a href="#hr-태그" class="headerlink" title="hr 태그"></a>hr 태그</h2><p>수평줄을 삽입하는 태그이다. 보통 css로 만들기 때문에 딱히 쓰이진 않지만… 실습용으로</p><h2 id="blockquote-태그"><a href="#blockquote-태그" class="headerlink" title="blockquote 태그"></a>blockquote 태그</h2><p>다른 사이트에서 가져온 글을 인용할 때 사용하는 태그이다. (마크다운에도 비슷한 문법이 있다.)</p><h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/rpg6cemf/1/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="pre-태그"><a href="#pre-태그" class="headerlink" title="pre 태그"></a>pre 태그</h2><p>입력한 그대로 입력되게 해주는 태그다. 하지만 웹 표준성에 맞추기 위해 사용을 자제하는 것이 좋다.</p><h2 id="strong-b태그와-em-i-태그"><a href="#strong-b태그와-em-i-태그" class="headerlink" title="strong, b태그와 em, i 태그"></a>strong, b태그와 em, i 태그</h2><p>strong, b 태그는 텍스트를 굵게 표시하기 위해 사용된다. 둘의 차이점은 단순히 굵게 표시할떈 b태그, 강조되었다는 것을 알리기 위해선 strong 태그를 사용한다.</p><p>em, i 태그는 이탤릭체로 표시되게 하는 태그이다. 둘의 차이는 단순히 표시만 하는 것은 em, 의미를 알리기 위해선 i 태그르 사용한다는 것이다.</p><h2 id="blockquote와-q-태그"><a href="#blockquote와-q-태그" class="headerlink" title="blockquote와 q 태그"></a>blockquote와 q 태그</h2><p>두 태그 모두 인용문을 사용하는 태그이지만 둘의 차이는 블록 베레이냐 인라인 레벨이냐 이다.<br>blocakquote는 블록 레벨에 태그이기 때문에 인용 내용이 줄이 바뀌어 나타나지만, q태그는 인라인 태그이기 때문에 한 줄로 표시된다.</p><h2 id="span-태그"><a href="#span-태그" class="headerlink" title="span 태그"></a>span 태그</h2><p>줄 바꿈 없이 단락 안에서 텍스트를 묶을 때 사용하는 태그이다. 큰 의미는 없다.</p><p>다음 시간에는 목록만들기와 테이블 만들기를 알아보도록 하겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTML-텍스트-관련-태그들&quot;&gt;&lt;a href=&quot;#HTML-텍스트-관련-태그들&quot; class=&quot;headerlink&quot; title=&quot;HTML 텍스트 관련 태그들.&quot;&gt;&lt;/a&gt;HTML 텍스트 관련 태그들.&lt;/h3&gt;&lt;p&gt;HTML 문서를 작성할 때 가
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="HTML" scheme="http://rootjang92.github.io/categories/HTML-CSS/HTML/"/>
    
    
      <category term="HTML, html, HTML basic syntax, htmltag" scheme="http://rootjang92.github.io/tags/HTML-html-HTML-basic-syntax-htmltag/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 기본 개요</title>
    <link href="http://rootjang92.github.io/2018/09/02/jsbasic/"/>
    <id>http://rootjang92.github.io/2018/09/02/jsbasic/</id>
    <published>2018-09-02T01:46:18.000Z</published>
    <updated>2018-09-02T02:01:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="자바스크립트-기본-개요"><a href="#자바스크립트-기본-개요" class="headerlink" title="자바스크립트 기본 개요"></a>자바스크립트 기본 개요</h3><p>자바스크립트는 웹 브라우저에서 동작하는 스크립트 언어이다. 처음에는 웹 페이지 제작에 <strong>보조적</strong> 역할에 한정되어 있었다.<br>하지만 여러가지 연구와 prototype 라이브러리 개발 등 많은 발전이 있으면서 서버에서 담당하던 역할이 웹 브라우저로 옮겨졌고 결국 자바스크립트는 그 변화의 중심적인 언어가 되었다. (인사이드 자바스크립트 저:송형주, 고현준 참조)</p><p>현재 github에서 가장 많이 사용되고 있는 언어는 자바스크립트이고 Node.js의 개발로 서버 개발 또한 가능해지며 사용자가 늘고 있다.</p><p>자바스크립트는 현재 웹 개발은 물론 Node.js, express, socket.io 등을 활용한 서버 개발, 애플리케이션 개발도 가능해졌기 때문에 웹 기반 플랫폼에선 없어서는 안될 언어가 되었다.</p><h3 id="자바스크립트-핵심-개념"><a href="#자바스크립트-핵심-개념" class="headerlink" title="자바스크립트 핵심 개념"></a>자바스크립트 핵심 개념</h3><p>자바스크립트에서는 꼭 알아야 할 몇가지 핵심 개념이 있는데 앞으로 블로그를 운영하면서 차차 살펴보도록 하겠다.</p><ul><li>객체(Object)</li></ul><p>자바스크립트(이하 JS)의 거의 모든 것은 객체라고 할 정도로 중요한 개념이다. 자바스크립트의 기본 데이터 타입을 제외하곤 모든 것이 객체이다.<br>하지만 null과 undefined를 제외한 모든 것을 객체처럼 다룰 수 있기 때문에 이 2가지를 제외하곤 모두 객체라고 할 수 있다.</p><ul><li>함수</li></ul><p>JS에선 함수도 객체이다. 함수는 특히 중요하기 떄문에 일급 객체(First class object)로 취급된다.</p><ul><li>프로토타입</li></ul><p>모든 객체는 프로토타입을 가진다. 분량이 상당히 많을 것으로 예상되기 때문에 뒤에서 자세히 다루겠지만, 쉽게 말해서 해당 개체를 생성한 생성자를 가리킨다고 보면 된다. 이 프로토타입으로 인해 겍체지향에 상속을 구현할 수 있게 되었다.</p><ul><li>실행 컨텍스트와 클로저</li></ul><p>JS는 자신만의 방법으로 실행 컨텍스트를 만들고 그 안에서 유효범위(Scope)를 갖는다. 또한 그 과정에서 클로저를 구현할 수 있다.</p><ul><li>객체지향 프로그래밍</li></ul><p>JS는 클래스를 지원하지 않지만(ES6에서는 함수의 형태로 만들어졌다.) 상속과 캡슐화 등의 객체지향 프로그래밍을 따라가고 있다.</p><ul><li>JS와 함수형 프로그래밍</li></ul><p>‘모듈화’하면 함수형 프로그래밍! JS의 일급 객체인 함수와 클로저를 활용하여 함수형 프로그래밍이 가능하게 한다.</p><ul><li>단점</li></ul><p>굉장히 유연한 언어의 단점은 디버깅이 힘들다는 점, 느슨한 타입 체크로 인한 컴파일 에러(런타임 에러로 이어진다.)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;자바스크립트-기본-개요&quot;&gt;&lt;a href=&quot;#자바스크립트-기본-개요&quot; class=&quot;headerlink&quot; title=&quot;자바스크립트 기본 개요&quot;&gt;&lt;/a&gt;자바스크립트 기본 개요&lt;/h3&gt;&lt;p&gt;자바스크립트는 웹 브라우저에서 동작하는 스크립트 언어이
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES5" scheme="http://rootjang92.github.io/categories/Javascript/ES5/"/>
    
    
      <category term="Javascript, js, es5, ES5" scheme="http://rootjang92.github.io/tags/Javascript-js-es5-ES5/"/>
    
  </entry>
  
  <entry>
    <title>HTML 기본 문서 구조</title>
    <link href="http://rootjang92.github.io/2018/09/02/htmlbasic/"/>
    <id>http://rootjang92.github.io/2018/09/02/htmlbasic/</id>
    <published>2018-09-02T01:03:39.000Z</published>
    <updated>2018-09-02T01:44:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML-기본-문서-구조"><a href="#HTML-기본-문서-구조" class="headerlink" title="HTML 기본 문서 구조"></a>HTML 기본 문서 구조</h3><h1 id="1-태그"><a href="#1-태그" class="headerlink" title="1. 태그"></a>1. 태그</h1><p>HTML은 웹 문서에 마크업을 하는 언어이다. 그 때 마크업을 사용하는 약속된 표기법이 <strong>태그</strong> 이다.</p><ul><li><p>태그는 <code>&lt;&gt;</code>를 사용한다.<br>꺽쇠 사이에 들어가는 부분이 바로 tag 부분이다.</p></li><li><p>소문자로 쓴다.(권장사항)<br>대,소문자를 구분하진 않지만 HTML5 표준 명세에는 소문자를 권장하고 있다.</p></li><li><p>여는 태그와 닫는 태그<br>닫는 태그가 없는 경우도 있지만 닫는 태그가 필요한 태그에는 반드시 태그를 닫아주어야 한다.</p></li><li><p>들여쓰기.<br>쉽게 눈으로 확인하고 문서의 구조를 파악하기가 쉬워진다. tab키를 사용한다.</p></li><li><p>속성을 파악해야 한다.<br>태그 안에는 사용할 수 있는 속성값이 있다. 예를 들어 img 태그에는 src(주소값), width, height 등의 속성이 있다.</p></li></ul><h2 id="처음-만들어-보는-HTML-문서"><a href="#처음-만들어-보는-HTML-문서" class="headerlink" title="처음 만들어 보는 HTML 문서"></a>처음 만들어 보는 HTML 문서</h2><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/7dao64g5/6/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="문서-구조-살펴보기"><a href="#문서-구조-살펴보기" class="headerlink" title="문서 구조 살펴보기."></a>문서 구조 살펴보기.</h2><pre><code>&lt;!DOCTYPE html&gt;</code></pre><p>HTML5로 작성된 웹 문서라는 뜻이다. HTML4에서는 엄격모드, 호환 모드 등 꽤 복잡했지만 이젠 단 한줄이면 된다.</p><pre><code>&lt;html&gt; ~ &lt;/html&gt;</code></pre><p>웹 문서의 시작과 끝이라고 보면 된다. 이 태그에는 lang이라는 속성에 언어를 설정해 줘야 하는데 특정 언어로 검색할 때 그 대상이 될 수 있다.</p><pre><code>&lt;head&gt; ~ &lt;/head&gt;</code></pre><p>웹 문서를 해석하기 위해 필요한 정보들을 입력하는 곳이다.</p><pre><code>&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;title&gt;내가 처음 만드는 HTML 문서&lt;/title&gt;</code></pre><p>head 태그 안에는 meta태그와 title태그가 보통 표시 되는데 화면에 보이는 것은 title 태그이다. meta 태그는 실제 문서 내용이 아닌 문서를 해석하기 위해 사용되는 태그이다.</p><p>title태그에 문서 제목을 입력하는 이유는 웹 표준성과 관련되어 있다. 간혹 시각 장애를 가지고 계시는 분들이 인터넷을 이용할 때 보조 기기를 이용하는데, 제목을 듣고 이 사이트가 어떤 사이트 인지 알 수 있어야 하기 떄문이다.</p><p>meta 태그 안에는 문자 인코딩 방법이나 키워드 등을 지정한다.</p><pre><code>&lt;body&gt; ~ &lt;/body&gt;</code></pre><p>웹 문서의 실질적인 내용(화면에 나오는 내용)이 나타내는 태그이다. 대부분의 태그는 이 <body>태그 안에 들어간다.</body></p><p>사이트를 이용하기 위해선 서버단에서 호스팅 서버를 준비해서 FTP 프로그램을 이용해 배포해야 한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTML-기본-문서-구조&quot;&gt;&lt;a href=&quot;#HTML-기본-문서-구조&quot; class=&quot;headerlink&quot; title=&quot;HTML 기본 문서 구조&quot;&gt;&lt;/a&gt;HTML 기본 문서 구조&lt;/h3&gt;&lt;h1 id=&quot;1-태그&quot;&gt;&lt;a href=&quot;#1-태그&quot;
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="HTML" scheme="http://rootjang92.github.io/categories/HTML-CSS/HTML/"/>
    
    
      <category term="HTML, html, HTML basic syntax, html tag" scheme="http://rootjang92.github.io/tags/HTML-html-HTML-basic-syntax-html-tag/"/>
    
  </entry>
  
  <entry>
    <title>HTML이란?</title>
    <link href="http://rootjang92.github.io/2018/09/01/html1/"/>
    <id>http://rootjang92.github.io/2018/09/01/html1/</id>
    <published>2018-09-01T06:27:45.000Z</published>
    <updated>2018-09-01T07:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML이란-무엇인가"><a href="#HTML이란-무엇인가" class="headerlink" title="HTML이란 무엇인가?"></a>HTML이란 무엇인가?</h3><p>우리가 흔히 보는 웹사이트의 기본은 HTML 이다. 흔히 ‘웹 문서’를 작성한다고 말하는데 이를 보는 프로그램이 바로 ‘Web browser’이다.<br>HTML은 HyperText Markup Language의 줄임말로서 하이퍼텍스트를 마크업한는 언어다.</p><h1 id="하이퍼-텍스트란"><a href="#하이퍼-텍스트란" class="headerlink" title="하이퍼 텍스트란?"></a>하이퍼 텍스트란?</h1><blockquote><p>웹 사이트에서 링크를 클릭해 다른 문서나 사이트로 즉시 이동할 수 있는 기능.</p></blockquote><p><code>&lt;&gt;</code>로 묶인 것은 HTML 태그라고 하고 이렇게 태그를 붙이는 것이 마크업이다. 이 꺽쇠안의 내용은 웹 브라우저 화면에 나타나지 않는다.</p><p>네이버로 들어가 [페이지 소스 보기], 혹은 검사(chrome)을 하여 documents를 살펴보자.<br><a href="https://www.naver.com" target="_blank" rel="noopener">HTML소스 엿보기</a></p><h1 id="웹-표준이란"><a href="#웹-표준이란" class="headerlink" title="웹 표준이란?"></a>웹 표준이란?</h1><p>우리가 현재 사용하고 있는 HTML5를 웹 표준 기술이라고 하는데 왜 웹 표준이 필요할까?<br>바로 ‘표준’이 필요하기 떄문입니다. 세상에는 많은 브라우저들이 있기 때문에 예를 들어 IE에서는 맞지 않고 크롬에만 맞는 사이트를 구현한다면 사용자들이 자유롭게 이용할 수 없다.</p><p>따라서 HTML5로 문서를 만드는 것은 웹 표준을 지키는 문서를 만드는 것이다.</p><ol><li>최신 웹 표준에 맞는 웹사이트를 제작할 수 있다.</li><li>앱 화면의 기초를 디자인한다.</li><li>Interactive한 사이트를 만들 수 있다.</li><li>소스를 이해하여 웹 사이트나 블로그를 쉽게 수정할 수 있다.</li></ol><p>이로서 HTML5를 왜 사용하는 지에 대해 알아보았습니다. 다음 시간에는 HTML의 기본 문서 구조에 대해 알아보겠습니다.</p><ul><li>이 글은 DO it! HTML5 + CSS3 웹 표준의 정석이라는 책을 인용하였습니다.</li><li>thumbnail 출처 : <a href="http://knulab.com/archives/1060" target="_blank" rel="noopener">http://knulab.com/archives/1060</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTML이란-무엇인가&quot;&gt;&lt;a href=&quot;#HTML이란-무엇인가&quot; class=&quot;headerlink&quot; title=&quot;HTML이란 무엇인가?&quot;&gt;&lt;/a&gt;HTML이란 무엇인가?&lt;/h3&gt;&lt;p&gt;우리가 흔히 보는 웹사이트의 기본은 HTML 이다. 흔히 
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="HTML" scheme="http://rootjang92.github.io/categories/HTML-CSS/HTML/"/>
    
    
      <category term="HTML, html" scheme="http://rootjang92.github.io/tags/HTML-html/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://rootjang92.github.io/2018/08/30/hello-world/"/>
    <id>http://rootjang92.github.io/2018/08/30/hello-world/</id>
    <published>2018-08-30T06:10:05.000Z</published>
    <updated>2018-08-30T06:10:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
