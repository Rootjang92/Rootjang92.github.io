{"meta":{"title":"Rootjang's IT Blog","subtitle":"Geunho's IT Blog","description":null,"author":"Geun ho","url":"http://rootjang92.github.io"},"pages":[],"posts":[{"title":"Input 태그","slug":"htmlinput","date":"2018-09-10T06:30:48.000Z","updated":"2018-09-10T06:36:05.000Z","comments":true,"path":"2018/09/10/htmlinput/","link":"","permalink":"http://rootjang92.github.io/2018/09/10/htmlinput/","excerpt":"","text":"태그Input 태그란?Input 태그는 기본적으로 입력 항목을 만드는 태그다.체크박스 등의 클릭하는 버튼도 input 태그를 활용해 만든다. id 속성을 사용하면 label 태그를 사용할 수 있다. Input 태그의 type 속성에 사용 하는 유형.input type태그속성 하지만 브라우저마다 지원이 다르기 때문에 이 사이트를 참조하여 얼마나 지원하는 지 알아보면 좋다. 브라우저지원확인 미완성입니다.","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"HTML","slug":"HTML-CSS/HTML","permalink":"http://rootjang92.github.io/categories/HTML-CSS/HTML/"}],"tags":[{"name":"html, html input","slug":"html-html-input","permalink":"http://rootjang92.github.io/tags/html-html-input/"}]},{"title":"함수의 this","slug":"jsfuncthis","date":"2018-09-10T05:15:07.000Z","updated":"2018-09-10T06:29:54.000Z","comments":true,"path":"2018/09/10/jsfuncthis/","link":"","permalink":"http://rootjang92.github.io/2018/09/10/jsfuncthis/","excerpt":"","text":"thisthis arguments 객체자바스크립트는 인자의 갯수를 달리해도 오류가 발생하지 않는다. 넘겨지지 않은 인자는 undefined, 갯수가 많을 경우에는 무시된다.이렇기 때문에 런타임 시 인자의 갯수를 확인하여 동작을 다르게 해줘야 하는데 이를 가능하게 하는 것이 arguments 객체이다. function add(a,b) { console.dir(arguments); return a+b; } console.log(add(1)); console.log(add(1,2)); VM156:2 Arguments(1)0: 1 callee: ƒ add(a,b) length: 1 Symbol(Symbol.iterator): ƒ values() __proto__: Object VM156:6 NaN VM156:2 Arguments(2) VM156:7 3 arguments는 유사 배열 객체이기 때문에 length를 가지고 있다. 이를 활용한 함수를 구현하자면… 예시ㅡ function sum() { var res = 0; for(var i = 0; i &lt; arguments.length; i++) { res += arguments[i]; } return res; } console.log(sum(1)); console.log(sum(1,2,3,4,5,6,7,8,9)); 출력결과 145 this 바인딩자바스크립트의 this는 타 언어와 달리 함수 호출 패턴에 따라 this가 참조하는 객체가 달라진다. (후…) 객체 메서드 호출 시 this 이 떄에는 해당 메서드를 호출한 객체로 바인딩 된다. var myObj = { name: &apos;Jang&apos;, sayName: function() { console.log(this.name); } }; var Obj = { name: &apos;Geun&apos; }; Obj.sayName = myObj.sayName; myObj.sayName(); // 1 Obj.sayName(); // 2 출력결과 JangGeun 우리는 sayName()이 호출되는 지점을 봐야 한다. 이 메서드의 this는 자신을 호출한 객체로 바뀌기 때문에 1에서는 Jang이 2에서는 Geun이 출력되는 것이다. 함수를 호출할 때 this 이 때의 this는 전역 객체에 바인딩 된다. (브라우저의 경우 window 객체, 런타임 환경의 경우 global) var test = &apos;test&apos;; console.log(window.test); var sayBar = function() { console.log(this.test); }; sayBar(); 출력결과 testtest test 변수는 전역 변수이기 때문에 window로 접근이 가능하다. 또한 sayBar 함수에서 this는 전역을 가리키기 때문에 window에 바인딩되어 test가 호출된다. var num = 100; var myObj = { num: 1, func1: function() { this.num += 1; console.log(&apos;func1() called. this.num : &apos; + this.num); // func2 func2 = function() { this.num += 1; console.log(&apos;func2() called. this.num : &apos; + this.num); } func2(); } }; myObj.func1(); 출력결과 func1() called. this.num : 2func2() called. this.num : 101 우리가 생각했던 방식은 부모 요소의 객체와 같은 거라고 예상했기에 2,3이 떠야 하지만 결과는 2와 101이 떴다. 그 이유는 내부 함수의 호출 패턴을 지정하지 않았기 때문이다. 내부 함수의 this는 전역 객체에 바인딩되기 때문에 부모 함수의 this를 다른 변수에 저장해야 한다. var num = 100; var myObj = { num: 1, func1: function() { var that = this; this.num += 1; console.log(&apos;func1() called. this.num : &apos; + that.num); // func2 func2 = function() { that.num += 1; console.log(&apos;func2() called. this.num : &apos; + that.num); } func2(); } }; myObj.func1(); 출력결과 func1() called. this.num : 2func2() called. this.num : 3 this를 that 변수에 저장하여 내부함수가 부모 함수의 변수에 접근이 가능하게 만들었다. 생성자 함수 호출 시 this 복습하자면 생성자 함수는 기존 함수에 new 연산자를 붙이는 방법이다. 또한 함수 이름 첫 글자를 대문자로 쓰기를 권한다. 많은 책이나 블로그에서 중요하게 여기는 것이 생성자 함수의 this바인딩을 이해하기 위해선 생성자 함수의 동작 방식을 이해해야 한다고 설명하고 있다. 빈 객체 생성 및 this 바인딩이 빈 객체가 this로 바인딩 된다. 단 이 생성자 함수가 생성한 객체는 생성자 함수 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체로 설정한다. this를 통해 프로퍼티 생성this를 사용해서 생성된 빈 객체에 동적으로 프로퍼티나 메서드를 생성할 수 있다. 생성된 객체 리턴일반적으로는 this에 바인딩된 새롭게 생성된 객체가 리턴된다.(일반 함수에서는 undefined) 그러나 다른 객체를 반환한다면 해당 객체가 리턴된다. var Person = function (name) { this.name = name; }; var foo = new Person(&apos;Jang&apos;); console.log(foo.name); 출력 결과 Jang Person() 생성자 함수가 빈 객체를 생성하며 Person.prototype을 [[prototype]]링크로 연결하여 자신의 프로토타입으로 설정한다.그러면서 this에 name이라는 동적 프로퍼티를 생성하여 리턴을 받환하여 foo 변수에 저장한다. 객체 리터럴 방식과 생성자 함수의 차이점. 둘의 가장 큰 차이점은 바로 프로토타입 객체다. 객체 리터럴은 Object(), 생성자 함수는 생성자함수 이름이 프로토타입 객체가 된다.그 이유는 둘의 생성자가 다르기 때문이다. 객체 리터럴의 경우 생성자가 Object()이기 때문이다. call과 apply 메서드를 사용한 this 이 방법은 명시적으로 this를 바인딩시키는 방법이다. 단 이 메서드들은 Function.prototype 객체의 메서드이다. function.apply(thisArg, argArray) 주의할 점은 결국 apply() 메서드를 호출하는 것은 함수이고, 본질적인 기능이 함수 호출이라는 점이다. 첫번째 인자는 this에 바인딩할 객체를 가리키고 두 번째 인자는 함수를 호출할 때 넘길 인자들의 배열을 가리킨다. function Person(name, age, gender) { this.name = name; this.age = age; this.gender = gender; } var foo = {}; Person.apply(foo,[&apos;Jang&apos;, 27, &apos;man&apos;]); console.dir(foo); Object age: 27 gender: “man” name: “Jang” proto: Object 결론적으로 이 코드는 Person(‘Jang’,27,’man’) 함수를 호출하여 this를 foo 객체에 명시적으로 바인딩한 것이다. 이들을 활용하는 것의 장점은 유사 배열 객체에 배열 메서드를 사용하는 경우에 나타난다. function myFunction() { console.dir(arguments); // arguments.shift(); -&gt; error var arg = Array.prototype.slice.apply(arguments); // Array.prototype.slice() 메서드를 호출하고 this는 arguments객체에 할당해라. console.dir(arg); } myFunction(1,2,3); 출력결과 [Arguments] { ‘0’: 1, ‘1’: 2, ‘2’: 3 }[ 1, 2, 3 ] 함수 리턴함수는 항상 리턴값을 반환한다. 라는게 포인트이다. 만약 리턴문이 없다면 undefined값이 리턴된다. 생성자 함수에서 리턴값을 지정하지 않으면 생성된 객체가 리턴된다. 생성자 함수에서 별도의 리턴값을 지정하지 않으면 this에 바인딩된 객체가 리턴되기 때문에 일반적으로 리턴문을 사용하지 않는다.만약 명시적으로 리턴값을 지정한다면 객체 외에 경우에는 리턴값을 무시하지만 객체를 지정할 경우 그 객체가 반환된다. 다음 시간에는 프로토타입 체이닝에 대해서 알아보겠습니다~!","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://rootjang92.github.io/categories/Javascript/"},{"name":"ES5","slug":"Javascript/ES5","permalink":"http://rootjang92.github.io/categories/Javascript/ES5/"}],"tags":[{"name":"Javascript, js, js this, this, prototype chain","slug":"Javascript-js-js-this-this-prototype-chain","permalink":"http://rootjang92.github.io/tags/Javascript-js-js-this-this-prototype-chain/"}]},{"title":"자바스크립트의 함수","slug":"jsfunction","date":"2018-09-09T06:52:11.000Z","updated":"2018-09-10T05:16:30.000Z","comments":true,"path":"2018/09/09/jsfunction/","link":"","permalink":"http://rootjang92.github.io/2018/09/09/jsfunction/","excerpt":"","text":"함수란?함수자바스크립트에서 가장 중요한 것이 무엇이냐고 했을 때 십중팔구는 함수를 이야기 할 것이다. 자바스크립트의 함수는 모듈화, 클로져, 객체 생성, 함수형 프로그래밍 지향에 있어서 정말 중요한 개념이고 잘 이해하여야 한다.(그런 의미에서 나는 아직 멀었다.) 함수의 생성방법함수 생성방법은 객체 생성방법과 비슷하게 3가지가 있다. 함수 선언문, 함수 표현식, Function() 생성자 함수 이 세가지 이다. 함수 리터럴 계속 강조하지만 함수도 결국 객체이다.(일급 객체라서 중요하다!) 그렇기 때문에 함수 리터럴 방식이 존재한다. function multiply(x,y) { return x * y; } 함수 키워드, 함수 명, 매개변수 리스트로 구성되어 있다. 함수 선언문 함수 리터럴과 형태는 같지만 주의할 점은 반드시 함수명이 있어야 한다는 점이다. function multiply(x,y) { return x * y; } console.log(multiply(3,4)); 출력결과 12 함수 표현식 함수 표현식은 함수 리터럴로 함수를 생성하여 생성된 함수를 변수에 할당하는 형태이다. var mul = function (x,y) { return x * y; } console.log(mul(3,4)); 출력결과 12 이렇게 이름이 없는 함수 형태를 익명함수라고 부른다. 즉 변수 mul을 통해 함수를 할당한 것을 익명 함수를 이용한 함수 표현식이라고 한다.위 예제는 기명 함수 표현식으로도 가능하다. 다만 함수 표현식에서 사용된 함수 이름은 외부 코드에서의 참조가 불가능하다. 이를 활용해서 팩토리얼 함수를 만들어 보도록 하자. var factorial = function factorial(n) { if ( n &lt;= 1) { return 1; } return n * factorial(n-1); } console.log(factorial(3)); console.log(factorial(1)); 출력결과 61 이는 재귀 호출을 이용한 방법으로 함수를 선언한 후 함수 내부에서 재귀호출하여 함수를 처리하였다. Function() 생성자 함수 자바스크립트의 함수도 결국 Function()이라는 내장 생성 함수에서 생성된 것이다. (축약 표현일 뿐이다.) var add = new Function(&apos;x&apos;, &apos;y&apos;, &apos;return x + y&apos;); console.log(add(3,4)); 출력결과 7 함수 호이스팅자바스크립트의 권위자 인 더글라스 크락포드는 함수 생성에서 함수 표현식만을 사용할 것을 권하고 있는 데 그 이유가 바로 호이스팅 때문이다. // 함수 호이스팅으로 인한 호출 가능. var res = square(5); function square(number) { return number * number; } // TypeError var res = square(5); var square = function(number) { return number * number; } 함수 표현식은 변수 호이스팅이 발생하기 때문에 함수 호이스팅 처럼 변수생성, 초기화, 할당이 한 번에 일어나는 것이 아니라 변수 호이스팅 처럼 생성과 초기화만 동시에 일어난다.결론적으로 함수 호출 전에는 반드시 함수를 선언하여야 한다. 함수 = 객체자바스크립트의 함수는 결국 객체이기 떄문에 일반 객체처럼 프로퍼티들을 가질 수 있다. 그렇기 때문에 위에서 설명한 것처럼 리터럴에 의한 생성, 변수나 배열 요소, 객체 프로퍼티 할당 가능, 함수의 인자로 전달 가능, 함수의 리털값으로 사용 가능, 동적으로 프로퍼티 생성 및 할당 가능 등 객체와 똑같이 적용된다. 위에 나열한 기능이 모두 가능하기 때문에 함수를 일급 객체라고 부르는 것이다. 변수나 프로퍼티에 할당. 함수도 변수나 프로퍼티에 할당할 수 있다. var foo = 100; var bar = function() { return 100; }; console.log(bar()); var obj = {}; obj.baz = function () { return 200; }; console.log(obj.baz()); 출력결과 100200 함수 인자로 전달. 다른 함수의 인자로 전달 가능하다. var foo = function(func) { func(); }; foo(function() { console.log(&apos;kkk&apos;); }); 출력결과 kkk 리턴값으로 활용 다른 함수의 리턴값으로도 활용할 수 있다. var a = function() { return function() { console.log(&apos;apple&apos;) }; }; var b = a(); b(); 출력결과 apple 변수 b에 함수 a를 호출하면 리턴값으로 전달되는 함수가 b 변수에 저장되어 apple이 출력된다. 기본 프로퍼티 정말 중요하다. 함수는 객체다. (일급객체) 또한 함수 객체만의 프로퍼티를 가지고 있다. 크롬 검사도구에서 함수를 살펴보면 arguments,caller, length 등과 같은 프로퍼티가 보인다는 것을 알 수 있다. (console.dir로 호출해 보시길)또한 객체이기 때문에 prototype을 갖는다. 함수 객체의 프로토타입은 Function.prototype 객체이다. prototype과 [[prototype]] 이 둘은 많이 헷갈릴 수 있는 개념이다. 하지만 둘은 엄연히 다른 개념이다. 물론 두 프로퍼티가 모두 프로토타입 객체를 가리킨다. 하지만 보는 관점에서 차이가 있다. [[prototype]]객체 입장에서 자신의 부모 역할을 수행하는 프로토타입 객체를 가리킨다. prototype함수가 생성자일 때 함수를 통해 생성된 객체의 부모 역할을 하는 개체를 가리킨다. 그래서 함수를 생성할 때 만들어지고 constructor 프로퍼티 하나만 있는 객체를 말한다. 함수 형태 콜백 함수익명 함수가 사용되는 대표적인 용도가 콜백함수이다. 콜백 함수는 어떤 이벤트가 발생했을 때 시스템에서 호출되는 함수이다.대표적인 예로 이벤트 핸들러 처리가 있다. 즉시 실행 함수Immediate function은 정의와 동시에 출력되는 함수이다. (function (name) { console.log(&apos;welcome -&gt; &apos; + name); })(‘Jang’); 출력결과 welcome -&gt; Jang 즉시시행함수는 바로 시행되지만 다시 호출할 수 없기 때문에 한 번만 실행하는 초기화 실행 같은 코드에 적합하다.(추후에 즉시실행함수에 대해 한 번 다뤄보도록 하겠습니다.) 내부 함수자바스크립트 함수는 내부에서도 함수를 정의할 수 있다. 이를 내부함수라고 한다. function parent() { var a = 100; var b = 200; function child() { var b = 300; console.log(a); console.log(b); } child(); } parent(); child(); 출력결과 100300ReferenceError: child is not defined 100이 출력되는 이유는 스코프 체이닝에 의해서 child함수의 부모인 parent 함수에서 변수 a의 값을 찾았기 때문에 가능한 것이다.또한 내부 함수는 자신을 둘러싼 외부 함수에서 접근이 가능하지만 그 내부에서만 호출이 가능하기 때문에 레퍼런스 에러가 발생했다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://rootjang92.github.io/categories/Javascript/"},{"name":"ES5","slug":"Javascript/ES5","permalink":"http://rootjang92.github.io/categories/Javascript/ES5/"}],"tags":[{"name":"js, javascript, javascript function, 자바스크립트 함수","slug":"js-javascript-javascript-function-자바스크립트-함수","permalink":"http://rootjang92.github.io/tags/js-javascript-javascript-function-자바스크립트-함수/"}]},{"title":"Form 태그에 대하여","slug":"htmlform","date":"2018-09-09T06:15:24.000Z","updated":"2018-09-09T06:51:32.000Z","comments":true,"path":"2018/09/09/htmlform/","link":"","permalink":"http://rootjang92.github.io/2018/09/09/htmlform/","excerpt":"","text":"HTML 폼 태그에 대하여폼 태그란 특정 형식에 사용자가 무언가를 입력하는 형태로 이루어져 있다. 로그인이나 회원가입 창이 그 예이다.웬만한 페이지에서는 형식에 구해받지 않고 이런 폼 태그를 볼 수 있다. 우리가 많이 사용하는 SNS에서도 회원가입을 하기 위해서 입력하는 정보들도 폼이다. 로그인을 예로 들면 우리가 클라리언트에서 정보를 입력하여 서버로 보내면 그 서버에서 DB를 확인하여 다시 보내주는 형태로 반응한다. 그 방법에는 여러가지가 있는데 흔히 ASP, PHP, JSP등을 사용할 수도 있고 최근 라이브러리나 프레임워크를 사용하면서 axios나 rxjs등의 여러가지 형태로도 가능하다. 폼태그&lt;form [속성=&quot;속성값&quot;]&gt;&lt;/form&gt; 폼 택의 기본적인 형태는 이렇다. 하지만 그 속성은 정말 다양하게 존재한다. method서버 쪽에 넘겨줄 방법을 지정하는 속성이다. 보통 get, post를 사용하는 데 get은 url자체에 담아서 넘겨줘 데이터 용량에 제한이 있지만 우리가 보통 사용하는 post 방식은 표준 입력으로 제한이 없고 정보가 노출되지 않는다. name폼의 이름을 지정한다. action서버 상의 프로그램을 지정한다. target스크립트 파일을 현재창에 띄울 지 다른 위치에서 열지 지정한다. autocomplete자동완성 속성이다. 우리가 검색창에서 어떤 검색어를 입력할 때 자동완성 되는 경험을 해본 적이 있을 것이다. 기본값은 on으로 지정되어 있다. label 태그&lt;label [속성=&quot;속성값&quot;]&gt;&lt;/label&gt; label 태그는 폼 요소에 레이블을 붙이기 위한 태그이다. 직접 텍스트를 입력할 수도 있고 for 속성을 사용하여 지정할 수도 있다. 또한 라벨 태그를 input 태그에 checkbox나 radio 버튼과 연결하면 텍스트를 클릭해도 항목이 클릭되게 만들 수도 있다. fieldset과 legend 태그이 두 태그는 폼 요소를 그룹으로 묶을 때 사용한다. 이 태그를 사용하면 하나의 그룹으로 묶고 외곽선을 그려준다. input 태그쉽게 말해서 우리가 입력할 수 있는 텍스트 상자나 로그인 버튼 등을 만들어 내는 태그가 바로 input 태그이다. &lt;input type=&quot;유형&quot; [속성=&quot;속성값&quot;]&gt; 위 예제에서 봤듯이 input태그에서 id 속성을 사용하면 label 태그를 통해 속성을 붙이기도 하고 css에서도 사용할 수 있다. input태그 속성 다음 시간에는 input 태그의 사용법에 대해서 예제와 함께 살펴보도록 하겠습니다. (찡긋)","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"HTML","slug":"HTML-CSS/HTML","permalink":"http://rootjang92.github.io/categories/HTML-CSS/HTML/"}],"tags":[{"name":"HTML, html, html form, form tag","slug":"HTML-html-html-form-form-tag","permalink":"http://rootjang92.github.io/tags/HTML-html-html-form-form-tag/"}]},{"title":"프로토타입과 배열 그리고 연산자","slug":"jsprototype","date":"2018-09-05T07:27:24.000Z","updated":"2018-09-05T08:48:34.000Z","comments":true,"path":"2018/09/05/jsprototype/","link":"","permalink":"http://rootjang92.github.io/2018/09/05/jsprototype/","excerpt":"","text":"프로토타입자바스크립트의 모든 객체는 자신의 부모 역할을 하는 객체와 연결되어 있다. 이를 통해 자바스크립트에서는 상속 개념을 구현할 수 있다. 이를 프로토타입 객체라고 한다. var foo = { name: &apos;Jang&apos;, age: 27 }; console.log(foo.toString()); console.dir(foo); 코드를 한 번 살펴보자. 사실상 1번 콘솔로그에서 toString이라는 메서드가 없어 오류가 발생해야 하지만 정상적으로 작동한다.즉, foo 객체의 부모 역할을 하는 프로토타입에 toString() 메서드가 이미 정의되어 있기 때문에 호출이 가능한 것이다. 출력결과 [object Object]{ name: ‘Jang’, age: 27 } 즉 모든 객체는 자신의 프로토타입을 가리키는 [[Prototype]]이라는 숨겨진 프로퍼티를 가진다. (크롬 브라우저의 _proto_)여기서 foo 객체는 자신의 부모 객체를 _proto_라는 내부 프로퍼티로 연결하고 있다.자세한 내용은 프로토타입 체이닝에서 더 다루겠지만, 결론적으로 객체 리터럴로 생성한 객체의 경우 Object.prototype 객체가 프로토타입 객체이다. 배열 배열 리터럴배열 리터럴은 ‘[]’를 사용해서 배열을 만든다. var colorArr = [‘orange’, ‘red’, ‘yellow’, ‘green’]; console.log(colorArr[0]); console.log(colorArr[1]); 출력결과 orangered 배열은 인덱스 값으로 접근할 수 있다. 배열 내 인덱스는 0부터 시작한다. 즉 첫번째 값의 인덱스는 0인 것이다. 배열 요소 생성배열도 다른 객체와 마찬가지로 동적으로 배열 원소를 동적으로 추가할 수 있다. var empty = []; console.log(empty); empty[0] = 100; empty[3] = ‘four’; console.log(empty); console.log(empty.length); 출력 결과 [][ 100, undefined x 2, four ]4 자바스크립트의 배열은 인덱스 순서와 상관없이 할당이 가능하다. 값이 없다면 undefined가 뜬다.또한 중요한 점은 자바스크립트가 배열의 크기를 배열 인덱스 중 가장 큰 값을 기준으로 정한다.는 것이다.또한 length 프로퍼티를 이용하여 배열의 길이를 구할 수 있다. 배열의 길이 값은 가장 큰 인덱스에 +1을 한 값이다.(인덱스의 시작이 0 이기 때문이다.) length길이값은 위에서 설명했지만, 중요한 것은 길이값을 명시적으로 변경할 수 있고 그 길이를 초과하는 값은 삭제된다는 점이다.위 예제에서 empty의 length값은 4이지만 length값을 2로 설정하면, 100과 undefined를 제외한 뒤의 값은 삭제된다. 배열과 객체배열과 객체는 모두 객체이지만 몇 가지 차이점이 있다. 우선 length 프로퍼티는 배열에만 존재한다. 두 번째로는 프로토타입의 차이이다.일반 객체는 push와 같은 표준 배열 메서드를 사용할 수 없는데 둘의 프로토타입 체이닝에 의한 부모 프로토타입 객체가 서로 다르기 때문이다. 객체 - _proto_ - Object.prototype배열 - _proto_ - Array.prototype - _proto_ - Object.prototype 배열의 프로퍼티 열거객체는 for in 문으로 객체를 열거할 수 있는데 배열은 for in문을 사용하면 불필요한 프로퍼티가 출력될 수 있으므로 for문을 사용하는 것이 좋다. var arr = [&apos;zero&apos;, &apos;one&apos;, &apos;two&apos;]; console.log(arr.length); arr[3] = &apos;red&apos;; console.log(arr.length); for (var i = 0; i &lt; arr.length; i++) { console.log(i, arr[i]); } 출력 결과 34for문 결과값0 ‘zero’1 ‘one’2 ‘two’3 ‘red’ 배열 요소 삭제배열도 객체이므로 delete 연산자를 사용할 수 있지만, 이는 해당 요소를 undefined처리할 뿐이다. 그래서 배열에서는 splice()배열 메서드를 사용한다. splice() 배열 메서드splice(start, deleteCount, item…) start : 배열에서 시작 위치, deleteCount : 삭제할 요소의 수 item : 삭제할 위치에 추가할 요소ㅡ var arr = [&apos;zero&apos;, &apos;one&apos;, &apos;two&apos;, &apos;three&apos;]; arr.splice(2,1); // 1 console.log(arr); console.log(arr.length); 즉 1의 의미는 arr배열의 2번째부터 1개 요소를 삭제하겠다는 의미이다. 즉 arr 요소에서 ‘two’가 삭제되는 것이다. 출력 결과 [ ‘zero’, ‘one’, ‘three’ ]3 Array() 생성자 함수배열은 배열 리터럴로 생성하지만 배열 리터럴도 결국 Array()생성자 함수로 배열을 생성하는 것을 단수화한 것이다.생성자 함수로 배열을 생성할 때에는 new 연산자를 사용하여야 한다. var foo = new Array(3); console.log(foo); console.log(foo.length); var bar = new Array(1,2,3); console.log(bar); console.log(bar.length); 호출할 때 인자가 1개이면 호출된 인자를 lenth로 갖는 빈 배열을 생성하고 그 외에는 호출된 인자를 요소로 같는다. 출력 결과 [ undefined x 3]3[1,2,3]3 유사 배열 객체length 프로퍼티는 배열의 동작에 있어서 정말 중요하다. 그런데 일반 객체에서도 length를 사용할 수 있는 경우가 있으니 이를 유사 배열객체라고 한다. var arr = [&apos;bar&apos;]; var obj = { name: &apos;Jang&apos;, length : 1}; arr.push(&apos;baz&apos;); console.log(arr); Array.prototype.push.apply(obj, [&apos;baz&apos;]); console.log(obj); 원래의 경우라면 변수 obj에는 push()메서드를 사용할 수 없으나, apply() 메서드를 사용하면 객체라도 표준 배열 메서드를 사용할 수 있다.후에 더 자세히 살펴볼 것이다. (call, apply 메서드) 출력 결과 [ ‘bar’, ‘baz’ ]{ ‘1’: ‘baz’, name: ‘Jang’, length: 2 } 기본 타입과 표준 메서드기본 타입의 경우 어떻게 표준 메서드를 호출하는가? 자바스크립트에서는 기본값을 객체로 변화한 다음 각 타입의 표준 메서드를 불러온다. 연산자 연산자 +연산자는 더하기 연산과 문자열 연결 연산을 수행한다. 두 연산자가 모두 숫자인 경우에는 더하기 연산을 실시한다. typeof 연산자 피연산자의 타입을 문자열 형태로 리턴하는 연산자이다. 유의할 점은 null의 경우 object로 표시된다는 점(자바스크립트 개발단 오류)함수는 function이라는 점에 유의하여야 한다. 동등연산자와 일치연산자. 동등연사자의 경우(==) 피연사자의 타입이 다를 경우 이를 변경하여 비교하고 일치연산자의 경우(===) 타입을 변경하지 않는다. console.log(1 == &apos;1&apos;) // true console.log(1 === &apos;1&apos;) // false !! 연산자 !!연산자는 피연산자를 불리언값으로 변환한다. 값이 0이나 없다면 false, 그 외의 빈 객체, 배열, 문자열 등은 true로 표시된다. 다음 시간에는 함수와 프로토타입 체이닝에 대해서 알아보겠습니다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://rootjang92.github.io/categories/Javascript/"},{"name":"ES5","slug":"Javascript/ES5","permalink":"http://rootjang92.github.io/categories/Javascript/ES5/"}],"tags":[{"name":"Javascript, js, es5, ES5, prototype, js prototype","slug":"Javascript-js-es5-ES5-prototype-js-prototype","permalink":"http://rootjang92.github.io/tags/Javascript-js-es5-ES5-prototype-js-prototype/"}]},{"title":"이미지와 하이퍼텍스트링크","slug":"htmlimage","date":"2018-09-05T01:37:02.000Z","updated":"2018-09-05T07:26:34.000Z","comments":true,"path":"2018/09/05/htmlimage/","link":"","permalink":"http://rootjang92.github.io/2018/09/05/htmlimage/","excerpt":"","text":"이미지와 하이퍼텍스트 링크웹에서 사용되는 이미지 파일 형식은?웹 페이지는 기본적으로 설명은 텍스트, 메뉴나 로고 등은 이미지로 처리 한다. 웹 페이지의 경우 크기가 작고 화질이 좋은 파일 형식을 사용하여야 하는데 웹에서 사용할 수 있는 파일 형식은 GIF, JPG/JPEG, PNG 파일이 있다. 이미지 파일 형식 img 태그HTML에서 이미지를 삽입하는 태그는 태그이다. 이 때 src 속성을 사용하여 해당 이미지의 주소를 넣는다. img 태그에는 src속성과 alt속성이 있는데 src는 해당 이미지의 주소, alt는 설명이 들어간다.다시 돌아가 파일 경로에 대해 살펴보자. 내 컴퓨터에 있는 이미지를 사용한다면 그에 맞는 파일명, 다른 폴더에 있는 경우 하위 폴더와 함께 적어주면 된다. ‘/‘는 하위폴더를 나타낸다.(한단계 위는 ‘..’을 사용한다.) 웹 상의 이미지 또한 링크 주소를 받아 붙여넣을 수 있다. 해당 사이트가 닫히지 않는 이상 사용할 수 있다. 단 이 경우 저작권에 주의하여야 한다. alt는 이미지를 설명하는 대체 텍스트를 달 때 사용하는 속성이다. 이를 사용할 경우 시각 장애인에게 화면 낭독기가 이미지를 설명해 줄 수 있다. width, height 속성은 너비와 높이를 조정하는 속성이다. img의 기타 속성들 figure, figcaption : 설명 속성 태그 이미지에 설명을 함께 붙이고 싶을 때 사용하는 태그이다. figure태그는 설명 글을 붙일 대상을 지정합니다. 예를 들어 figure태그 안에 img태그와 figcaption태그를 넣게 되면 이미지 밑에 캡션이 달리게 됩니다. 링크텍스트를 클릭하면 연결된 주소로 즉시 이동하게 하는 기능이 링크이다. a태그와 href 속성. 사실상 링크에서 가장 중요한 두 요소이다. a태그를 이용하여 링크를 걸고 href 속성에 주소를 넣는다. 그 외에 속성으로는target(링크한 내용이 표실될 위치, 현재 창 혹은 새 창), download(링크 다운로드), rel(관계 알리기), hreflang(링크한 문서 언어 설정), type(파일 유형) SVG 이미지최근 웹 브라우저에서 svg 파일을 지원하면서 아이콘이나 로고에 많이 사용되고 있다. 이미지를 확대, 축소해도 깨끗한 상태로 유지되는 것이 바로 벡터 이미지이고 그 확장자명이 svg이다. 다음 시간에는 폼 태그에 대해 다루겠습니다.","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"HTML","slug":"HTML-CSS/HTML","permalink":"http://rootjang92.github.io/categories/HTML-CSS/HTML/"}],"tags":[{"name":"HTML, html, HTML basic syntax, HTML hyperlink, html link","slug":"HTML-html-HTML-basic-syntax-HTML-hyperlink-html-link","permalink":"http://rootjang92.github.io/tags/HTML-html-HTML-basic-syntax-HTML-hyperlink-html-link/"}]},{"title":"Object","slug":"jsobject","date":"2018-09-04T01:38:52.000Z","updated":"2018-09-05T01:36:37.000Z","comments":true,"path":"2018/09/04/jsobject/","link":"","permalink":"http://rootjang92.github.io/2018/09/04/jsobject/","excerpt":"","text":"객체 프로퍼티와 참조 그리고 프로토타입객체 프로퍼티 읽기와 쓰기 그리고 갱신우선 프로퍼티에 접근하는 방법을 알아야 하는데 그 방법에는 대괄호 표기법과 마침표 표기법 두가지가 있다. 예제var foo = { name : &apos;Jang&apos;, major : &apos;Computer science&apos; }; // 객체 프로퍼티 읽기 console.log(foo.name); console.log(foo[&apos;name&apos;]); console.log(foo.nickname); foo.major = &apos;electronics Business&apos;; console.log(foo.major); console.log(foo[&apos;major&apos;]); foo.age = 27; console.log(foo.age); foo[&apos;full-name&apos;] = &apos;Jang Geun-ho&apos;; console.log(foo[&apos;full-name&apos;]); console.log(foo.full); 출력 결과 JangJangundefinedelectronics Businesselectronics Business27Jang Geun-houndefined 마침표 표기법은 객체 다음에 마침표를 찍고 원하는 속성값을 적으면 된다. 대괄호 표기법은 객체의 프로퍼티를 문자열 형태로 만들어 대괄호 안에 넣으면 된다. 만약 문자화하지 않으면 값은 undefined가 나타난다. 또한 대괊호 표기법을 이용하여 기존 프로퍼티값을 갱신할 수 있다. 예제에서 살펴봤던 foo[‘major’]의 형태처럼 말이다.JS의 특징 중 하나가 프로퍼티의 동적 생성인데 보시다시피 foo.age라는 프로퍼티는 아직 존재하지 않지만 이걸 동적으로 생성하여 27이라는 숫자값을 할당해준다. 즉 기존에 있는 값은 갱신되고 없는 프로퍼터의 경우 동적 생성된 후 값이 할당된다는 의미이다. 주의할 점은 연산자가 포함되있는 경우라면 대괄호 표기법을 사용하여야 한다는 것이다.또한 객체 프로퍼티는 delete 연산자를 이용해 삭제할 수 있다. 단 delete 연산자는 프로퍼티만 삭제한다. 예제2var foo = { name : &apos;Jang&apos;, major : &apos;Computer science&apos; }; var prop; for (prop in foo) { console.log(prop, foo[prop]); } 출력결과 name Jangmajor Computer science for in 문을 이용해서 foo라는 개체에 루프를 돌렸다. prop 변수에 foo 객체의 프로퍼티가 하나씩 할당되면서 대괄호 표기법을 사용해 모든 요소가 출력된다. 참조 타입의 특성객체는 JS에서 참조 타입이라고 부른다. 객체의 연산은 참조값으로 처리가 되기 때문이다. var A = { val : 40 }; var B = A console.log(A.val); console.log(B.val); B.val = 50; console.log(A.val); console.log(B.val); A, B두 객체를 객체 리터럴 방식으로 생성해 보았다. 이 때 각 콘솔 로그의 값은 어떻게 찍힐까? 출력 결과 40405050 변수 A와 B는 동일한 객체를 가리키는 참조값을 가지기 때문에 B의 val 값을 50으로 변경하면 변수 A의 값도 변한다.즉 A는 실제로 객체를 참조하는 값을 저장하는 것이지 실제 객체를 나타내지는 않는다는 점이다.A 객체는 참조 변수 A가 가리키는 객체! 객체 비교JS에서의 동등 연산자(==)는 객체의 프로퍼티 값이 아니라 참조값을 비교한다. var a = 100; var b = 100; var objA = { value: 100 }; var objB = { value: 100 }; var objC = objB console.log(a == b); console.log(objA == objB); console.log(objB == objC); 출력 결과를 예상해보자. 당연히 모두 true를 예상했겠지만(처음에는 저도…) 답은… 출력결과 truefalsetrue 변수 objA와 objB는 다른 참조값을 가진다. a,b처럼 기본 타입의 경우는 단순히 값을 비교하지만 객체의 경우 참조값을 비교하기 때문에 각각 다른 값을 참조하고 있는 두 변수는 동등 연산자를 사용했을 때 false가 나오는 것이다. 함수 호출 방식.기본 타입과 참조 타입은 함수 호출 방식이 다르다. 기본타입call by value(값에 의한 호출) : 기본 타입의 값을 인자로 넘길 경우 호출된 함수의 매개변수로 복사된 값이 전달된다.그렇기 때문에 함수 내 매개변수로 값을 변경해도 실제로 변수의 값은 변하지 않는다. 참조타입call by reference(참조에 의한 호출) : 함수 호출 시 인자로 넘긴 객체의 참조값이 그대로 함수로 전달된다. 그렇기 때문에 함수 내부에서 참조값을 변경하면 실제 객체의 값도 변경된다. var a = 100; var objA = { value: 100 }; function changeArg(num, obj) { num = 200; obj.value = 200; console.log(num); console.log(obj); } changeArg(a, objA); console.log(a); console.log(objA); 출력 결과 200{ value: 200 }100{ value: 200 } 함수를 호출하면서 기본 타입인 변수 a의 값은 변화하지 않았지만, 객체 타입인 objA의 값은 변화하였다. 참고자료 다음 시간에는 프로토타입과 배열에 대해 살펴보겠습니다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://rootjang92.github.io/categories/Javascript/"},{"name":"ES5","slug":"Javascript/ES5","permalink":"http://rootjang92.github.io/categories/Javascript/ES5/"}],"tags":[{"name":"Javascript, js, es5, ES5, object, js object","slug":"Javascript-js-es5-ES5-object-js-object","permalink":"http://rootjang92.github.io/tags/Javascript-js-es5-ES5-object-js-object/"}]},{"title":"목록을 생성하는 HTML 태그","slug":"htmllist","date":"2018-09-04T01:12:31.000Z","updated":"2018-09-04T08:14:53.000Z","comments":true,"path":"2018/09/04/htmllist/","link":"","permalink":"http://rootjang92.github.io/2018/09/04/htmllist/","excerpt":"","text":"목록을 생성하는 태그HTML 문서를 작성할 때 많이 쓰이는 태그 중 하나가 바로 목록을 생성하는 태그다. 웹 표준이 정의화된 후에는 이미지나 텍스트에 구애받지 않고 어떤 것이든 목록화 시킬 수 있다. 특히 CSS를 적용한다면 메뉴나 본문 내용 등으로 사용할 수 있으니 table 태그가 거의 안쓰이는 이유가 되기도 했다. ul태그, li태그이 두 태그는 ‘순서 없는’ 목록을 만들 때 사용되는 태그이다. ul태그 안에 li태그를 사용하여 목록화 시킨다. 예제 ol태그, li태그ol 태그는 순서가 필요한 목록을 만들 때 사용한다. ol은 타입을 지정할 수 있는데 1은 숫자를 나타내며 기본값으로 설정되어 있다.그 외에 a(영소문자),A(영대문자),i(로마숫자 소문자),I(로마숫자 대문자)로 이루어져 있다. CSS로도 대체 가능하다. 에제 dl,dt,dd 태그자주 쓰이는 태그는 아니지만 설명 목록을 만들 때 주로 쓰이는 태그이다. 경험이 적어서 그런건진 몰라도 이 태그 쓰는 사이트를 본 기억이 드물다. 위키트리에서는 쓰일 수도 있겠다… 여튼 dl태그로 묶고 dt 태그에 제목을 dd 태그에 설명을 표시한다. 지금까지 배운 자료를 가지고 본인만의 간단한 프로필 웹 페이지를 만들어 보는 것도 좋을 것 같다. 참고할 만한 사이트.HTML 온라인 검사기 이 사이트는 파일을 업로드하면 자동으로 HTML 문서 상 오류가 있는 지 검사해주는 사이트다. 웹 페이지를 제작할 때 꽤 유용하다.","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"HTML","slug":"HTML-CSS/HTML","permalink":"http://rootjang92.github.io/categories/HTML-CSS/HTML/"}],"tags":[{"name":"HTML, html, HTML basic syntax, htmltag, ul, li","slug":"HTML-html-HTML-basic-syntax-htmltag-ul-li","permalink":"http://rootjang92.github.io/tags/HTML-html-HTML-basic-syntax-htmltag-ul-li/"}]},{"title":"자바스크립트 데이터 타입과 연산자.","slug":"jsdatatype","date":"2018-09-03T09:04:58.000Z","updated":"2018-09-04T08:05:26.000Z","comments":true,"path":"2018/09/03/jsdatatype/","link":"","permalink":"http://rootjang92.github.io/2018/09/03/jsdatatype/","excerpt":"","text":"자바스크립트 데이터 타입자바스크립트의 데이터 타입에는 기본 타입과 참조 타입이 있다. 기본타입은 숫자, 문자열, boolean, undefined, null 값이 있고참조형에는 객체(배열, 함수, 정규 표현식)이 있다. 자바스크립트 기본 타입기본 타입에는 Nmber, String, Boolean, null, undefined가 있다.이들 타입의 특징은 그 자체가 하나의 값을 나타낸다는 것이다. 자바스크립트는 느슨한 타입의 언어이기 때문에 변수를 선언할 때 타입을 미리 지정하지 않고 var(es5)라는 키워드로 변수를 선언하여 어떠한 값이라도 데이터를 저장할 수 있다. var intNum = 10; var floatNum = 0.1; var singleQuoteStr = &apos;single quote string&apos;; var boolVar = true; var emptyVar; var nullVar = null; console.log(typeof intNum, typeof floatNum, typeof singleQuoteStr, typeof boolVar, typeof emptyVar, typeof nullVar); 출력 결과 number number string boolean undefined object 숫자다른 언어와 달리 JS에서는 하나의 숫자형만 존재한다. (모든 숫자를 64비트 부동 소수점 형태로 저장한다.)또한 모든 숫자를 실수로 처리하므로 나눗셈 연산에 주의하여야 한다. var num = 5 / 2; console.log(num); console.log(Math.floor(num)); 출력 결과 2.52 Math.floor 메서드는 정수 부분만 구하는 JS의 메서드이다. 문자열문자열은 작은 따옴표나 큰 따옴표를 이용해서 생성한다. 또한 JS의 문자열은 문자 배열처럼 인덱스를 이용할 수 있다. 또한 한 번 생선된 문자열은 수정이 불가능 하다. var str = &apos;easy&apos;; console.log(str[0], str[1], str[2], str[3]); str[0] = &apos;E&apos;; console.log(str); 출력 결과 e a s yeasy boolean값JS에서 사용하는 true, false 값이다. null과 undefined두 타입 모두 ‘값이 비어 있다.’를 나타내기 위해 사용된다. 값이 할당되지 않은 변수는 undefined이며 이는 변수 자체의 값이 undefined이다. (타입이자 값이다.) 여기 주의할 점은 null의 타입이 object라는 것인데 이 때문에 타입 변수인자를 확인할 때에는 일치 연산자를 사용하여야 한다. (===) var nullVar = null; console.log(typeof nullVar === null); console.log(nullVar === null); 출력 결과 falsetrue JS 객체 타입JS에서 기본 타입을 제외한 모든 것은 객체이다. 배열, 함수, 정규표현식 들도 마찬가지이다. 객체는 단순히 이름(key):값(value)를 저장하는 형태이다. 기본 타입은 하나의 값마늘 가지는 데에 반해 겍체는 여러 개의 프로퍼티를 포함할 수 있다. 그래서 기본 타입을 포함하거나 다른 객체를 가리킬 수도 있다. 또한 프로퍼티의 성질에 따라 함수로 포함시킬 수도 있으며 이러한 프로퍼티를 메서드라고 부른다. JS 객체 생성 방법.객체 생성 방법에는 3가지가 있다. 그 방법들에 대해 알아보자 Object() 생성자 함수.JS에서는 객체를 생성할 때 내장 Object() 생성자 함수를 제공한다. 예제를 통해 살펴보자. var foo = new Object(); // foo property make up foo.name = &apos;Jang&apos;; foo.age = 27; foo.gender = &apos;male&apos;; console.log(typeof foo); console.log(foo); 출력 결과 object{ name: ‘Jang’, age: 27, gender: ‘male’ } Object() 생성자 함수를 통해 객체를 생성하였고 그 타입은 object이고 변수 foo에 3가지 프로퍼티가 추가되었음을 알 수 있다. 객체 리터럴 방식.리터럴이란 표기법을 의미한다. 즉 간단한 표기법으로 객체를 생성하는 방식이다. var foo = { name : &apos;Jang&apos;, age : 27, gender : &apos;male&apos; }; console.log(typeof foo); console.log(foo); 출력 결과 object{ name: ‘Jang’, age: 27, gender: ‘male’ } 생성자 함수 이용.객체를 함수를 통해서도 생성할 수 있다. 생성자 함수라고 하는데 다음에 더 자세히 다루도록 하겠다. 다음 시간에는 객체 프로퍼티 표기법과 참조타입의 특성에 대해 살펴보겠습니다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://rootjang92.github.io/categories/Javascript/"},{"name":"ES5","slug":"Javascript/ES5","permalink":"http://rootjang92.github.io/categories/Javascript/ES5/"}],"tags":[{"name":"Javascript, js, es5, ES5, data, datatype","slug":"Javascript-js-es5-ES5-data-datatype","permalink":"http://rootjang92.github.io/tags/Javascript-js-es5-ES5-data-datatype/"}]},{"title":"HTML 텍스트 관련된 태그들","slug":"htmltext","date":"2018-09-03T08:02:35.000Z","updated":"2018-09-04T08:15:00.000Z","comments":true,"path":"2018/09/03/htmltext/","link":"","permalink":"http://rootjang92.github.io/2018/09/03/htmltext/","excerpt":"","text":"HTML 텍스트 관련 태그들.HTML 문서를 작성할 때 가장 많이 쓰이는 태그는 무엇일까?? 바로 텍스트 관련 태그들이다.p, strong, table,em,ul,li 태그 등 꽤 많은 태그가 쓰이는 데 그 중에서 정말 자주 쓰이는 태그만 알아보자.araboza h 관련 태그HTML 문서에서 제목을 붙이고 싶을 때는 h관련 태그(제목 텍스트)를 쓰면 된다. h 태그를 사용하면 글씨가 크고 굵어진다.h1 ~ h6까지 사용 가능하다. p 태그쉽게 말하면 단락 만들기 태그이다. 단락은 앞뒤에 줄바꿈이 있는 덩어리를 말한다. br 태그줄바꿈 태그이다. 이 태그 없이 줄바꿈을 하더라도 줄이 바뀌지 않는다. (텍스트만 사용 시) hr 태그수평줄을 삽입하는 태그이다. 보통 css로 만들기 때문에 딱히 쓰이진 않지만… 실습용으로 blockquote 태그다른 사이트에서 가져온 글을 인용할 때 사용하는 태그이다. (마크다운에도 비슷한 문법이 있다.) 예제 pre 태그입력한 그대로 입력되게 해주는 태그다. 하지만 웹 표준성에 맞추기 위해 사용을 자제하는 것이 좋다. strong, b태그와 em, i 태그strong, b 태그는 텍스트를 굵게 표시하기 위해 사용된다. 둘의 차이점은 단순히 굵게 표시할떈 b태그, 강조되었다는 것을 알리기 위해선 strong 태그를 사용한다. em, i 태그는 이탤릭체로 표시되게 하는 태그이다. 둘의 차이는 단순히 표시만 하는 것은 em, 의미를 알리기 위해선 i 태그르 사용한다는 것이다. blockquote와 q 태그두 태그 모두 인용문을 사용하는 태그이지만 둘의 차이는 블록 베레이냐 인라인 레벨이냐 이다.blocakquote는 블록 레벨에 태그이기 때문에 인용 내용이 줄이 바뀌어 나타나지만, q태그는 인라인 태그이기 때문에 한 줄로 표시된다. span 태그줄 바꿈 없이 단락 안에서 텍스트를 묶을 때 사용하는 태그이다. 큰 의미는 없다. 다음 시간에는 목록만들기와 테이블 만들기를 알아보도록 하겠습니다.","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"HTML","slug":"HTML-CSS/HTML","permalink":"http://rootjang92.github.io/categories/HTML-CSS/HTML/"}],"tags":[{"name":"HTML, html, HTML basic syntax, htmltag","slug":"HTML-html-HTML-basic-syntax-htmltag","permalink":"http://rootjang92.github.io/tags/HTML-html-HTML-basic-syntax-htmltag/"}]},{"title":"Javascript 기본 개요","slug":"jsbasic","date":"2018-09-02T01:46:18.000Z","updated":"2018-09-02T02:01:24.000Z","comments":true,"path":"2018/09/02/jsbasic/","link":"","permalink":"http://rootjang92.github.io/2018/09/02/jsbasic/","excerpt":"","text":"자바스크립트 기본 개요자바스크립트는 웹 브라우저에서 동작하는 스크립트 언어이다. 처음에는 웹 페이지 제작에 보조적 역할에 한정되어 있었다.하지만 여러가지 연구와 prototype 라이브러리 개발 등 많은 발전이 있으면서 서버에서 담당하던 역할이 웹 브라우저로 옮겨졌고 결국 자바스크립트는 그 변화의 중심적인 언어가 되었다. (인사이드 자바스크립트 저:송형주, 고현준 참조) 현재 github에서 가장 많이 사용되고 있는 언어는 자바스크립트이고 Node.js의 개발로 서버 개발 또한 가능해지며 사용자가 늘고 있다. 자바스크립트는 현재 웹 개발은 물론 Node.js, express, socket.io 등을 활용한 서버 개발, 애플리케이션 개발도 가능해졌기 때문에 웹 기반 플랫폼에선 없어서는 안될 언어가 되었다. 자바스크립트 핵심 개념자바스크립트에서는 꼭 알아야 할 몇가지 핵심 개념이 있는데 앞으로 블로그를 운영하면서 차차 살펴보도록 하겠다. 객체(Object) 자바스크립트(이하 JS)의 거의 모든 것은 객체라고 할 정도로 중요한 개념이다. 자바스크립트의 기본 데이터 타입을 제외하곤 모든 것이 객체이다.하지만 null과 undefined를 제외한 모든 것을 객체처럼 다룰 수 있기 때문에 이 2가지를 제외하곤 모두 객체라고 할 수 있다. 함수 JS에선 함수도 객체이다. 함수는 특히 중요하기 떄문에 일급 객체(First class object)로 취급된다. 프로토타입 모든 객체는 프로토타입을 가진다. 분량이 상당히 많을 것으로 예상되기 때문에 뒤에서 자세히 다루겠지만, 쉽게 말해서 해당 개체를 생성한 생성자를 가리킨다고 보면 된다. 이 프로토타입으로 인해 겍체지향에 상속을 구현할 수 있게 되었다. 실행 컨텍스트와 클로저 JS는 자신만의 방법으로 실행 컨텍스트를 만들고 그 안에서 유효범위(Scope)를 갖는다. 또한 그 과정에서 클로저를 구현할 수 있다. 객체지향 프로그래밍 JS는 클래스를 지원하지 않지만(ES6에서는 함수의 형태로 만들어졌다.) 상속과 캡슐화 등의 객체지향 프로그래밍을 따라가고 있다. JS와 함수형 프로그래밍 ‘모듈화’하면 함수형 프로그래밍! JS의 일급 객체인 함수와 클로저를 활용하여 함수형 프로그래밍이 가능하게 한다. 단점 굉장히 유연한 언어의 단점은 디버깅이 힘들다는 점, 느슨한 타입 체크로 인한 컴파일 에러(런타임 에러로 이어진다.)","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://rootjang92.github.io/categories/Javascript/"},{"name":"ES5","slug":"Javascript/ES5","permalink":"http://rootjang92.github.io/categories/Javascript/ES5/"}],"tags":[{"name":"Javascript, js, es5, ES5","slug":"Javascript-js-es5-ES5","permalink":"http://rootjang92.github.io/tags/Javascript-js-es5-ES5/"}]},{"title":"HTML 기본 문서 구조","slug":"htmlbasic","date":"2018-09-02T01:03:39.000Z","updated":"2018-09-02T01:44:33.000Z","comments":true,"path":"2018/09/02/htmlbasic/","link":"","permalink":"http://rootjang92.github.io/2018/09/02/htmlbasic/","excerpt":"","text":"HTML 기본 문서 구조1. 태그HTML은 웹 문서에 마크업을 하는 언어이다. 그 때 마크업을 사용하는 약속된 표기법이 태그 이다. 태그는 &lt;&gt;를 사용한다.꺽쇠 사이에 들어가는 부분이 바로 tag 부분이다. 소문자로 쓴다.(권장사항)대,소문자를 구분하진 않지만 HTML5 표준 명세에는 소문자를 권장하고 있다. 여는 태그와 닫는 태그닫는 태그가 없는 경우도 있지만 닫는 태그가 필요한 태그에는 반드시 태그를 닫아주어야 한다. 들여쓰기.쉽게 눈으로 확인하고 문서의 구조를 파악하기가 쉬워진다. tab키를 사용한다. 속성을 파악해야 한다.태그 안에는 사용할 수 있는 속성값이 있다. 예를 들어 img 태그에는 src(주소값), width, height 등의 속성이 있다. 처음 만들어 보는 HTML 문서 문서 구조 살펴보기.&lt;!DOCTYPE html&gt; HTML5로 작성된 웹 문서라는 뜻이다. HTML4에서는 엄격모드, 호환 모드 등 꽤 복잡했지만 이젠 단 한줄이면 된다. &lt;html&gt; ~ &lt;/html&gt; 웹 문서의 시작과 끝이라고 보면 된다. 이 태그에는 lang이라는 속성에 언어를 설정해 줘야 하는데 특정 언어로 검색할 때 그 대상이 될 수 있다. &lt;head&gt; ~ &lt;/head&gt; 웹 문서를 해석하기 위해 필요한 정보들을 입력하는 곳이다. &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;내가 처음 만드는 HTML 문서&lt;/title&gt; head 태그 안에는 meta태그와 title태그가 보통 표시 되는데 화면에 보이는 것은 title 태그이다. meta 태그는 실제 문서 내용이 아닌 문서를 해석하기 위해 사용되는 태그이다. title태그에 문서 제목을 입력하는 이유는 웹 표준성과 관련되어 있다. 간혹 시각 장애를 가지고 계시는 분들이 인터넷을 이용할 때 보조 기기를 이용하는데, 제목을 듣고 이 사이트가 어떤 사이트 인지 알 수 있어야 하기 떄문이다. meta 태그 안에는 문자 인코딩 방법이나 키워드 등을 지정한다. &lt;body&gt; ~ &lt;/body&gt; 웹 문서의 실질적인 내용(화면에 나오는 내용)이 나타내는 태그이다. 대부분의 태그는 이 태그 안에 들어간다. 사이트를 이용하기 위해선 서버단에서 호스팅 서버를 준비해서 FTP 프로그램을 이용해 배포해야 한다.","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"HTML","slug":"HTML-CSS/HTML","permalink":"http://rootjang92.github.io/categories/HTML-CSS/HTML/"}],"tags":[{"name":"HTML, html, HTML basic syntax, html tag","slug":"HTML-html-HTML-basic-syntax-html-tag","permalink":"http://rootjang92.github.io/tags/HTML-html-HTML-basic-syntax-html-tag/"}]},{"title":"HTML이란?","slug":"html1","date":"2018-09-01T06:27:45.000Z","updated":"2018-09-01T07:13:00.000Z","comments":true,"path":"2018/09/01/html1/","link":"","permalink":"http://rootjang92.github.io/2018/09/01/html1/","excerpt":"","text":"HTML이란 무엇인가?우리가 흔히 보는 웹사이트의 기본은 HTML 이다. 흔히 ‘웹 문서’를 작성한다고 말하는데 이를 보는 프로그램이 바로 ‘Web browser’이다.HTML은 HyperText Markup Language의 줄임말로서 하이퍼텍스트를 마크업한는 언어다. 하이퍼 텍스트란?웹 사이트에서 링크를 클릭해 다른 문서나 사이트로 즉시 이동할 수 있는 기능. &lt;&gt;로 묶인 것은 HTML 태그라고 하고 이렇게 태그를 붙이는 것이 마크업이다. 이 꺽쇠안의 내용은 웹 브라우저 화면에 나타나지 않는다. 네이버로 들어가 [페이지 소스 보기], 혹은 검사(chrome)을 하여 documents를 살펴보자.HTML소스 엿보기 웹 표준이란?우리가 현재 사용하고 있는 HTML5를 웹 표준 기술이라고 하는데 왜 웹 표준이 필요할까?바로 ‘표준’이 필요하기 떄문입니다. 세상에는 많은 브라우저들이 있기 때문에 예를 들어 IE에서는 맞지 않고 크롬에만 맞는 사이트를 구현한다면 사용자들이 자유롭게 이용할 수 없다. 따라서 HTML5로 문서를 만드는 것은 웹 표준을 지키는 문서를 만드는 것이다. 최신 웹 표준에 맞는 웹사이트를 제작할 수 있다. 앱 화면의 기초를 디자인한다. Interactive한 사이트를 만들 수 있다. 소스를 이해하여 웹 사이트나 블로그를 쉽게 수정할 수 있다. 이로서 HTML5를 왜 사용하는 지에 대해 알아보았습니다. 다음 시간에는 HTML의 기본 문서 구조에 대해 알아보겠습니다. 이 글은 DO it! HTML5 + CSS3 웹 표준의 정석이라는 책을 인용하였습니다. thumbnail 출처 : http://knulab.com/archives/1060","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"HTML","slug":"HTML-CSS/HTML","permalink":"http://rootjang92.github.io/categories/HTML-CSS/HTML/"}],"tags":[{"name":"HTML, html","slug":"HTML-html","permalink":"http://rootjang92.github.io/tags/HTML-html/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-30T06:10:05.000Z","updated":"2018-08-30T06:10:05.000Z","comments":true,"path":"2018/08/30/hello-world/","link":"","permalink":"http://rootjang92.github.io/2018/08/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}