{"meta":{"title":"Rootjang's IT Blog","subtitle":"Geunho's IT Blog","description":null,"author":"Geun ho","url":"http://rootjang92.github.io"},"pages":[],"posts":[{"title":"JS30 - 시계만들기","slug":"js302","date":"2018-10-02T07:24:29.000Z","updated":"2018-10-02T07:25:45.000Z","comments":true,"path":"2018/10/02/js302/","link":"","permalink":"http://rootjang92.github.io/2018/10/02/js302/","excerpt":"","text":"JS와 CSS로 시계 만들기코드 설명은 추후에 만들기로… 유튜브 보기 코드 보기MyGithub","categories":[{"name":"Project","slug":"Project","permalink":"http://rootjang92.github.io/categories/Project/"},{"name":"JS30","slug":"Project/JS30","permalink":"http://rootjang92.github.io/categories/Project/JS30/"}],"tags":[{"name":"javascript,js,es6,clock","slug":"javascript-js-es6-clock","permalink":"http://rootjang92.github.io/tags/javascript-js-es6-clock/"}]},{"title":"CSS 선택자","slug":"cssselector","date":"2018-10-02T04:10:05.000Z","updated":"2018-10-02T05:10:03.000Z","comments":true,"path":"2018/10/02/cssselector/","link":"","permalink":"http://rootjang92.github.io/2018/10/02/cssselector/","excerpt":"","text":"CSS 선택자 알아보기연결 선택자combination selector라고도 부른다. 하위 선택자 : 지정한 하위 요소에 스타일 적용하기 예제 코드를 살펴보자 div p { color: blue } 여기서 div는 상위 요소 p는 하위 요소이다. 이 코드를 해석하자면 div 태그안에 있는 모든 p태그에 css 요소를 적용하겠다는 의미이다. 예제를 보면 ul태그 모두 section의 하위 요소에 속하기 때문에 모두 적용되는 것을 볼 수 있다. 자식 선택자 : 자식 요소에만 스타일 적용하기 부모 요소의 자식 요소에만 스타일을 적용하는 방법도 있다. section &gt; p { color: blue } 하위 요소 전체가 아닌 section 요소 안에 포함된 p 요소 중 자식 p요소에만 스타일을 적용하겠다는 의미이다. 여기서는 container의 자식인 첫 번째 ul요소에만 스타일이 적용된다. 인접 형제 선택자 문서 구조상 같은 부모를 가진 형제 요소 중 첫 번째 동생 요소에만 스타일을 적용할 때 사용한다. h1 + p { text-decoration: underline; } 형제 선택자 인접 형제 선택자와 달리 모든 형제 요소에 적용된다. 인접 형제 선택자에선 ‘+’ 기호를 사용했다면 형제 선택자에선 ‘~’ 기호를 사용한다. 속성 선택자 ‘[속성]’ 선택자 : 지정한 속성에 스타일 적용 특정 요소에 스타일을 적용시킨다. 대괄호 사이에 찾으려는 속성을 넣으면 된다. [속성 = 값] : 특정 값을 갖는 속성에 스타일 적용 위 예제에서 a[target=&quot;_blank&quot;] { ... } 라고 입력하면 target=”_blank”인 링크를 찾아 스타일을 적용시킨다. [속성 ~= 값] : 여러 값 중 특정 값이 포함된 소성에 스타일 적용 [속성 = 값]이 속성과 값이 정확히 일치하는 요소를 찾는다면 [속성 ~= 값]은 여러 속성 값 중 해당 값이 포함되어 있는 요소를 선택한다. [속성 |= 값] : 특정 값이 포함된 속성에 스타일 적용 이 때 값은 한 단어로 같아야 한다. 단어가 포함된 하이픈 연결 단어도 스타일이 적용된다. [속성 ^= 값] : 특정 값으로 시작하는 속성에 스타일 적용 ^는 캐럿이라고 한다. 캐럿이 붙으면 지정한 문자로 시작하는 속성 값에 대해서만 스타일을 적용시킨다. [속성 $= 값] : 특정 값으로 끝나는 속성에 스타일 적용 반대로 $는 지정한 문자로 끝나는 속성에 스타일을 적용시킨다. [속성 *= 값] : 값의 일부가 일치하는 속성에 스타일 적용 사용자가 지정한 속성 값의 위치에 관계없이 값이 포함되어 있으면 스타일이 적용된다. 가상 클래스와 가상 요소 사용자 동작에 반응하는 가상 클래스 사용자가 커서를 올린다던 지 클릭을 한다던지의 이벤트가 발생할 때 스타일이 바뀌도록 만들고 싶을 때 사용하는 것이 가상 클래스 선택자이다. :link 하이퍼링크 중 사용자가 아직 방문하지 않은 링크에 스타일을 적용한다. 기본적으로 파란줄이 표시되는 것을 없애고 싶다거나 할 때에 사용한다. :visited 링크 중 한 번 이상 방문한 링크에 대해 스타일을 적용한다. :hover 요소에 마우스 커서를 올렸을 때 스타일을 지정한다. 롤오버 효과등이 그 예이다. :active 요소를 활성화 시켰을 때 스타일을 지정하는 요소이다. :focus 요소에 초점이 맞춰젔을 때 사용한다. 아이디를 입력하기 위해 텍스트 필드로 마우스 커서를 갖다 놓았을 때 등에 사용한다. 주의할 점은 가상 클래스 선택자는 순서를 중요하게 해야한다. link, visited, hover, active 순으로 정의한다. UI 요소 상태에 따른 가상 클래스 User Interface 요소에 상태에 따른 가상 클래스는 화면 디자인할 때 상태 스타일을 지정하기 위해 사용한다. :enabled, :disabled : 요소를 사용할 수 있을 때와 없을 때 둘의 차이를 예제로 설명하자면 회원가입은 사용자가 텍스트를 작성해야 하기 때문에 enabled 상태, 약관 등은 disabled 상태로 표시해야 한다. :checked : 라디오, 체크 박스에서 항목을 선택했을 때 구조 가상 클래스 웹 문서의 구조를 기준으로 특정 위치에 있는 요소를 찾아서 스타일을 지정한다. :root 문서 전체에 적용한다. :nth-child(n) , nth-last-child(n) : 자식 요소의 위치에 따른 스타일 적용 특정 부분에 스타일을 적용하기 위해서는 보통 class나 id를 통해 이름을 붙여준다. 그러나 여러 개의 항목이 일렬로 나열되어 있다면, nth-child(n)을 사용하여 n번째 자식 요소에 스타일을 적용하거나 nth-last-child(n) 끝에서부터 n번째 자식 요소를 통해서 사용한다.an+b 처럼 수식사용도 가능하다. 조금은 어려운 개념이므로 충분한 연습이 필요하다.단, 위치에 따른 스타일 적용이기 때문에 해당 요소들이 모두 한 부모 요소를 가지고 있어야 한다. 다음 예제는 홀수 열에만 스타일을 적용시키는 예제이다. :nth-of-type(n), nth-last-of-type(n) : 특정 태그 위치에 스타일 적용하기 :first-child, :last-child : 첫번째, 마지막 자식 요소에 스타일 적용하기 :first-of-type, :last-of-type : 형제 관계 요소의 위치에 따른 스타일 적용 형제 관계 요소 중에서 첫번째, 마지막 요소에 스타일을 적용한다. :only-child, :only-of-type : 하나뿐인 자식 요소에 스타일 적용하기 부모 요소 중 자식 요소가 하나일 때 스타일을 적용한다. only-child는 다른 자식요소가 존재할 수 없고 only-of-type은 다른 자식 요소가 있어도 된다. 그 외에 가상 요소 :target : 앵커 목적지에 스타일 적용 다른 사이트로 이동할 때 링크를 이용하고, 같은 문서 안에서 다른 위치로 이동할 때에는 앵커를 사용한다. :not : 특정 요소가 아닐 때 스타일 적용 가상 요소 ::first-line, ::first-letter : 첫 번째 줄과 첫 번째 글자에 스타일 적용 ::before, ::after : 내용 앞 뒤에 콘텐츠 추가하기 요소 앞 뒤에 텍스트, 이미지 등을 표시한다.","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/CSS/"}],"tags":[{"name":"css, css3, css selector","slug":"css-css3-css-selector","permalink":"http://rootjang92.github.io/tags/css-css3-css-selector/"}]},{"title":"Javascript 30 project Day 1 - Drum kit","slug":"js301","date":"2018-10-02T02:30:29.000Z","updated":"2018-10-02T02:32:58.000Z","comments":true,"path":"2018/10/02/js301/","link":"","permalink":"http://rootjang92.github.io/2018/10/02/js301/","excerpt":"","text":"ES6로 Drum kit 제작하기이 동영상과 코드는 Javascript 30 동영상 강의를 참조하였습니다. Javascript30 동영상 보기 깃허브 링크 MyGithub","categories":[{"name":"Project","slug":"Project","permalink":"http://rootjang92.github.io/categories/Project/"},{"name":"JS30","slug":"Project/JS30","permalink":"http://rootjang92.github.io/categories/Project/JS30/"}],"tags":[{"name":"Javascript, js, es6, drum","slug":"Javascript-js-es6-drum","permalink":"http://rootjang92.github.io/tags/Javascript-js-es6-drum/"}]},{"title":"HTML 멀티 미디어","slug":"htmlmedia","date":"2018-10-01T05:10:44.000Z","updated":"2018-10-01T05:39:27.000Z","comments":true,"path":"2018/10/01/htmlmedia/","link":"","permalink":"http://rootjang92.github.io/2018/10/01/htmlmedia/","excerpt":"","text":"HTML 멀티미디어 관련 태그들과거에 사용하던 플러그인은 문제가 많았다. 확장자 지원 문제도 그렇고 원하지 않는 툴바 등이 설치되는 경우도 있었다. 하지만 최근 플래시 플레이어가 거의 차단 된 만큼, html5에도 그와 관련된 태그가 생겨났다. object 태그, embed 태그이 태그들은 사실 플러그인을 지원하는 태그이지만, 아직 html5를 지원하지 않는 브라우저를 위해 알아두면 좋다.object 태그는 자바 애플릿이나 pdf 파일 등을 웹 문서안에 포함시키기 위해 사용하는 태그이다. 다른 html 문서도 가능하다. &lt;object data=&quot;경로&quot; type=&quot;유형&quot; [name, width, height]&gt;&lt;/object&gt; 많이 사용하지 않기 때문에 여기까지만 알아보도록 하자. embed 태그는 웹 브라우저에서 재생할 수 없는 외부 파일을 삽입할 때 사용하는 태그이다. 더 오래된 태그이다. 비디오 코덱동영상 파일을 재생하기 위해 코덱이라는 용어를 많이 봤을 것이다. 그에 앞서 이 과정에서 촬영한 비디오를 압축해서 컴퓨터에서 사용할 수 있는 비디오 파일로 변환하는 과정인 인코딩이 있다면, 비디오 파일에 저장되어 있는 정보를 가져와 플레이어에 보여 주는 과정이 디코딩이다. 코덱이란 인코딩과 디코딩을 수행하는 것이다. 종료가 매우 다양하기 때문에 플레이어에선 코덱을 지원하게 되주는 파일을 지원하지만 html5에선 그게 아니기 때문에 크게 3가지 코덱을 사용하고 있다. H.264/AVCmp4 파일에 사용하는 코덱이다. 대부분 멀티미디어 업계에서 표준으로 사용하고 있는 코덱이다. v8, v9구글 오픈 소스 코덱이다. 화질이 우수하고 무료이다. 파이어 폭스, 오페라, 크롬이 이 코덱을 사용한다. Ogg TheoraH.264에 대응하는 무료 오픈 코덱이며 ogv 파일에서 사용한다. 단점은 모바일 브라우저에선 사용할 수 없다. 주로 사용하는 오디오 코덱에는 MPEG-1 AUDIO Layer3MP3 코덱이다. Ogg Vorbis오픈 소스 코덱으로 ogg, oga 확장자를 사용한다. 무료이기 때문에 PC게임에서 많이 사용한다. 단점으로는 인코딩이 오~래 걸린다. 오디오와 비디오 재생하기 audio 태그 오디오를 재생하기 위한 태그이다. &lt;audio src=&quot;경로&quot; [속성] [속성=&quot;속성 값&quot;]&gt;&lt;/audio&gt; 속성에는 autoplay, controls(컨트롤 막대 표시), loop(반복 재생), muted(소리만 끄기), preload(재생하기 전 오디오 파일 다운로드)가 있다. video 태그 비디오를 재생하기 위한 태그이다. audio 태그와 같다. source 태그 여러 미디어를 한꺼번에 지정하는 태그이다. track 태그 비디오 화면에 자막을 추가할 수 있다. &lt;track kind=&quot;자막 종류&quot; src=&quot;경로&quot; srclang=&quot;언어&quot; label=&quot;제목&quot; default&gt; kind 속성에 속성값에는 subtitles(다른 언어로 번역한 자막일 경우 사용), captions, descriptions(비디오 콘텐츠 설명), chapters(비디오 탐색을 위한 장 제목), metadata(비디오 콘텐츠 정보)","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"HTML","slug":"HTML-CSS/HTML","permalink":"http://rootjang92.github.io/categories/HTML-CSS/HTML/"}],"tags":[{"name":"html,html5, html video, html audio","slug":"html-html5-html-video-html-audio","permalink":"http://rootjang92.github.io/tags/html-html5-html-video-html-audio/"}]},{"title":"ES6의 변수와 블록 레벨 스코프","slug":"es6value","date":"2018-09-25T09:34:26.000Z","updated":"2018-09-26T08:06:06.000Z","comments":true,"path":"2018/09/25/es6value/","link":"","permalink":"http://rootjang92.github.io/2018/09/25/es6value/","excerpt":"","text":"ES6의 변수 선언과 블록 레벨 스코프요즘 핫한 JS 관련 문법은 Typescript이다. 타입 선언이 가능할 뿐만 아니라 js의 모든 문법을 사용할 수도 있고, 제네릭 등의 기타 편리한 요소가 추가되었다. 이를 익히기 위해선 기본적으로 ES6에 대한 지식이 필요하다. 그래서 오늘부터 며칠간 ES6의 기본 문법에 대해 알아보고자 한다. let, constes5의 변수 선언은 var 키워드를 통해 했었다. 하지만 var 키워드의 문제점이 있었다. 우선 함수 레벨 스코프였기 떄문에 전역 변수를 남발할 수 있었고 변수의 참조 범위에 대한 문제도 있었다. 또한 var 키워드의 생략을 허용하였기 때문에 의도치 않게 변수를 전역화 하였다. 그 외에도 중복 선언이 허용되어 의도치 않게 변수의 할당값을 변경한다던지, 변수 호이스팅으로 인해서 변수를 선언하기 전에 참조가 가능했었다.그래서 이러한 단점들을 보안하기 위해 등장한것이 let과 const이다. let var 키워드에서 변수는 함수 레벨 스코프를 가졌다. 하지만 es6에서는 let을 지원한다. 우선적으로 이들은 블록레벨 스코프를 갖는다. let foo = 123; { let foo = 456; let bar = 456; } console.log(foo); // 123 console.log(bar); // ReferenceError: bar is not defined 변수 bar는 블록 내에서만 참조할 수 있기 떄문에 에러가 발생한다. 또한 중복선언이 금지되어 있어 중복선언 시 문법 에러가 발생한다. 호이스팅 물론 let과 const 역시 호이스팅이 발생한다. 자바스크립트에서는 모든 선언을 호이스팅하기 떄문이다. var 키워드는 선언과 초기화가 한 번에 이루어진다. 그래서 스코프에 변수를 등록하고 메모리에 공간을 확보한 후 undefined 값으로 초기화한다. 그렇게 하면 변수 선언문 이전에 변수에 접근하여도 스코프에 변수가 존재하기 때문에 에러가 발생하지 않는다. 하지만 let의 경우는 조금 다르다. let의 경우는 선언과 초기화가 분리되서 진행된다. 즉 초기화가 변수 선언문에 도달했을 때 실행되기 때문에 참조에러가 발생하게 된다. 변수를 위한 메모리 공간이 확보되지 않았다는 의미이다.이것을 일시적 사각지대라고 부른다. let foo = 1; { console.log(foo); // ReferenceError let foo = 2; } 블록 안에서 foo를 호출하면 foo가 출력될 것 같지만, 참조 에러가 발생한다. ES6의 변수 선언을 블록레벨 스코프를 가지기 때문에 블록 안에서의 변수 foo는 호출당시 일시적 사각지대에 빠져있다. 클로저 아래 코드를 살펴보자. var func = []; for (var i = 0; i &lt; 3; i++) { func.push(function () { console.log(i); }); } for (var j = 0; j &lt; 3; j++) { func[j](); // 3 3 3 } 여기서 for 루프의 변수 i는 전역변수이다. 따라서 반복문에서 계속 값이 할당되고 결국 마지막 값이 남아 3번 출력되는 것이다.0,1,2를 출력하기 위해선 클로저를 사용하여야 한다. var func = []; for (var i = 0; i &lt; 3; i++) { (function (index) { func.push(function () { console.log(index); }) }(i)); } for (var j = 0; j &lt; 3; j++) { func[j](); // 0 1 2 } 여기서 인자 index가 자유변수가 된다. 즉시실행함수가 죽어도 해당 환경이 남아있기 때문에 결과값을 기억한다. 하지만 let을 사용하면 var func = []; for(let i = 0; i &lt; 3; i++) { func.push(function () { console.log(i); }); } for(let j = 0; j &lt; 3; j++) { console.dir(func[j]); func[j](); } // // [Function] // 0 // [Function] // 1 // [Function] // 2 여기서의 변수 i는 지역변수가 된다. 또한 자유변수로서 for 루프가 끝나도 변수 i를 참조하는 함수가 존재한다면 계속 유지된다. let은 전역에서 접근할 수 없다. 보통 전역 변수는 window.변수명으로 접근이 가능하지만, let은 전역 변수여도 보이지 않는 블록이 존재하기 때문에 window 키워드로 접근할 경우 undefined가 뜬다. const const도 let과 마찬가지로 변수를 선언하는 키워드이지만, const는 상수(변하지 않는 값)을 위해서 사용한다. (반드시 그런 것은 아니다.)let과 대부분 비슷하지만 그 차이점도 있다. 선언과 초기화 let은 재할당 해도 상관없지만 const는 재할당할 수 없다. 또한 const는 선언과 동시에 할당이 이루어져야 한다. 그냥 변수만 선언할 경우에 문법에러가 발생하게 된다. 상수 아래 예제를 살펴보자. (그냥 보기만 하셔도 됩니다.) if (rows &gt; 10) {} // ??? const MAXROWS = 10; if (rows &gt; MAXROWS) {} 첫 번째 문장에서는 사실 그냥 딱 보았을 때 무슨 의미인지 알기 힘들지만, const로 변수 이름을 잘 설정한다면 의미가 명확해지기 떄문에 가독성과 유지보수가 편해진다. 객체 위에서도 말했지만, const는 재할당이 금지된다. 즉 const의 타입이 객체인 경우에는 객체에 대한 참조를 변경할 수 없다.하지만 객체의 프로퍼티는 보호되지 않기 때문에 재할당은 안되지만, 할당된 내용은 변경할 수 있다. const user = { name: &apos;Lee&apos; } user.name = &apos;Jang&apos;; console.log(user) // { name: &apos;Jang&apos; } 이 의미는 할당된 주소값이 변경되지 않고 그 값 자체가 변화한다는 의미이다. 이렇기 떄문에 객체 타입에는 const가 매우 좋다. 요약 재할당이 필요하다면 let을 사용하자!ES6와 Typescript를 위해서 var 사용을 자제하자!재할당이 필요없는 타입에는 const를 사용하자!","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://rootjang92.github.io/categories/Javascript/"},{"name":"ES6","slug":"Javascript/ES6","permalink":"http://rootjang92.github.io/categories/Javascript/ES6/"}],"tags":[{"name":"javascript,js,es6,let,const","slug":"javascript-js-es6-let-const","permalink":"http://rootjang92.github.io/tags/javascript-js-es6-let-const/"}]},{"title":"HTML5 시맨틱 태그","slug":"csssemantic","date":"2018-09-25T02:13:12.000Z","updated":"2018-09-25T09:33:21.000Z","comments":true,"path":"2018/09/25/csssemantic/","link":"","permalink":"http://rootjang92.github.io/2018/09/25/csssemantic/","excerpt":"","text":"시맨틱 태그많은 웹 사이트를 분석하여 웹 문서 레이아웃의 표준화를 하는 태그가 많이 추가되었다. (물론 아직 많이 사용하진 않는다.)‘semantic’은 의미가 통한다는 의미이기 때문에 태그만 보면 ‘아 여기구나’라고 알 수 있다. 우리가 흔히 쓰는 의미 없는 상자 태그인 div 대신에 각 구역의 의미가 담긴 태그를 사용하는 것이다. HTML5의 시맨틱 태그를 사용해야 하는 이유는 웹 표준성이다. 우리가 웹 사이트의 태그를 보고 필요한 내용을 즉각 찾아낼 수 있어 편리해지고, 어떤 내용인지 바로 알 수 있기 때문이다. header : 머리말head부분이 아니고 body안에 머릿말에 들어가는 태그이다. header 부분에는 검색창이나 메뉴를 삽입한다. nav 태그 : 문서를 연결하는 네비게이션 보통 메뉴에 사용하는 태그이다. header, aside, footer 어디에든 사용 가능하다. (참조 : HTML5 &amp; CSS3 웹 표준의 정석) section : 주제별 콘텐츠 영역콘텐츠의 주제를 묶을 때 사용하는 태그이다. article : 콘텐츠 내용사전적의미로 신문이나 잡지의 기사를 뜻하는 내용이니, 일맥상통한다. 여기서는 블로그 포스트, 코멘트, 독립적인 웹 콘텐츠를 넣는다.보통 section은 문맥상 콘텐츠를 주제별로 묶을 때 사용하기 떄문에 article 태그 안에 section 태그를 넣기도 한다. aside : 본문 이외의 내용블로그나 웹 사이트의 왼쪽이나 오른쪽, 하단 사이드바를 만드는 태그이다. 문서의 메인 컨텐츠에 영향을 끼치지 않는 내용을 삽입한다. iframe : 외부 태그 삽입하기HTML, CSS란에 있는 예제태그가 모두 iframe 태그를 통해 가져온 것이다. 즉 외부 문서를 삽입하는 태그이다. footer : 제작정보, 저작권 정보 표시address : 사이트 제작 정보, 연락처 정보주로 footer 태그 안에서 사용되며 연락처 정보 등을 남긴다. div는 뭔데 그럼?div는 콘텐츠를 묶어서 css 등을 사용해야 할 때 사용합니다. (물론 주로 div로 다 한다.) 예제","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/CSS/"}],"tags":[{"name":"css,css3, css semantic tag, 시맨틱 태그","slug":"css-css3-css-semantic-tag-시맨틱-태그","permalink":"http://rootjang92.github.io/tags/css-css3-css-semantic-tag-시맨틱-태그/"}]},{"title":"표 스타일","slug":"csstable","date":"2018-09-23T03:16:25.000Z","updated":"2018-09-25T02:12:34.000Z","comments":true,"path":"2018/09/23/csstable/","link":"","permalink":"http://rootjang92.github.io/2018/09/23/csstable/","excerpt":"","text":"간단히 살펴보는 표 스타일이제 테이블이라는 태그는 많이 사용하지 않지만, 자신이 만들어야 하는 웹 페이지에 테이블이 필요하다면 ul태그나 기타 다른 태그를 사용하는 것보단 테이블 태그를 사용하는 것이 훨씬 실용적이고, 또 웹 표준성에도 맞는 방법이다. 그렇기 때문에 오늘은 표 관련 css를 살펴보려고 한다. caption-side : 표 제목 위치 표 제목은 caption 태그를 이용하는 데 그 위치를 조정하는 css 속성은 caption-side이다. top은 기본 값이며 제목이 위에 설정되도록, bottom은 제목이 아래에 오도록 하는 속성값이다. border : 표 테두리 일반 컨텐츠와 마찬가지로 border는 테두리를 지정하는 속성이다. 하지만 주의할 점은 표는 바깥 테두리와 셀 테두리를 따로 설정해주어야 한다는 점이다. border-collapse : 테두리 통합, 분리 바깥 테두리와 셀의 각 테두리를 떨어트릴지 하나로 합칠 것인지를 정하는 속성이다. collapse는 테두리를 하나로 합치는 속성값이고, separate는 테두리를 따로 표시하는 속성값이다.(이래서 영어공부를 해야한다.) border-spacing : 인접한 셀 테두리 사이 거리 지정 border-collapse : separate를 지정했을 때 인접한 셀 테두리의 거리를 지정하는 속성이다. empty-cells : 빈 셀 표시 여부 지정. 빈 셀의 표시여부를 지정할 수 있다. 속성값으로는 show와 hide가 있다. table-layout : 콘텐츠에 맞는 셀 너비 width값으로 셀 너비를 지정할 수 있지만, 영문의 경우는 그걸 무시하고 한 줄로 표시된다. 이를 지정하는 속성이 table-layout 속성이다. fixed는 너비 고정, auto는 셀의 너비가 달라진다.(기본값)","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/CSS/"}],"tags":[{"name":"css,css3,css table","slug":"css-css3-css-table","permalink":"http://rootjang92.github.io/tags/css-css3-css-table/"}]},{"title":"CSS 포지셔닝에 대해서","slug":"cssposition","date":"2018-09-22T03:32:10.000Z","updated":"2018-09-22T07:57:24.000Z","comments":true,"path":"2018/09/22/cssposition/","link":"","permalink":"http://rootjang92.github.io/2018/09/22/cssposition/","excerpt":"","text":"CSS 포지셔닝css에서 가장 중요한속성이 바로 포지셔닝이다. 이것을 이용해서 웹 문서의 레이아웃이 짜여진다고 생각하면 된다.우리가 네이버나 다음에서 보는 검색창, 광고, 로그인 창들의 위치는 모두 css로 만들고 그 배치를 하는 것이 바로 포지셔닝이다. box-sizing : 박스 너비 기준 정하기box-sizing은 박스 모델 안에 있는 콘텐츠 부분의 너비와 높이를 정하는 속성이다. 속성값에는 content-box와 border-box가 있으며 content-box는 너비의 기준이 컨텐츠이고, border-box는 콘텐츠 영역의 테두리까지 포함한다. box1의 실제 넓이는 패딩 30px border 2px 콘텐츠 너비 300px = 364pxbox2의 실제 넓이는 300px에서 패딩 30px과 테두리 2px씩 할당해서 = 236px이 된다. 더 자세히 보고 싶으면 크롬 검사에 Computed 요소를 살펴보면 더 자세히 볼 수 있다. float : 왼쪽 혹은 오른쪽float의 단어적 의미는 “뜨다”, “띄우다”이다. 즉 css에서 float는 요소를 띄어서 배치시킨다는 의미이다.즉 이미지를 어떻게 띄어서 텍스트와 함께 배치할 것인가를 나타낸다. 속성값에는 inherit(부모 요소로부터 상속),left, right, none이 있다. float에서 중요한 점은 그 원리 이다. float를 지정할 경우 필요한 너비 값을 차지하고 다른 요소가 들어올 만큼의 공간을 비워둔다. clear : float 해제하기float 속성을 적용시켜 배치하면 그 다음에 넣는 요소들에게도 같은 속성이 전달된다. 이제 그만~ 을 알려주기 위해선 clear를 사용하여야 한다. left를 무효화 할 때에는 clear:left, right는 clear:right, 상관업싱 할 떄는 clear: both를 사용하면 된다. 문서 구조 만들기 출처 사이드바나 nav의 위치가 바뀌는 것은 상관없지만 보통 웹 문서는 이러한 레이아웃 구조를 가지고 있다. position 속성position 속성은 문서 안 요소들을 자유롭게 배치하는 속성이다. 속성값에는 static(문서의 흐름에 맞춰 배치), relative(이전 요소에 자연스럽게 연결해 배치, 위치 지정 가능), absolute(원하는 위치 배정), fixed(지정한 위치에 고정) static 속성을 제외한 나머지는 좌표를 이용하여 위치를 조절할 수 있다. relative 위 예제는 원래 float 상 위치해야 될 위치에서 왼쪽으로 50px, 위에서 아래로 30px 조정되었다. absolute absolute의 기준이 되는 위치는 가장 가까운 부모 요소나 조상 요소 중 position이 relative인 속성이다. fixed 문서이 흐름과 상관없이 좌표로 결정하지만 브라우저 창이 기준이 된다. (브라우저 창 왼쪽 위 기준) visibility : 보이거나 보이지 않거나특정 요소를 보이게 하거나 보이지 않게 할 수 있다. 속성값에는 visible, hidden, collapse이 있다. z-index : 요소 쌓는 순서 정하기한 요소 위에 다른 요소를 쌓는 속성이다. z-index 값이 작을 수록 아래에 쌓이고 높을 수록 작은 요소보다 위에 쌓인다. 명시하지 않을 경우에는 웹 문서에 제일 처음 삽입하는 요소가 z-index: 1 값을 가지고 순차적으로 커진다.","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/CSS/"}],"tags":[{"name":"css, css3, css positioning, float, z-index","slug":"css-css3-css-positioning-float-z-index","permalink":"http://rootjang92.github.io/tags/css-css3-css-positioning-float-z-index/"}]},{"title":"함수형 프로그래밍이란","slug":"functionprogram","date":"2018-09-18T09:08:59.000Z","updated":"2018-09-22T03:31:37.000Z","comments":true,"path":"2018/09/18/functionprogram/","link":"","permalink":"http://rootjang92.github.io/2018/09/18/functionprogram/","excerpt":"","text":"함수형 프로그래밍사실 함수형 프로그래밍은 정말… 설명하기가 힘들다. (아직도 힘들다.) 하지만 자바스크립트에서 함수형 프로그래밍이 어떤 식으로 사용되는 지 간단하게 나마 남겨보고자 한다. 함수형 프로그래밍이 뭔데?그러게 말이다… 단순히 말하자면 함수를 조합하여 작업을 수행한다.라고 말하고 싶다. 말 그대로다 프로그램을 만들기 위해 프로그래밍을 한다면, 함수형 프로그래밍은 함수를 이용해서 프로그래밍을 하겠다는 이야기니 말이다. 중요한 점은 작업 동안에 데이터나 상태의 변화 없이 오로지 함수만 변화하고 연산의 대상이 된다는 점이다. 함수에는 외부에 아무런 영향을 끼치지 않는 순수함수와 함수를 하나의 값으로 인식하여 함수의 인자나 반환값으로 사용하는 고차함수가 있다. 자바스크립트에서의 함수형 프로그래밍자바스크립트의 함수는 일급 객체이면서 클로저를 활용할 수 있다. 암호화 예제를 자바스크립트로 표현해 보았다. var f1 = function(input) { var result; result = 1; return result; } var f2 = function(input) { var result; result = 2; return result; } var f3 = function(input) { var result; result = 3; return result; } var get_encrypted = function(func) { var str = &apos;Jang&apos;; return function() { return func.call(null, str); } } var encrypted_value = get_encrypted(f1)(); console.log(encrypted_value); var encrypted_value = get_encrypted(f2)(); console.log(encrypted_value); var encrypted_value = get_encrypted(f3)(); console.log(encrypted_value); 출력결과는 1,2,3 이다. 변수 str은 외부에서 접근이 불가능하다(영향을 끼칠 수 없다.). 또한 함수는 일급 객체이기 때문에 함수의 인자로 함수를 넘기고 결과로 함수를 반환할 수도 있다. 함수형 프로그래밍 예제 시그마 배열의 각 원소의 합을 구하는 알고리즘을 구현해보자. (코드를 보지 않고 직접 해보길 추천한다.) function sum(arr) { var len = arr.length; var i = 0, sum = 0; for (; i &lt; len ; i++) { sum += arr[i]; } return sum; } var arr = [1,2,3,4]; console.log(sum(arr)); // 10 이를 응용하여 곱셈값을 구하면, function multiply(arr) { var len = arr.length; var i = 0, result = 1; for(; i &lt; len; i++) { result *= arr[i]; } return result; } var arr = [1,2,3,4]; console.log(multiply(arr)); // 24 이를 함수형 프로그래밍을 이용해보자. function reduce(func, arr, memo) { var len = arr.length, i = 0; accum = memo; for(; i &lt; len; i++) { accum = func(accum, arr[i]); } return accum; } var arr = [1,2,3,4]; var sum = function(x, y) { return x+y; }; var multyply = function(x, y) { return x*y; }; console.log(reduce(sum, arr, 0)); // 10 console.log(reduce(multyply, arr, 1)); // 24 reduce 함수에서 함수와 배열, 기본값을 인자로 받아 넘기고 루프를 돌며 함수를 실행시킨다. 결과값은 변수 accum에 저장된다. 팩토리얼 함수형 프로그래밍을 이용해서 팩토리얼을 구현해보자. function fact(num) { if (num === 0 ) return 1; else return num * fact(num-1); } console.log(fact(10)); // 3628800 간단한 재귀함수를 통해 팩토리얼을 구현했다. 이를 함수형 프로그래밍으로 하면, (사실 그냥 하려면 이게 더 쉽지만 재사용성 등을 위해서..) var factorial = function() { var cache = {&apos;0&apos; : 1}; var func = function(n) { var result = 0; if(typeof(cache[n]) === &apos;number&apos;) { result = cache[n]; } else { result = cache[n] = n * func(n-1); } return result; } return func; }(); console.log(factorial(1)); // 1 console.log(factorial(10)); // 3628800 console.log(factorial(20)); // 2432902008176650000 변수 factorial은 cache에 접근할 수 있는 클로저를 반환받아, 캐시에 저장된 값이 있으면 곧바로 그 값을 반환하는 방식으로 만들었다. (아직도 어렵다.) 한 번 연산된 값을 cache에 저장하고 있기 때문에 중복 연산을 피할 수 있다. 피보나치 수열 메모이제이션 패턴 var fibo = function() { var cache = {&apos;0&apos; : 0, &apos;1&apos; : 1}; var func = function(n) { if (typeof(cache[n]) === &apos;number&apos;) { result = cache[n]; } else { result = cache[n] = func(n-1) + func(n-2); } return result; } return func; }(); console.log(fibo(10)); // 55 클로저를 활용하여 cache를 캐시로 활용한다. 함수형 프로그램밍의 주요함수 커링 커링이란 특정 함수에서 정의된 인자의 일부를 넣어 고정시켜, 나머지를 인자로 받는 새로운 함수를 받는 것을 의미한다. function calc(a, b, c) { return a*b+c; } function curry2(func) { var args = Array.prototype.slice.call(arguments, 1); return function() { var arg_index = 0; for (var i = 0; i &lt; args.length &amp;&amp; arg_index &lt; arguments.length; i++) if (args[i] === undefined ) args[i] = arguments[arg_index++]; return func.apply(null, args); } } var new_func = curry2(calc, 1, undefined, 4); console.log(new_func(3)); // 7 1 * 3 + 4 var new_func2 = curry2(calc, 1, 3, undefined); console.log(new_func2(5)); bind bind 함수는 특정 함수에 원하는 객체를 바인딩시켜서 새로운 함수를 사용할 때 bind 함수를 사용하는 것이다. var print_all = function(arg) { for(var i in this ) console.log(i + &quot; : &quot; + this[i]); for(var i in arguments ) console.log(i + &quot; : &quot; + arguments[i]); } var myObj = { name : &apos;Jang&apos; }; var myfunc = print_all.bind(myObj); myfunc(); // name : Jang // 2 var myfunc1 = print_all.bind(myObj, &quot;I am Jang&quot;, &quot;others&quot;); myfunc1(&quot;inside&quot;); // 0 : I am Jang, 1 : others, 2: inside // 3 console.log(print_all); // [Function: print_all] // 1 1번째는 변수 print_all의 로그값. 2번째는 myfunc라는 변수에 print_all 변수에 myObj를 바인딩한 것을 할당한 것이다.3번째는 myfun1에 3가지 인수를 바인딩해서 할당한 것이다. 반복함수 map 배열의 각 요소를 꺼내서 사용자 정의 함수를 적용시켜 새로운 값을 얻은 후, 새로운 배열에 넣는 함수이다. 이 때 원본 배열은 변형되지 않는다.즉, 배열을 순회하여 요소 값을 다른 값으로 매핑하기 위한 함수이다. var numbers = [1, 4, 9]; var roots = numbers.map(function (item) { return Math.sqrt(item); }); console.log(roots); // [1,2,3] console.log(numbers); // [1,4,9] -&gt; 원본 배열은 변하지 않는다. numbers = [1,4,9]; roots = numbers.map(function (item) { return ++item; }); console.log(roots); // [2,5,10] 또한 두 번째 인자로 this를 전달할 수 있다. function Prefix(prefix) { this.prefix = prefix; } Prefix.prototype.prefixArray = function (arr) { return arr.map(function (x) { return this.prefix + x; // 2번째 인자가 없다면 this는 전역 객체 }, this); }; var pre = new Prefix(&apos;-webkit-&apos;); var preArr = pre.prefixArray([&apos;liner-gredient&apos;, &apos;border-radius&apos;]); console.log(preArr); // [ &apos;-webkit-liner-gredient&apos;, &apos;-webkit-border-radius&apos; ] forEach 배열을 순회하며 배열의 각 요소로 주어진 인자에 콜백함수를 실행한다. 매개변수를 통해 배열 요소의 값, 인덱스, 순회할 배열을 전달받을 수 있다. for와 다른 점은 break가 없다는 점이다. 또한 forEach 역시 원본 배열을 변경하지 않는다. function Counter() { this.sum = 0; this.count = 0; } Counter.prototype.add = function (array) { array.forEach(function (entry) { this.sum += entry; this.count++; }, this); }; var counter = new Counter(); counter.add([2,5,9]); console.log(counter.count); // 3 console.log(counter.sum); // 16 filter 배열을 순회하며 각 요소의 인자로 주어진 값에서 콜백함수의 실행결과가 true인 것만 반환한다. 역시 원본 배열은 변경되지 않는다. var result = [1,2,3,4,5].filter(function (item, index, array) { console.log(&apos;[&apos; + index + &apos;] = &apos; + item); return item % 2; // 각 배열 요소, 인덱스, 순회할 배열을 인자로 받아 2로 나눴을 때 나머지가 있는 것만 반환 }); console.log(result); // [0] = 1 // [1] = 2 // [2] = 3 // [3] = 4 // [4] = 5 // [ 1, 3, 5 ] reduce 각 배열을 순회하여 콜백 함수를 적용시킨 뒤, 이전 콜백함수의 값을 누적시키는 함수이다. var result = [1,2,3,4,5].reduce(function (previouValue, currentValue, currentIndex, array) { console.log(previouValue + &apos;+&apos; + currentValue + &apos;=&apos; + (previouValue + currentValue)); return previouValue + currentValue; }); console.log(result); // 1+2=3 // 3+3=6 // 6+4=10 // 10+5=15 // 15","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://rootjang92.github.io/categories/Javascript/"},{"name":"ES5","slug":"Javascript/ES5","permalink":"http://rootjang92.github.io/categories/Javascript/ES5/"}],"tags":[{"name":"javascript, function programming, 함수형 프로그래밍, 함수형 프로그래밍 이란?","slug":"javascript-function-programming-함수형-프로그래밍-함수형-프로그래밍-이란","permalink":"http://rootjang92.github.io/tags/javascript-function-programming-함수형-프로그래밍-함수형-프로그래밍-이란/"}]},{"title":"레이아웃 관련 스타일","slug":"csslayout","date":"2018-09-18T01:41:39.000Z","updated":"2018-09-18T09:14:36.000Z","comments":true,"path":"2018/09/18/csslayout/","link":"","permalink":"http://rootjang92.github.io/2018/09/18/csslayout/","excerpt":"","text":"레이아웃 관련 스타일 태그들.결국 디자인을 위해선 레이아웃을 알아야 한다. 흔히 ‘박스 모델의 조합’이라고들 말한다. 이는 영역, 테두리, 여백들의 조합을 말한다.css를 제대로 알기 위해선 결국 레이아웃을 잘 알아야 한다. 박스모델말 그대로 박스 형태의 모델을 말한다. 이 박스들을 합쳐서 웹 문서를 만든다. 블록 레벨과 인라인 레벨 block-level은 태그를 요소에 삽입했을 때 한 줄을 차지하는 요소다. 즉 너비가 100%이다. margin, padding 등으로 크기 조정을 하기 위해서도 block-level의 요소여야 한다. 그 예로는 div, p 태그 등이 있다. 반면 in-line 요소는 화면에 표시되는 콘텐츠 만큼만 영역을 차지한다. 예로는 img나 strong 태그가 있다. 박스 형태의 컨텐츠 앞에서 본 블록 레벨의 요소들은 모두 박스 형태이다. 이 박스 형태를 잘 알고 있어야 웹 문서의 전체적인 배치 형태를 조절할 수 있다. 박스 모델은 콘텐츠 영역을 시작으로 영역과 영역 사이를 뜻하는 padding, 박스 모델의 여백을 뜻하는 margin, 박스의 테두리인 border로 구성되어 있다. 실제로 구글의 검사 탭에서 Computed 영역을 살펴보면 실제 박스모델이 어떻게 적용되어 있는지 볼 수 있다. width와 height 쉬운 영어단어 이다. 그 뜻처럼 너비와 높이를 나타내는 속성이다. 속성 값으로는 px 단위로 크기를 직접 지정할 수도 있고 백분율이다 auto를 사용할 수도 있다. width 값을 직접준 것과 백분율로 준 값을 비교해보았다. 주의할 점은 실제 콘텐츠의 크기를 계산하는 법이다. 보통 브라우저의 박스 모델 전체 너비는 width값 + 좌우 패딩 + 좌우 테두리로 계산한다. 만약 box의 너비값이 200px, 패딩값이 10px, 테두리가 5px로 지정되어 있다면 컨텐츠의 총 넓이는 230px이다. display display 속성은 원래 해당 요소가 화면에 어떻게 보일지를 지정하는 속성이다. 하지만 display 속성은 박스 모델을 변경할 수 있다. 블록 요소를 인라인 요소로, 또 인라인 요소를 블록 요소로 변경할 수 있다.display의 속성값으로는 none, contents, block, inline, inline-block, table, tabel-cell 등이 있다. block 속성 값은 해당 요소를 블록 레벨로 지정하는 요소이다. img같은 인라인 요소도 블록 요소처럼 사용할 수 있다. inline 속성 값은 블록 레벨 요소를 인라인 레벨 요소로 사용할 수 있다. 블록 레벨 요소 처럼 한 줄을 차지하지 않고 수평적으로 나열 할 수 있다. inline-block의 경우는 inline의 단점인 마진, 패딩값이 적용되지 않는다는 점을 보완해준다. 요소를 인라인 레벨로 배치하면서 내용은 블록 레벨 속성을 적용하는 것이다. none은 해당 요소를 표시하지 않는다. 이는 공간조차 차지하지 않는다는 점에서 visibility: hidden;과 차이가 있다. 테두리앞서 말했듯이 테두리는 border이다. 기본값이 none이기 때문에 테두리를 설정하기 위해서는 border 값을 지정해 주어야 한다. border의 예시이다. (poiemaweb.com 참조) border-width 속성은 테두리의 두께를 나타내는 속성이다. top, right, left, bottom 별로 지정할 수 있다. border-color 속성은 테두리의 색상을 지정한다. 각 방향별로 지정할 수 있다. border-radius 속성은 박스 모서리를 둥글게 만드는 속성이다. 이 때 크기는 직접 지정하거나 백분율을 사용할 수 있다. box-shadow 속성은 선택한 요소에 그림자 효과를 나타내는 것이다. 속성 값으로는 수평거리, 수직거리, 흐림 정도, 번짐 정도, 색상, inset(안쪽 그림자 표시)가 있다. 여백 조정 여백을 설정하는 속성에는 margin과 padding이 있다. 그 차이에 대해 살펴보자. margin : 요소 주변의 여백을 설정한다. 요소 주변에 여백을 설정하기 때문에 다른 콘텐츠와의 간격을 조절할 수 있다. 역시 방향마다 크기를 다르게 설정하 ㄹ수 있고 속성 값으로는 크기를 직접 설정할 수 있고 백분율이나 auto도 사용 가능하다. 만약 left, right의 값을 auto로 지정하면 좌우 마진을 똑같이 맞춰 가운데 정렬을 할 때 많이 사용한다. padding : 콘텐츠와 테두리 사이 여백을 설정한다. padding도 margin과 사용법은 비슷하지만 어디에 여백을 만드는지에는 차이가 있다. 예제 이 예제는 Do it! HTML5 + CSS3 웹 표준의 정석 책을 참고하였습니다.","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/CSS/"}],"tags":[{"name":"css, css3, css layout","slug":"css-css3-css-layout","permalink":"http://rootjang92.github.io/tags/css-css3-css-layout/"}]},{"title":"객체지향 프로그래밍","slug":"Programming","date":"2018-09-17T06:49:36.000Z","updated":"2018-09-22T07:42:19.000Z","comments":true,"path":"2018/09/17/Programming/","link":"","permalink":"http://rootjang92.github.io/2018/09/17/Programming/","excerpt":"","text":"객체 지향 프로그래밍객체지향이 뭔데?어려운 말이 정말 많다. 관계성 있는 객체들의 집합? 책임을 갖는 기계나 부품의 결합? 정도로 표현할 수 있겠다. (그나마 쉽게 말하면…)객체지향이라는 의미 자체를 한마디로 정의하기가 정말 힘들다. 그래서 우리는 객체지향 프로그래밍이 의미하는 바를 짚어보면서 이해해보고자 한다. 클래스 기반과 프로토타입 기반프로그래밍 언어를 자바스크립트로 처음 접한 사람은(저를 포함해서) 클래스 기반을 이해하기가 조금은 힘들 수 있다. 많은 사람들이 사용하는 Java, c++가 이에 해당하며 클래스에 정의된 메서드를 사용하여 여러가지 기능을 수행하는 언어이다. 클래스란 한 집단에 속해 있는 속성과 행위들을 정의한 것이다. 즉 클래슨느 객체 생성의 패턴이나 설계도 정도로 말할 수 있겠다. 반면 프로토타입 기반의 언어는 객체의 자료구조나 메서드 등을 동적으로 바꿀 수 있다. 즉 자바스크립트는 프로토타입 기반의 객체 지향 언어라고 할 수 있겠다. 예를 들어 객체 생성 방법만 해도 객체 리터럴, Object() 생성자 함수, 생성자 함수 등의 방법이 있다. function Person(name) { this.name = name; this.setName = function (name) { this.name = name; } this.getName = function () { return this.name; }; } var me = new Person(&apos;jang&apos;); console.log(me.getName()); me.setName(&apos;Jang&apos;); console.log(me.getName()); 출력결과 jangJang 굳이 이럴 필요는 없다.(좀 인스턴가 동일한 메서드를 각자 가지고 있어 메모리 낭비이다.) 이 함수를 프로토타입을 이용하여 바꾸면 function Person(name) { this.name = name; Person.prototype.setName = function (name) { this.name = name; } Person.prototype.getName = function () { return this.name; } }; var me = new Person(&apos;Jang&apos;); var you = new Person(&apos;Lee&apos;); var him = new Person(&apos;Park&apos;); console.log(Person.prototype); console.log(me); console.log(you); console.log(him); 출력결과 Person { setName: [Function], getName: [Function] }Person { name: ‘Jang’ }Person { name: ‘Lee’ }Person { name: ‘Park’ } setName, getName 함수를 프로토타입으로 이동시켜씩 때문에 모든 인스턴스가 참조할 수 있다. 아래 예제는 자바스크립트의 권위자인 더글라스 크락포드가 제안한 프로토타입에 객체에 메서드를 추가하는 방법이다. 참조 링크는 참조하기 /** * 모든 생성자 함수의 프로토타입은 Function.prototype이다. 따라서 모든 생성자 함수는 Function.prototype.method()에 접근할 수 있다. * @method Function.prototype.method * @param ({string}) (name) - (메소드 이름) * @param ({function}) (func) - (추가할 메소드 본체) */ Function.prototype.method = function (name, func) { // 생성자함수의 프로토타입에 동일한 이름의 메소드가 없으면 생성자함수의 프로토타입에 메소드를 추가 // this: 생성자함수 if (!this.prototype[name]) { this.prototype[name] = func; } }; /** * 생성자 함수 */ function Person(name) { this.name = name; } /** * 생성자함수 Person의 프로토타입에 메소드 setName을 추가 */ Person.method(&apos;setName&apos;, function (name) { this.name = name; }); /** * 생성자함수 Person의 프로토타입에 메소드 getName을 추가 */ Person.method(&apos;getName&apos;, function () { return this.name; }); var me = new Person(&apos;Lee&apos;); var you = new Person(&apos;Kim&apos;); var him = new Person(&apos;choi&apos;); console.log(Person.prototype); // Person { setName: [Function], getName: [Function] } console.log(me); // Person { name: &apos;Lee&apos; } console.log(you); // Person { name: &apos;Kim&apos; } console.log(him); // Person { name: &apos;choi&apos; } 상속자바스크립트는 전통적인 상속을 지원하지 않는다. 그래서 프로토타입 체인을 이용하여 상속을 구현해낸다. 즉 프로토타입을 통해서 객체가 다른 객체로 상속된다고 보면 되겠다. 방법에는 클래스 방식을 따라하는 Pseudo-classical 방식과 프로토타입 상속이 있다. 의사 클래스 상속 구현 – var Parent = (function () { function Parent (name) { this.name = name; } Parent.prototype.sayHi = function () { console.log(&apos;Hi! &apos; + this.name); }; return Parent; }()); var Child = (function () { function Child(name) { this.name = name; } // 자식 생성자 함수의 프로토타입 객체를 부모의 인스턴스로 변경 Child.prototype = new Parent(); Child.prototype.sayHi = function() { console.log(&apos;안녕하세요! &apos; + this.name); }; Child.prototype.sayBye = function() { console.log(&apos;안녕히가세요! &apos; + this.name); }; return Child; }()); var child = new Child(&apos;Jang&apos;); console.log(child); console.log(Child.prototype); child.sayHi(); child.sayBye(); console.log(child instanceof Parent); console.log(child instanceof Child); 출력결과 Parent { name: ‘Jang’ }Parent { name: undefined, sayHi: [Function], sayBye: [Function] }안녕하세요! Jang안녕히가세요! Jangtruetrue 인스턴스 child의 프로토타입 객체는 Parent 생성자 함수가 생성한 인스턴스이다. 또한 Parent 생성자 함수가 생성한 인스턴스의 프로토타입 객체는 Parent.prototype이다. 따라서 child는 Parent 생성자 함수가 생성한 인스턴스와 Parent.prototype에 있는 모든 프로퍼티에 접근할 수 있다. 여기서 sayBye() 메서드는 Parent 생성자 함수 인스턴스에 위치한다. 하지만 new 연산자를 사용하여 불필요한 객체를 계속 생성하여야 하고 new 키워드를 빼먹을 경우 this가 전역 객체에 바인딩되는 실수가 일어날 수 있다. 또한 프로토타입 객체를 인스턴스로 교체하면서 constructor가 깨지게 된다. 프로토타입 상속 그래서 결국은 자바스크립트의 프로토타입 체인을 이용한 상속을 이용하여야 한다. var Parent = (function () { function Parent(name) { this.name = name; } Parent.prototype.sayHi = function() { console.log(&apos;Hi &apos; + this.name); }; return Parent; }()); var child = Object.create(Parent.prototype); child.name = &apos;Jang&apos;; child.sayHi(); console.log(child instanceof Parent); 출력결과 Hi Jangtrue 객체리터럴로도 사용 가능하다. var parent = { name: &apos;Jang&apos;, sayHi: function() { console.log(&apos;Hi &apos; + this.name); } }; var child = Object.create(parent); child.name = &apos;kim&apos;; parent.sayHi(); child.sayHi(); console.log(parent.isPrototypeOf(child)); 출력결과 Hi JangHi kimtrue Object.create 함수는 매개변수에 프로토타입으로 설정할 객체 또는 인스턴스를 전달하고 이를 상속하는 새로운 객체를 생성한다.이 함수의 폴리필을 구현하는 함수가 있다. function create_object(o) { function F() {} F.prototype = o; return new F(); } 비어 있는 함수 F를 생성하여 그 프로토타입의 프로퍼티에 매개변수로 전달받은 객체를 넣는다. 그 후 생성자 함수 F로 새로운 객체를 생성하고 반환하는 것이다. 캡슐화캡슐화는 객체지향 프로그래밍에서 정말 중요한 개념이다. 그 정의는 필요한 여러가지 정보를 하나의 틀 안에 담는 것을 말한다.관련있는 변수와 메서드를 클래스 같은 틀 안에 담는다고 생각하면 편하겠다. 또한 외부에 공개될 필요가 없는 정보는 은닉한다.원래의 자바스크립트는 public이나 private 같은 키워드를 제공하지 않지만 캡슐화가 가능하다. var person = function(arg) { var name = arg ? arg : &apos;&apos;; // 삼항 연산자 return { getName: function() { return name; }, setName: function(arg) { name = arg; } } }; var me = person(&apos;Jang&apos;); var name = me.getName(); console.log(name); // Jang me.setName(&apos;kim&apos;); name = me.getName(); console.log(name); // kim person 함수가 객첼르 반환하면서 객체 내 메서드 getName, setName은 클로저로, private 변수에 접근할 수 있다.이것이 모듈화이며 캡슐화와 은닉 정보를 제공한다. 단 주의할 점은 private 멤버가 객체나 배열일 경우 쉽게 변경할 수 있다. 객체 반환 시 반환값은 얉은 복사를 통해서 private 멤버의 참조값을 반환하는 데 이는 외부에서도 private 값을 변경할 수 있음을 나타낸다. 이를 해결하려면 깊은 복사를 활용해야 한다. person 함수가 반환한 객체는 person 함수 객체의 프로토타입에 접근할 수 없다. = 상속을 구현하 수 없다. 위는 생성자 함수가 아니고 그냥 메서드를 담은 객체이기 때문이다. var Person = function() { var name; var F = function(arg) { name = arg ? arg : &apos;&apos;; }; F.prototype = { getName: function() { return name; }, setName: function(arg) { name = arg; } }; return F; }(); var me = new Person(&apos;Jang&apos;); console.log(Person.prototype === me.__proto__); // true console.log(me.getName()); // Jang me.setName(&apos;kim&apos;); console.log(me.getName()); // kim 객체지향 프로그래밍은 결국 재사용성,유지보수를 잘하기 위해 사용하려고 하는 것이다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://rootjang92.github.io/categories/Javascript/"},{"name":"ES5","slug":"Javascript/ES5","permalink":"http://rootjang92.github.io/categories/Javascript/ES5/"}],"tags":[{"name":"javsscript, 객체지향 프로그래밍, object oriented programming","slug":"javsscript-객체지향-프로그래밍-object-oriented-programming","permalink":"http://rootjang92.github.io/tags/javsscript-객체지향-프로그래밍-object-oriented-programming/"}]},{"title":"색상과 배경 꾸미기","slug":"cssbg","date":"2018-09-15T04:09:17.000Z","updated":"2018-09-17T06:44:20.000Z","comments":true,"path":"2018/09/15/cssbg/","link":"","permalink":"http://rootjang92.github.io/2018/09/15/cssbg/","excerpt":"","text":"색상과 배경 꾸미기색상 표현하기텍스트나 배경 등 우리가 색상을 사용하는 일은 비일비재할 정도로 많다. 웹에서도 마찬가지이다. 오늘은 색상을 표현하는 방법과 배경을 적용하는 방법에 대해서 알아보려고 한다. 16진수 표기법 ‘#’기호 다음에 알파벳이나 숫자로 색상을 표현하는 것은 16진수 표기법이라고 한다. 6자리는 앞에서부터 두자리씩 묶어 RGB(red, green, blue)를 표현한다. 예를 들어 ‘#ffff00’은 빨강과 초록은 가득 파란색은 전혀 없는 것을 의미한다. rgb와 rgba css에서 색상을 표기하는 방법 중 하나는 rgb와 rgba를 사용하는 것이다. color: rgb(255,0,0); 이렇게 작성할 경우 빨간색이 나온다. 또한 여기선 10진수를 사용하여 표기한다. 근데 rgba는 무엇일까? a는 불투명도를 나타내는 값이다. 0부터 1까지의 숫자로 사용하고 1은 완전 불투명함을 뜻한다. 0.5 대신 .5로 표시하여도 된다. hsl, hsla hsl은 hue(색), saturation(채도), lightness(밝기)를 나타내는 표시이다. a는 위와 마찬가지로 불투명도를 나타낸다. hsl(&lt;hue&gt;, &lt;saturation&gt;, &lt;lightness&gt;) 색은 3요소 중 하나로 각도 기준으로 색상을 배치한다. 0과 360도는 빨간색 120도에는 초록색, 240도에는 파란색이 배치되어 그 사이사이에 다른색들이 배치되어 있다. 채도는 %로 표시하고 0%이면 회색톤, 100%이면 무색이다. 밝기도 %로 표시하고 0%가 가장 어둡고 100%가 가장 밝다. 이름 표기법 색상을 단순히 이름으로 표기할 수도 있다. 웹 안전색상이라고 부르는 이 색상들은 기본 16가지를 포함, 모두 216가지로 표현할 수 있다. 예제 색상추출사이트 배경 색과 배경 이미지 꾸미기 background-color : 배경 색 지정 background-color 속성은 배경색을 지정할 때 사용한다. 16진수 ,rgb, 이름 표기법 모두 사용할 수 있다.주의할 점은 이 속성은 상속되지 않는다. background-clip : 배경 적용 범위 조절하기 박스 모델에 따라 적용 범위를 조절할 수 있다. 예를 들어 테두리까지 적용할지, 패딩 범위까지 적용할 지 등을 정하는 속성이다. 속성값으로는 border-box(테두리까지), padding-box(패딩까지), content-box(콘텐츠까지)가 있다. background-image : 웹 요소에 배경 이미지 넣기 이 속성은 배경에 이미지를 넣을 때 사용한다. background-image: url(‘파일경로’)을 사용하며 상대 경로 절대 경로 모두 이용 가능하다. background-repeat : 배경 이미지 반복 지정. 배경 이미지를 반복시키는 방법을 설정할 수 있다. 속성값에는 repeat(가로 세로 반복), repeat-x(창 너비와 같아질 때까지 가로로 반복), repeat-y (세로 반복), no-repeat(반복하지 않음) background-size : 배경 이미지 크기 조절 배경 이미지의 크기를 조절할 수 있다. 속성값으로는 auto, contain(요소 안에 배경 이미지가 다 들어오게 하기), cover(모두 덮도록), 크기 값, 백분율이 있다. background-position : 배경 이미지 위치 조절하기 제목이나 본문에 한 쪽에서 이미지를 표시할 경우 사용한다. left,center,right, top, bottom, 백분율, 길이 값 등을 사용할 수 있다. background-origin : 배경 이미지 배치 기준 배경 이미지가 어떻게 배칠될 지 기준을 정하는 속성이다. 속성값으로는 border-box, padding-box, content-box가 있다. background-attachment : 배경 이미지 고정하기 배경 이미지를 고정시킬 수 있따. 속성에 scroll을 사용하면 스크롤과 함께 배경이미지도 이동, fixed는 고정된다. 그라데이션종류에는 선형, 원형 그라데이션이 있다. 하지만 웹 브라우저마다 호환성이 다 다르기 때문에 접두사를 붙여줘야 한다는 불편함이 있다. 선형 그라데이션 수직, 수평 또는 대각선 방향으로 일정하게 변하게 하는 그라데이션을 말한다. line-gradient(각도 to 방향, color-stop ...) 방향은 to top, to left, to right, to bottom이 있다. 원형 그라데이션 원이나 타원 중심부터 동심원을 그리면서 바깥 방향으로 색상이 바뀐다. 위치 지정 그라데이션이 시작하는 중심도 지정할 수 있다. 주의할 점은 브라우저 접두사를 붙이는 구문에는 at 키워드를 생략해야 한다. 크기 원의 크기 또한 지정할 수 있다. closest-side 속성값은 그라데이션 가장자리가 그라데이션 중심에서 가장 가까운 요소의 모서리와 만난다. 타원일 경우 그라데이션 중심에서 가장 가까운 요소의 수평축이나 수직축과 만난다.closest-corner는 가장 가까운 코너에 닿도록 한다.farthest-side는 그라데이션 가장자리가 중심에서 가장 먼 모서리와 만나게 한다.farthest-corner는 그라데이션 가장자리가 그라데이션 중심에서 제일 먼 코너에 닿도록 한다. 색상 중지 점 원형 그라데이션에서도 색상이 바뀌는 부분을 색상 중지점이라고 하며 색상뿐 아니라 색상이 바뀌는 위치도 지정 가능하다. 그라데이션 반복 그라데이션은 패턴을 만든 후 요소를 채울 만큼 반복해서 표시할 수 있다. repeating-linear-gradient(선형 그라데이션 반복), repeating-radial-gradient(원형 그라데이션 반복)을 사용한다.","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/CSS/"}],"tags":[{"name":"css,css3,css image, css background","slug":"css-css3-css-image-css-background","permalink":"http://rootjang92.github.io/tags/css-css3-css-image-css-background/"}]},{"title":"텍스트 관련 css","slug":"csstext","date":"2018-09-14T01:35:18.000Z","updated":"2018-09-23T03:44:55.000Z","comments":true,"path":"2018/09/14/csstext/","link":"","permalink":"http://rootjang92.github.io/2018/09/14/csstext/","excerpt":"","text":"Text 관련 css오늘은 텍스트에 적용되는 스타일에 대해 알아보자. 우리가 웹 사이트를 보다 보면 가장 많은 요소 중 하나가 텍스트이다. 글꼴, 줄, 정렬 등 텍스트에도 많은 스타일 요소가 있다. 글꼴 font-family : 글꼴 지정하기 스타일 font-family는 body, p ,hn 태그 등 텍스트를 사용하는 요소들에게 사용하는 글꼴 지정 태그이다. font-family: 글꼴이름; 굴림이나 맑은 고딕 등의 이름을 넣으면 된다. 글꼴에서 중요한 것은 글꼴 자체를 시스템에 설치하여야 한다는 것이다. 기본 글꼴은 물론 적용이 되지만 그렇지 않을 경우에는 적용되지 않는다. @font-face : 웹 폰트 사용하기 css3는 웹 폰트를 표준으로 채택하여 굳이 다운로드 받을 필요 없이 사용할 수 있다. &lt;style&gt; @import url(&apos;url주소&apos;); // 소스 붙여넣기 .ng-font { font-family:&apos;Nanum Gothic&apos;, 돋움; // 웹 폰트 적용(구글 나눔 고딕) } &lt;/style&gt; &lt;p class=&quot;ng-font&quot;&gt;ddd&lt;/p&gt; 이런 식으로 사용하면 된다. 구글폰트 글꼴 저작권에 주의하여야 한다. 만약 글꼴 파일을 업로드 해서 사용한다면 @font-face를 사용해서 하면 된다. @font-face { font-family: 글꼴 이름; src:url(글꼴파일경로) format(파일 유형); } font-size : 글자 크기 조절 font-size는 글꼴을 조정하는 스타일인데 크기에는 절대 크기, 상대 크기, 백분율, 크기를 정할 수 있다. 절대 크기 xx-small, xx-large, large 등으로 지정하는 데 거의 사용하지 않는다.(주관적인 의견입니다.) 상대 크기 부모 요소의 크기를 기준으로 크거나 작게 표시할 수 있다. larger | smaller 크기 글자 크기를 직접 지정한다. 백분율 글자 크기를 %로 지정한다. 글자 크기의 단위에는 em, ex, px, pt가 있다. font-size에서 가장 많이 사용하는 것은 px이다. 픽셀 단위를 사용할 경우 폰트 크기가 고정되어 모바일 등에서 볼 때에도 크기가 고정된다. 여러 웹 표준성을 고려한다면 em단위를 쓰는 것이 가장 좋긴 하다. 부모 요소에서 지정한 폰트의 너비를 1em으로 정해놓고 상대적으로 계산하는 방법이다. 기본적으로는 body태그의 16px이 1em으로 지정된다. font-weight : 글자 굵기 normal은 기본 글자 굵기 이다. 그 외에 bold | lighter | bolder (굵게 | 더 가늘게 | 원래 굵기보다 더 굵게), 100~900 (400이 normal, 700은 bold)가 있다. font-variant : 작은 대문자 표시 소문자를 작은 대문자로 표시할 수 있다. 글을 꾸밀 때 유요하지만 잘 사용하지는 않는다. font-style : 글자 스타일 지정하기 이탤릭체 여부를 결정한다. 속성에는 italic, oblique가 있다. font : 글꼴 속성 묶어서 사용하기 font라는 스타일을 적용해서 위에 설명한 속성들을 한 번에 사용할 수 있다. 그 외에도 caption, icon, menu, message-box, small-caption, status-bar 등 각 상황에 맞는 글꼴을 표시할 수 있다. 주의할 점은 font-size와 line-height의 차이이다. 둘은 슬래시를 통해 묶어서 사용할 수 있지만, 백분율로 표시했을 때 font-size는 부모요소를 기준으로 line-height는 현재 요소의 글자 크기를 기준으로 한다. 그 외 다양한 폰트 스타일 텍스트 스타일 color : 글자 색 지정하기 색상은 16진수, rgb, rgba, hsl, hsla, 색상 이름으로 지정할 수 있다. text-decoration : 텍스트에 줄 표시하기/없애기 텍스트에 줄을 표시하거나 없앨 수 있다. 속성으로는 underline(밑줄), overline(영역 위에 선), line-through(취소 선)이 있다. text-transform : 대 소문자 변환하기 텍스트의 영문자를 대소문자로 변환시킬 수 있다. 속성으로는 capitalize(첫 글자를 대문자로), uppercase(모든 글자를 대문자로), lowercase(모든 글자를 소문자로), full-width(가능한 모든 문자를 전각문자로) 가 있다. text-shadow : 그림자 효과주기 텍스트에 그림자 효과를 주는 태그이다. text-shadow : none | &lt;가로거리&gt; &lt;세로거리&gt; &lt;번짐정도&gt; &lt;색상&gt; white-space : 공백 처리하기 white-space는 공백을 처리하는 속성이다. 속성 값에는 normal, nowrap(공백 그대로계속 한 줄 표시), pre(공백 하나로한줄 표시), pre-line(공백 하나로자동 줄바꿈), pre-wrap(공백 그대로 자동 줄바꿈)이 있다. td { white-space: nowrap; } 이럴 경우 td 속성의 모든 공백을 한 칸으로 인식하고 줄을 바꾸지 않는다. letter-spacing, word-spacing : 텍스트 간격 조절 letter-spacing은 글자 사이 간격 조절, word-spacing은 단어와 단어 사이의 간격을 조절한다. 보통 letter-spacing 속성으로 자간을 조정한다. 문단 스타일 direction : 글자 방향 지정하기 텍스트를 어느 방향부터 써 나갈 것인지 정하는 속성이다 속성값으로 ltr, rtl이 있다. ltr은 기본 값이다. text-align 속성 : 텍스트 정렬하기 왼쪽 정렬, 가운데 정렬 등 텍스트를 정렬할 때 사용하는 속성이다. 속성 값으로는 start(줄의 시작 위치에 맞춰 문단 정렬), end(텍스트 줄 끝 위치에 맞추어 문단 정렬), left, right, center, justify(양쪽에 맞추어), match-parent(부모 요소에 따라)가 있다. text-justify : 정렬 시 공백 조절 text-align의 속성값이 justify일 경우, 글자 간격이 어색해질 수 있기 때문에 이를 조정하는 속성이다. 속성값으로는 auto, none, inter-word(단어 사이 공백 조절), distribute(인접한 글자 사이 공백을 같게)가 있다. text-indent : 텍스트 들여쓰기 px나 백분율로 조정한다. 백분율은 부모 요소를 기준으로 크기를 지정한다. line-height: 줄 간격 조정하기 역시 숫자, 실제 크기, 백분율로 표시한다. 계산법은 글자 크기가 12px일 때, 줄 간격을 2.0으로 지정하면 실제 줄 간격은 24px이 된다. text-overflow : 넘치는 텍스트 표시하기 넘치는 컨텐츠를 어떻게 처리할 지 정하는 속성이다. 속성값에는 clip(자르기), ellipsis(말 줄임표 사용하기)가 있다. 단, 해당 요소의 overflow속성값이 hidden, scroll, auto이면서 white-space의 속성값이 nowrap일 경우만 적용된다. 목록 스타일 list-style-type : 목록의 불릿과 번호 스타일 지정 목록 앞에 불릿이나 번호 스타일을 지정할 수 있다. 속성 값으로는 순서 없는 목록에는 disc(원), circle(빈 원), square(사각형),none(불릿 없애기)가 있고 순서가 있는 목록에서 숫자를 바꾸고 싶은 경우 decimal, decimal-leading-zero등 여러가지 속성이 있다. list-style-image : 불릿 대신 이미지 넣기 특정 이미지 속성이 있다면 불릿을 원하는 이미지로 바꿀 수 있다. list-style-image:url(&apos;url주소&apos;); list-style-position : 목록에 들여 쓰기 효과내기 목록을 들여쓰기 할 수 있다. 속성값으로는 inside(불릿이나 숫자를 안쪽으로), outside(내어쓰기)가 있다. list-style : 위 속성 한번에 묶어 쓰기 다음 시간에는 색상과 배경에 적용하는 스타일에 대해 알아보겠습니다.","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/CSS/"}],"tags":[{"name":"css,css3,css text","slug":"css-css3-css-text","permalink":"http://rootjang92.github.io/tags/css-css3-css-text/"}]},{"title":"클로저에 대하여","slug":"closure","date":"2018-09-14T01:35:10.000Z","updated":"2018-09-14T08:20:05.000Z","comments":true,"path":"2018/09/14/closure/","link":"","permalink":"http://rootjang92.github.io/2018/09/14/closure/","excerpt":"","text":"클로저앞에서 살펴봤던 실행 컨텍스트에서 클로저에 대해 잠깐 언급했다. 실행 컨텍스트가 소멸하여도 그 환경은 남아 외부에서 참조가 가능하다고 했었지만, 사실 말도 너무 어렵고 이해하기가 어렵다.(저도 그랬습니다… 아직도 완벽하다고 보긴 어렵기도 하고…) function outFun() { var x = 1; var inFun = function() { console.log(x); }; return inFun; }; var inner = outFun(); inner(); 이 함수를 살펴보자. 함수 outFun()은 내부함수 inFun을 반환하고 소멸했다. 마지막에 함수 outFun()을 할당해준 변수를 소환해도 변수 x에는 접근할 수 없을 것 같지만 결과는 1이 나온다.이처럼 자신을 포함하고 있는 외부함수가 내부함수보다 더 오래 유지되는 경우(그 환경이) 내부함수가 노출되더라도 외부함수의 지역 변에 접근할 수 있는 것을 클로저(Closure) 라고 한다. 다른 정의로는 내부함수가 그 렉시컬 환경(선언 됐을 때 환경)의 스코프를 기억하여 자신의 선언됐을 때 환경 밖에서 호출되어도 그 환경에 접근할 수 있는 함수를 말한다. 즉 자신의 태어났을 때의 환경을 기억하는 함수라고 할 수 있다. 내부함수가 유효한 상태에서 외부함수가 종료되어 외부함수의 실행 컨텍스트가 반환되어도, 외부함수 실행 컨텍스트 내의 활성 객체는 내부함수가 참조하는 한 내부함수가 스코프체인을 통해 참조할 수 있다는 것을 의미한다.내부함수가 하나 이상 존재하는 경우 계속 유지된다. 이 때 내부함수는 외부함수의 실제 변수에 접근한다. 클로저 활용하기 전역 변수 억제 단 이 코드의 문제는 함수 increase 함수가 호출되기 전 counter의 값이 반드시 0이여야 한다는 것이다. 그렇다고 변수 counter를 increase 함수 안에 넣는다면 함수가 호출될 때마다 값이 초기화가 된다. 이 코드를 클로저를 활용해 문제를 해결하면 즉시실행함수는 한 번만 실행되기 때문에 counter가 초기화 될 일이 없다. 또한 increaser에 담겨있는 함수가 외부함수 변수 counter에 접근할 수 있다는 것이다. 또한 변수 counter는 private 변수이므로 외부에서의 변경을 신경쓸 필요가 없다. 여기서의 counter가 바로 자유변수이다. 특정 함수에 사용자가 정의한 객체 메서드 연결 예제를 살펴보면 function HelloFunc(func) { this.greeting = &apos;Helle&apos;; } HelloFunc.prototype.call = function(func) { func ? func(this.greeting) : this.func(this.greeting); } var user = function(greeting) { console.log(greeting); // Hello } var objHello = new HelloFunc(); objHello.func = user; objHello.call(); func 프로퍼티에 참조되는 함수를 call() 함수로 호출하여 func 프로퍼티에 자신이 정의한 함수를 참조시켜 호출할 수 있다.다만 greeting만을 인자로 넣어 사용하기 때문에 한 개의 인자를 받는 함수를 정의할 수 밖에 없기 때문에 function saySomething(obj, methodName, name) { return (function(greeting) { return obj[methodName](greeting,name); }); } function newObj(obj, name) { obj.func = saySomething(this, &quot;who&quot;, name); return obj; } newObj.prototype.who = function(greeting, name) { console.log(greeting + &quot; &quot; + (name || &quot;everyone&quot;) ); } var obj1 = new newObj(objHello, &quot;Jang&quot;); obj1.call(); console.log(obj1); 첫 번째로 obj.func가 실행되어 saySomething() 함수에서 반환되는 함수를 참조한다. 결국 obj1은 objHello 객체에서 func 프로퍼티에 참조된 함수만 바뀐 객체가 되기 때문에 call 함수를 사용할 수 있다. 출력결과 HelleHelle JangHelloFunc { greeting: ‘Helle’, func: [Function] } 또한 obj1.call()로 인해 실행되는 것은 실제로 newObj.prototype.who()가 된다. who를 HelloFunc에 연결할 수 있고 클로저는 saySomething()에서 반환되면 function(greeting) {}이 되어 자유변수 obj, methodName, name을 참조하게 된다. 함수 캡슐화다음 예제를 통해 자기소개를 출력해보자. var getCompleted = (function() { var buffAr = [ &apos;I am &apos;, &apos;&apos;, &apos;I live in &apos;, &apos;&apos;, &apos;. I\\&apos;m &apos;, &apos;&apos;, &apos; years old.&apos;, ]; return (function(name, city, age) { buffAr[1] = name; buffAr[3] = city; buffAr[5] = age; return buffAr.join(&apos;&apos;); }); })(); var str = getCompleted(‘Jang’, ‘Incheon’, 27); console.log(str); 변수 getComplted에 익명 함수를 즉시 실행함수로 실행시켜서 반환되는 함수를 할당하는 것이다. 여기서 반환되는 함수가 클로저가 되서 자유변수 buffAr을 스코프체인에서 참조할 수 있다. setTimeout() 첫번째로 함수 fade가 document.body를 인자로 전달받아서 호출한다. 그 후 함수 fade의 지역변수인 level이 1로 초기화가 되어 있다. step은 내부함수, 외부 함수 fade의 지역변수 level을 사용하고 level은 자유 변수다.setTimeout() 호출 후에는 fade 함수는 종료되지만, 100ms 이후에 함수 step이 호출된다.step은 지역 변수 hex를 갖고 16진수 문자열이다. fade의 배경색을 변경할 수 있다.그 후 변수 level이 15보다 작은지 확인한다. 그 후 level = 1을 증가시켜 작업을 반복한다. 실수 클로저의 프로퍼티값이 쓰기 가능하면 여러번 호출로 값이 항상 변할 수 있다. function outerFun(argNum) { var num = argNum; return function(x) { num += x; console.log(&apos;num : &apos; + num); } } var exam = outerFun(40); exam(5); // 45 exam(-5); //40 exam을 호출할 때마다 num의 값이 변한다. 하나의 클로저가 여러 함수 객체의 스코프 체인에 들어있는 경우. function func() { var x = 1; return { func1 : function(){ console.log(++x); }, func2 : function(){ console.log(-x); } }; }; var exam = func(); exam.func1(); // 2 exam.func2(); // -2 함수 호출 때마다 값이 변하므로 주의. 루프 안 클로저 활용. var arr = []; for(var i = 0; i &lt; 5; i++) { arr[i] = function() { return i; }; } for (var j=0; j &lt; arr.length; j++) { console.log(arr[j]()); } // 55555 배열 arr 안에 5개의 함수가 할당되지만 변수 i가 전역변수이기 때문에 이미 길이가 5가 된 상태이기 때문이다.이를 해결하기 위해서 var arr = []; for (var i = 0; i &lt; 5; i++) { arr[i] = (function (id) { return function() { return id; }; }(i)); } for (var j=0; j &lt; arr.length; j++) { console.log(arr[j]()); } // 01234 이런 식으로 즉시 실행 함수를 사용하여 매개변수 id를 자유변수를 만들어 반환하면 id의 값이 유지된다. 물론 ES6의 let 키워드를 사용하면 말끔히 해결된다.(일시적 사각지대가 생기기 때문에.) 다음 시간에는 객체지향 프로그래밍의 개념에 대해 알아보겠습니다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://rootjang92.github.io/categories/Javascript/"},{"name":"ES5","slug":"Javascript/ES5","permalink":"http://rootjang92.github.io/categories/Javascript/ES5/"}],"tags":[{"name":"Javascript, js, es5, closure, js closure","slug":"Javascript-js-es5-closure-js-closure","permalink":"http://rootjang92.github.io/tags/Javascript-js-es5-closure-js-closure/"}]},{"title":"실행 컨텍스트와 스코프","slug":"executioncontext","date":"2018-09-12T07:33:21.000Z","updated":"2018-09-14T01:34:51.000Z","comments":true,"path":"2018/09/12/executioncontext/","link":"","permalink":"http://rootjang92.github.io/2018/09/12/executioncontext/","excerpt":"","text":"실행 컨텍스트와 스코프실행 컨텍스트란?ECMAScript의 정의를 살펴보면 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이라고 설명하고 있다.즉 실행 가능한 자바스크립트 코드 블록이 실행되는 환경이라고 할 수 있다. 실행 가능한 코드에는 전역 코드, eval() 코드, 함수 코드가 있다. 우리는 오늘 한가지 예제를 통해 콜 스택부터 실행 컨텍스트, 스코프가 어떻게 설계되는 지에 대해 살펴보도록 하겠다. 참조사이트 var x = &apos;xxx&apos;; function foo () { var y = &apos;yyy&apos;; function bar () { var z = &apos;zzz&apos;; console.log(x + y + z); } bar(); } foo(); 이 코드에서는 스택이 쌓이고 소멸하게 된다. 실행 가능한 코드가 새로운 실행 컨텍스트 스택으로 생성된다. 이때는 후입선출(LIFO)로 진행된다. 전역 실행 컨텍스트는 처음에 만들어져 컨텍스트가 끝날 때까지 유지된다 함수 호출 시 스택이 쌓인다. 함수 호출이 끝나면 실행 컨텍스트를 파기하고 직전 실행 컨텍스트의 컨트롤을 반환한다. 실행 컨텍스트 생성과정 전역 컨텍스트의 경우전역에 선언된 전역변수와 전역 함수를 객체로 갖는다. 함수 컨텍스트의 경우활성 객체를 가리키며 매개변수와 인수들의 정보를 가지고 있는 arguments객체가 추가된다. 순서로는 우선 활성 객체를 생성한다. 그 후 arguments 객체를 생성한다. 이 떄 활성객체는 arguments 프로퍼티로 arguments 객체를 참조하게 된다. 그 후 스코프의 정보를 생성한다. 연결 리스트와 유사한 형태로 만들어지며 [[scope]] 프로퍼티로 참조된다. 그 후 변수를 생성한다. 주의할 점은 생성과 초기화만 진행할 뿐, 실행되기 전까지는 할당이 이루어지지 않는다는 것이다. 마지막으로 this를 할당하는 데 함수 호출 패턴에 따라 this가 참조하는 객체가 정해진다. 전역 코드 진입 전역 객체가 생성되면 전역 코드로 컨트롤이 진입하여 전역 실행 컨텍스트가 생성되고 실행 컨텍스트가 쌓인다. 스코프 체인 생성 및 초기화 이 때 스코프체인은 전역 객체 레퍼런스를 포함한다. 변수 객체화 여기선 매개변수가 변수 객체의 프로퍼티로 인수가 값으로 설정된다. 그 후 코드 내 함수 선을 대상으로 변수 객체가 프로퍼티로, 생성된 함수 객체가 값으로 설정되며 함수 호이스팅이 발생한다. 그 다음 대상 코드 대상으로 변수 명이 변수 객체의 프로퍼티로 undefined가 값으로 설정된다. 이를 변수 호이스팅이라고 한다. 이후 위 코드의 함수 foo가 처리된다. 함수 foo가 프로퍼티로 생성된 함수 객체가 값으로 지정된다. 이 때 생성된 함수 객체는 [[scope]] 프로퍼티를 가진다. 이 때 [[scope]] 프로퍼티는 자신의 실행환경을 가지고 자신을 포함하는 외부 함수와 실행 환과 전역 객체를 가리킨다. 또한 자신을 포함하는 외부 함수의 실행 컨텍스트가 소멸하여도 [[scope]] 프로퍼티가 가리키는 외부함수 실행환경을 참조할 수 있는데 이것이 클로저다. 이후 변수 x를 처리하는데 var 변수는 선언과 초기화가 한 번에 이루어진다. 그 후 this value를 정한다. 이전에는 this가 전역 객체를 가리키다가, 함수 호출 패턴에 이해 this가 정해진다. 함수 호출 패턴","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://rootjang92.github.io/categories/Javascript/"},{"name":"ES5","slug":"Javascript/ES5","permalink":"http://rootjang92.github.io/categories/Javascript/ES5/"}],"tags":[{"name":"js, javascript, execution context, scope","slug":"js-javascript-execution-context-scope","permalink":"http://rootjang92.github.io/tags/js-javascript-execution-context-scope/"}]},{"title":"CSS의 기초 살펴보기","slug":"cssbasic","date":"2018-09-12T02:04:28.000Z","updated":"2018-09-23T03:44:44.000Z","comments":true,"path":"2018/09/12/cssbasic/","link":"","permalink":"http://rootjang92.github.io/2018/09/12/cssbasic/","excerpt":"","text":"왜 css인가?웹 문서에 텍스트만 있다면 어떤 느낌일 것 같은가? 물론 기존 html로 기초적인 스타일링은 할 수 있지만 지금은 2018년, 4차 산업 혁명 시대 아니겠는가? css는 우리가 보는 view라는 웹 문서를 꾸미는 언어라고 보면 된다.css의 가장 큰 장점은 웹 문서를 건드리지 않고 단순히 디자인만 바꿀 수 있다.라는 정말 큰 장점이 있다. 참고할 만한 사이트 또한 웹 문서는 브라우저 기반이기 때문에 브라우저에 따라, 사용하는 기종에 따라 그 모습이 바뀐다. 스타일 형식은? ex)p{text-align: center;} p태그의 글자를 가운데로 옮기는 css 문법이다. 여기서 p는 selector(선택자), text-align은 Property(스타일 속성) center는 Property Value(속성 값) 이라고 한다. 주석 주석은 참 중요하지 않아보이지만 굉장히 중요하다. 물론 주석없이 바로바로 해석되는 게 정말 가독성이 좋은 코드라고 할 수 있지만, 모두가 그럴 순 없기에 이 코드가 어떻게 사용되었다.라는 걸 설명해 주는 것이 좋다. css의 주석은 / / 사이에 텍스트를 작성한다. 내부 스타일과 외부 스타일 css는 html문서 안에서 작성할 수도 있다. 이를 내부 스타일 시트라고 하는데 보통 head태그 안에 title밑, style ~ /style 태그 사이에 작성한다. 반면 외부 스타일 시트는 css 파일을 따로 작성하여 html 문서에서 link태그를 사용하여 연결한다. &lt;link href=&quot;파일 경로&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; 보통 외부에 css 파일을 만들어 사용하는 것이 좋은데 필요한 경우에 따라 만들어 놓은 css를 가져다 사용할 수 있기 때문이다. 또한 html 태그안에 인라인 스타일로 작성할 수도 있다. &lt;p style=&quot;color:blue&quot;&gt; 이런식으로 말이다. Selector스타일 속성을 작용하는 요소가 바로 선택자이다. 태그 하나에 지정할 수도, 여러개에 지정할 수도 있다. 전체 선택자 모든 요소에 적용할 때 사용하는 것이 전체 선택자 이다. 전체 선택자는 *를 사용한다. 태그 선택자 해당 요소에 스타일을 적용할 때 사용한다. 해당 태그가 사용된 모든 요소에 적용된다. 클래스 선택자 해당 태그에 클래스를 지정하여 그 클래스가 지정된 요소에만 스타일이 적용되게 할 때 사용한다. 사용할 때에는 ‘.’을 사용한다. 특히 클래스는 중복이 가능하기 때문에 태그를 적요하고 싶은 태그만 골라 클래스를 적용하여 스타일을 적용할 수 있다. 다른 경우도 있다. 예를 들어 h2.bluetext라고 사용한다면 h2에 있는 bluetext 클래스에만 스타일이 적용된다. 참고로 부분적으로 적용하고 싶을 때에는 span 태그를 사용하면 된다. id 선택자 클래스와 마찬가지로 특정 부분에 스타일을 적용하고 싶을 때 사용하지만, id는 중복이 허용되지 않는다. 또 다른점은 id는 #을 사용한다는 것이다. 그룹 선택자 따로따로 선언할 필요 없이 같은 스타일을 적용할 때에는 쉼표로 구분해주면 된다. Cascading캐스캐이딩의 의미는 선택자에 적용된 많은 스타일 중 어떤 스타일을 나타낼지를 결정한다는 의미이다. 스타일 간의 충돌을 막기 위해 무엇이 우선시 되어야 할 지 정하는 것이다. 그를 위해선 스타일 우선순위 스타일 상속 이 두가지 원칙에 대해서 알아야 한다. 스타일 우선순위란? 캐스캐이딩에 있어서 정말 중요한 개념이라고 할 수 있다. ‘어떤 스타일을 먼저 적용할까’를 결정하기 때문이다.첫 번째로 중요도를 살펴봐야 한다. 중요도 사용자 스타일 시트가 최우선이다. !important (다른 어떤 것보다 최우선 되는 스타일) 기본 브라우저 스타일 시트 명시도 명시도는 스타일의 적용 범위에 따라 우선순위를 정함을 말한다. 가장 중요한 것부터 말하자면 인라인 스타일 id 스타일 클래스 스타일 태그 스타일 의 순서로 중요도가 적용된다. 소스 순서 앞에 설명했던 중요도와 명시도가 같다면 먼저 온 스타일을 나중에 온 스타일이 겹친다. 위 예제에서 !important가 없다면 글자는 파란색이 될 것이다. 상속스타일은 상속된다. 웹 문서에 사용되는 태그들은 서로 포함관계에 있다. 그 중에서는 부모요소 자식요소의 관계도 포함되어 있다.자식 요소에 따로 스타일을 지정하지 않으면 부모 요소에 있는 스타일 속성이 전달된다. 이를 스타일 상속이라고 한다. 부모 요소의 배경 이미지, 배경 색 등은 상속되지 않는다. 즉 부모 요소의 모든 스타일 요소가 상속되는 것은 아니다. CSS Modulecss3참조하기 여러가지 css 규약이나 상태등을 볼 수 있다. prefix css 모듈에는 규약이 많고 아직 미완성 상태이기 떄문에 모든 브라우저에서 똑같이 적용되지 않는 경우도 있다. 또한 버전에 따라서도 지원이 되고 안되고의 차이가 있기 때문에 브라우저 접두사를 붙여서 사용한다. 이를 prefix라고 한다. -webkit- (사파리, 크롬), -moz-(모질라, 파이어폭스), -o-(오페라), -ms-(IE) -webkit-column-count:3; 앞에 접두사를 붙이고 속성을 사용하면 된다. 근데 귀찮다.(매우매우) 그래서 유용한 사이트를 소개하자면 prefix-free 에서 Only 2kb gzipped에서 js 파일을 받아 폴더에 넣어 script태그로 연결해주면 된다.","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/CSS/"}],"tags":[{"name":"css,css3,css basic","slug":"css-css3-css-basic","permalink":"http://rootjang92.github.io/tags/css-css3-css-basic/"}]},{"title":"Todo app 만들기","slug":"todo","date":"2018-09-12T01:55:37.000Z","updated":"2018-09-12T01:58:28.000Z","comments":true,"path":"2018/09/12/todo/","link":"","permalink":"http://rootjang92.github.io/2018/09/12/todo/","excerpt":"","text":"Todo 프로젝트 만들기.이 프로젝트는 ES5와 ES6를 이용하여 만들었습니다. 그 외 Angular를 활용한 코드도 깃허브에 있으니 참조하여 보시면 감사하겠습니다. 깃허브페이지","categories":[{"name":"Project","slug":"Project","permalink":"http://rootjang92.github.io/categories/Project/"},{"name":"todo","slug":"Project/todo","permalink":"http://rootjang92.github.io/categories/Project/todo/"}],"tags":[{"name":"todo,todolist,front-end","slug":"todo-todolist-front-end","permalink":"http://rootjang92.github.io/tags/todo-todolist-front-end/"}]},{"title":"프로토타입 체이닝","slug":"jsprotochain","date":"2018-09-11T05:40:20.000Z","updated":"2018-09-11T06:54:20.000Z","comments":true,"path":"2018/09/11/jsprotochain/","link":"","permalink":"http://rootjang92.github.io/2018/09/11/jsprotochain/","excerpt":"","text":"프로토타입 체이닝자바스크립트는 프로토타입 기반 객체지향 언어이다. 자바스크립트를 이해하기 위해서 무조건 알아가야 할 개념 중 하나가 이 프로토타입이다.그래서 오늘은 상속의 개념을 구현하는 프로토타입과 프로토타입 체이닝에 대해 글을 써보려고 한다. 가장 중요한 건 자신을 생성한 생성자 함수의 prototype 프로퍼티가 가리키는 프로토타입 객체를 자신의 부모로 설정하는 [[prototype]]링크로 연결한다. 이다. function Person(name) { this.name = name; } var foo = new Person(&apos;Jang&apos;); console.dir(Person); console.dir(foo); 이 코드는 그림 한장으로 설명할 수 있다. 결국 prototype 프로퍼티나 [[prototype]]은 같은 객체를 가리키고 있다는 걸 알 수 있다.즉, 객체를 생성하는 건 생성자 함수가 하지만 그 부모 역할을 하는 건 생성자의 prototype 프로퍼티가 가리키는 프로토타입 객체이다. 객체 리터럴로 생성된 객체의 프로토타입 체이닝프로토타입 체이닝이란 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티를 사용할 수 있는 것을 말한다. var myObj = { name: &apos;Jang&apos;, sayName: function() { console.log(&apos;My name is &apos; + this.name); } }; myObj.sayName(); console.log(myObj.hasOwnProperty(&apos;name&apos;)); console.log(myObj.hasOwnProperty(&apos;nickName&apos;)); myObj.sayNickname(); 출력결과 My name is JangtruefalseTypeError: myObj.sayNickname is not a function hasOwnProperty() 메서드는 호출한 객체에 인자로 넘긴 문자열 으림의 프로퍼티나 메서드가 있는지 체크하는 API 함수이다.myObj에는 name 프로퍼티가 있기 때문에 true가 출력되었다. 하지만 myObj에서 hasOwnProperty()를 사용할 수 있는 이유는 [[prototype]] 링크로 연결된 Object.prototype 객체에 hasOwnProperty() 메서드가 존재하기 때문이다. 결국 프로토타입 체이닝은 해당 객체에 접근하려는 프로퍼티나 메서드가 없다면 [[prototype]]링크를 따라서 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티를 차례대로 검색하는 것을 말한다. 생성자 함수로 생성된 객체의 프로토타입 체이닝function Person(name, age, hobby) { this.name = name; this.age = age; this.hobby = hobby; } var foo = new Person(&apos;Jang&apos;, 27, &apos;Soccer&apos;); console.log(foo.hasOwnProperty(&apos;name&apos;)); console.dir(Person.prototype); 출력결과 truePerson {}(Object) Person() 함수가 생성한 foo 객체의 프로토타입 객체는 Person.prototype이 된다. 하지만 Person.prototype에는 hasOwnProperty 메서드가 없다. 하지만 결과값은 true가 나오는데 그 이유는 프로토타입 체이닝의 종점인 Object.prototype 객체에 존재하기 떄문이다.Person.prototype 역시 객체이기 때문에 Object.prototype을 프로토타입 객체로 가진다. 기본 데이터 타입 확장숫자, 문자열, 배열 등이 사용하는 표준 메서드는 그들의 프로토타입에 정의되어 있다. 또한 기본 내장 프로토타입도 Object.prototype을 자신의 프로토타입으로 가지고 있다.(알면 알수록 놀랍습니다…) 또한 자바스크립트는 표준 빌트인 프로토타입 객체에도 사용자가 직접 정의한 메서드를 추가할 수 있다. String.prototype.testMethod = function() { console.log(&apos;Testing method in String.prototype.testMethod()&apos;); }; var str = &quot;this is test&quot;; str.testMethod(); console.dir(String.prototype); 출력 결과 Testing method in String.prototype.testMethod(){ [String: ‘’] testMethod: [Function] } 구글 크롬의 브라우저 출력화면을 보면 다양한 메서드가 쭉 나오는데 testMethod가 추가된 것을 볼 수 있을 것이다.(꼭 해보시길!) 프로토타입 메서드와 this앞에서 봤던 객체의 메서드를 호출할 때 this바인딩의 규칙과 같다. 그 메서드를 호출한 객체에 바인딩 된다. 디폴트 프로토타입디폴트 프로토타입은 한 마디로 함수가 생성될 때 같이 생성된다. 자바스크립트에서는 이러한 디폴트 프로토타입을 다른 일반 객체로 변환할 수 있다.단, 변경된 시점에서 생성된 객체들은 변경된 프로토타입 객체로 [[prototype]] 링크를 연결한다. function Person(name) { this.name = name; } console.log(Person.prototype.constructor); // 1 var foo = new Person(&apos;Jang&apos;); console.log(foo.country); // 2 Person.prototype = { country : &apos;Republic of Korea&apos; }; console.log(Person.prototype.constructor); //3 var bar = new Person(&apos;Lee&apos;); console.log(foo.country); //4 console.log(bar.country); //5 console.log(foo.constructor); //6 console.log(bar.constructor); //7 출력결과 [Function: Person] // 1undefined // 2[Function: Object] // 3undefined // 4Republic of Korea // 5[Function: Person] // 6[Function: Object] // 7 2번을 살펴보자 foo 객체에는 country 프로퍼티가 없고 Person.prototype객체도 마찬가지이다. 체이닝이 일어나도 결국 undefined3번을 살펴보자 country라는 프로퍼티를 가진 객체로 변화시켰다. 그 결과로 이 객체에는 constructor가 존재하지 않는다. 일반 객체로 변화했기 때문이다. 일반 객체는 Object.prototype 객체로 프로토타입 체이닝이 발생하고 그 결과 그 constructor는 Object로 출력된다.또한 생성된 bar 프로퍼티도 새로 변경된 프로토타입 객체를 가리킨다. 그렇기 때문에 서로 다른 결과값이 발생하는 것이다. 주의할 점프로토타입은 특정 프로퍼티를 읽거나, 메서드를 실행할 때 발생한다. 다른 객체에 있는 특정 프로퍼티를 쓰려고 할 때에는 프로토타입 체이닝이 동작하지 않고 동적으로 프로퍼티를 생성한다. function Person(name) { this.name = name; } Person.prototype.country = &apos;Republic of Korea&apos;; var foo = new Person(&apos;foo&apos;); var bar = new Person(&apos;bar&apos;); console.log(foo.country); console.log(bar.country); foo.country = &apos;USA&apos;; console.log(foo.country); console.log(bar.country); 출력결과 Republic of KoreaRepublic of KoreaUSARepublic of Korea foo.country 값에 ‘USA’를 지정하면 foo 객체 자체에 country 프로퍼티가 동적으로 생성된다. 그래서 bar 객체는 프로토타입 체이닝을 거쳐 ‘Republic of korea’가 출력된다. 다음 시간에는 실행 컨텍스트와 클로저에 대해 알아보겠습니다!","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://rootjang92.github.io/categories/Javascript/"},{"name":"ES5","slug":"Javascript/ES5","permalink":"http://rootjang92.github.io/categories/Javascript/ES5/"}],"tags":[{"name":"Javascript, JS prototype, prototype chain","slug":"Javascript-JS-prototype-prototype-chain","permalink":"http://rootjang92.github.io/tags/Javascript-JS-prototype-prototype-chain/"}]},{"title":"Input 태그","slug":"htmlinput","date":"2018-09-10T06:30:48.000Z","updated":"2018-09-11T05:39:27.000Z","comments":true,"path":"2018/09/10/htmlinput/","link":"","permalink":"http://rootjang92.github.io/2018/09/10/htmlinput/","excerpt":"","text":"태그Input 태그란?Input 태그는 기본적으로 입력 항목을 만드는 태그다.체크박스 등의 클릭하는 버튼도 input 태그를 활용해 만든다.원래는 form 태그 안에 속해야 하지만 ajax통신에서는 그러지 않아도 된다. id 속성을 사용하면 label 태그를 사용할 수 있다. Input 태그의 type 속성에 사용 하는 유형.input type태그속성 하지만 브라우저마다 지원이 다르기 때문에 이 사이트를 참조하여 얼마나 지원하는 지 알아보면 좋다. 브라우저지원확인 Input 태그 사용하기. type=”hidden”히든필드는 관리자가 알아야 할 정보를 입력할 때 사용합니다. 그렇기 떄문에 사용자에게는 보이지 않는다.(view상에서) type=”text”텍스트 필드를 만들 때 사용한다. 폼에서 가장 많이 사용한다고 볼 수 있다. &lt;input type=”text” [속성=”속성값”]&gt; 속성에는 name, size(필드 길이 지정), value(화면에 표실될 내용), maxlength(최대 길이)가 있다. type=”password”비밀번호를 입력하는 창을 만들 때 사용한다. &lt;input type=”password” [속성=”속성값”]&gt; type=”search”,”url”,”email”,”tel” 각각, 검색 상자, URL 입력, 메일 주소 입력, 전화번호 입력 창을 만들 때 사용한다. type=”number” 사용자가 입력한 내용을 숫자로 인식하는 창이다. 스핀 박스를 사용해 갯수를 조정할 수 있다. type=”range” 슬라이드 막대로 범위를 지정할 수 있다. 이 속성은 브라우저 지원 버전을 확인 후 사용하여야 한다. number, range모두 min,max,step(짝수,홀수 등 특정 숫자 지정),value 속성을 사용할 수 있다. type=”radio”, “checkbox” 라디오 버튼과 체크박스 버튼을 생성한다. 이 둘은 여러항목 중 자신이 원하는 항목을 선택할 때 사용한다.한 개만 선택할 경우 라디오 버튼, 중복 체크가 가능하도록 할 때는 체크박스 버튼을 사용한다. 속성으로는 name, value, checked(기본으로 선택해 놓을 화면) 속성이 있다. type=”color” 색상을 선택할 수 있게 창을 만들어준다. 색상은 16진수로 표시되기 때문에 텍스트로 색상을 선택할 수는 없다. &lt;input type=&quot;color&quot; value=&quot;기본색&quot;&gt; type=”date”, “month”, “week” 날짜를 표시하는 속성이다. &lt;input type=&quot;date | month | week&quot; [value=&quot;기본값&quot; 속성=&quot;속성값&quot;]&gt; date로 지정하면 yyyy-mm-dd 형식으로 month는 yyyy-mm, week는 yyyy-w24로 표시된다. type=”time”,”datetime”,”datetime-local” 시간 지정하는 속성이다. 시간을 지정할 때는 time, 날짜와 시간은 datetime,datetime-local을 사용하면 된다.min,max,step,value를 사용할 수 있다. type=”submit”,”reset” 서버 전송과 리셋하기 버튼이다. submit은 서버로 전송하는 버튼으로 form태그에서 지정한 폼 처리 프로그램에 넘겨진다. type=”image” submit버튼 대신 전송 이미지를 넣을 수 있다. type=”button” 폼 안에 버튼 형태를 만들 수 있다. 스크립트 함수를 넣어서 사용하여야 한다. type=”file” 파일을 첨부할 수 있다. Input 태그 속성들 autofocus 원하는 요소에 입력 커서를 표시할 수 있다. placeholder 텍스트를 입력할 때 힌트를 표시할 수 있다. 필드안에 그 속성에 어떠한 값을 입력해야 하는 지 알려줄 수 있다. readonly 읽게만 만드는 창을 만들 때 사용하는 속성이다. true, false값을 지정해도 되고 readonly=”readonly”라고 적어도 된다. required 속성 필수적으로 입력하여야 하는 곳에 사용한다. min,max,step 속성 최솟값, 최대값, 허용 범위를 설정한다. size,minlength,maxlength 텍스트 길이, 최솟값, 최대값을 설정한다. 실습(상품 주문서 만들기) 이 예제는 Do it! HTML5 + CSS3 웹 표준의 정석 책을 참고하였습니다.","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"HTML","slug":"HTML-CSS/HTML","permalink":"http://rootjang92.github.io/categories/HTML-CSS/HTML/"}],"tags":[{"name":"html, html input","slug":"html-html-input","permalink":"http://rootjang92.github.io/tags/html-html-input/"}]},{"title":"함수의 this","slug":"jsfuncthis","date":"2018-09-10T05:15:07.000Z","updated":"2018-09-10T06:29:54.000Z","comments":true,"path":"2018/09/10/jsfuncthis/","link":"","permalink":"http://rootjang92.github.io/2018/09/10/jsfuncthis/","excerpt":"","text":"thisthis arguments 객체자바스크립트는 인자의 갯수를 달리해도 오류가 발생하지 않는다. 넘겨지지 않은 인자는 undefined, 갯수가 많을 경우에는 무시된다.이렇기 때문에 런타임 시 인자의 갯수를 확인하여 동작을 다르게 해줘야 하는데 이를 가능하게 하는 것이 arguments 객체이다. function add(a,b) { console.dir(arguments); return a+b; } console.log(add(1)); console.log(add(1,2)); VM156:2 Arguments(1)0: 1 callee: ƒ add(a,b) length: 1 Symbol(Symbol.iterator): ƒ values() __proto__: Object VM156:6 NaN VM156:2 Arguments(2) VM156:7 3 arguments는 유사 배열 객체이기 때문에 length를 가지고 있다. 이를 활용한 함수를 구현하자면… 예시ㅡ function sum() { var res = 0; for(var i = 0; i &lt; arguments.length; i++) { res += arguments[i]; } return res; } console.log(sum(1)); console.log(sum(1,2,3,4,5,6,7,8,9)); 출력결과 145 this 바인딩자바스크립트의 this는 타 언어와 달리 함수 호출 패턴에 따라 this가 참조하는 객체가 달라진다. (후…) 객체 메서드 호출 시 this 이 떄에는 해당 메서드를 호출한 객체로 바인딩 된다. var myObj = { name: &apos;Jang&apos;, sayName: function() { console.log(this.name); } }; var Obj = { name: &apos;Geun&apos; }; Obj.sayName = myObj.sayName; myObj.sayName(); // 1 Obj.sayName(); // 2 출력결과 JangGeun 우리는 sayName()이 호출되는 지점을 봐야 한다. 이 메서드의 this는 자신을 호출한 객체로 바뀌기 때문에 1에서는 Jang이 2에서는 Geun이 출력되는 것이다. 함수를 호출할 때 this 이 때의 this는 전역 객체에 바인딩 된다. (브라우저의 경우 window 객체, 런타임 환경의 경우 global) var test = &apos;test&apos;; console.log(window.test); var sayBar = function() { console.log(this.test); }; sayBar(); 출력결과 testtest test 변수는 전역 변수이기 때문에 window로 접근이 가능하다. 또한 sayBar 함수에서 this는 전역을 가리키기 때문에 window에 바인딩되어 test가 호출된다. var num = 100; var myObj = { num: 1, func1: function() { this.num += 1; console.log(&apos;func1() called. this.num : &apos; + this.num); // func2 func2 = function() { this.num += 1; console.log(&apos;func2() called. this.num : &apos; + this.num); } func2(); } }; myObj.func1(); 출력결과 func1() called. this.num : 2func2() called. this.num : 101 우리가 생각했던 방식은 부모 요소의 객체와 같은 거라고 예상했기에 2,3이 떠야 하지만 결과는 2와 101이 떴다. 그 이유는 내부 함수의 호출 패턴을 지정하지 않았기 때문이다. 내부 함수의 this는 전역 객체에 바인딩되기 때문에 부모 함수의 this를 다른 변수에 저장해야 한다. var num = 100; var myObj = { num: 1, func1: function() { var that = this; this.num += 1; console.log(&apos;func1() called. this.num : &apos; + that.num); // func2 func2 = function() { that.num += 1; console.log(&apos;func2() called. this.num : &apos; + that.num); } func2(); } }; myObj.func1(); 출력결과 func1() called. this.num : 2func2() called. this.num : 3 this를 that 변수에 저장하여 내부함수가 부모 함수의 변수에 접근이 가능하게 만들었다. 생성자 함수 호출 시 this 복습하자면 생성자 함수는 기존 함수에 new 연산자를 붙이는 방법이다. 또한 함수 이름 첫 글자를 대문자로 쓰기를 권한다. 많은 책이나 블로그에서 중요하게 여기는 것이 생성자 함수의 this바인딩을 이해하기 위해선 생성자 함수의 동작 방식을 이해해야 한다고 설명하고 있다. 빈 객체 생성 및 this 바인딩이 빈 객체가 this로 바인딩 된다. 단 이 생성자 함수가 생성한 객체는 생성자 함수 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체로 설정한다. this를 통해 프로퍼티 생성this를 사용해서 생성된 빈 객체에 동적으로 프로퍼티나 메서드를 생성할 수 있다. 생성된 객체 리턴일반적으로는 this에 바인딩된 새롭게 생성된 객체가 리턴된다.(일반 함수에서는 undefined) 그러나 다른 객체를 반환한다면 해당 객체가 리턴된다. var Person = function (name) { this.name = name; }; var foo = new Person(&apos;Jang&apos;); console.log(foo.name); 출력 결과 Jang Person() 생성자 함수가 빈 객체를 생성하며 Person.prototype을 [[prototype]]링크로 연결하여 자신의 프로토타입으로 설정한다.그러면서 this에 name이라는 동적 프로퍼티를 생성하여 리턴을 받환하여 foo 변수에 저장한다. 객체 리터럴 방식과 생성자 함수의 차이점. 둘의 가장 큰 차이점은 바로 프로토타입 객체다. 객체 리터럴은 Object(), 생성자 함수는 생성자함수 이름이 프로토타입 객체가 된다.그 이유는 둘의 생성자가 다르기 때문이다. 객체 리터럴의 경우 생성자가 Object()이기 때문이다. call과 apply 메서드를 사용한 this 이 방법은 명시적으로 this를 바인딩시키는 방법이다. 단 이 메서드들은 Function.prototype 객체의 메서드이다. function.apply(thisArg, argArray) 주의할 점은 결국 apply() 메서드를 호출하는 것은 함수이고, 본질적인 기능이 함수 호출이라는 점이다. 첫번째 인자는 this에 바인딩할 객체를 가리키고 두 번째 인자는 함수를 호출할 때 넘길 인자들의 배열을 가리킨다. function Person(name, age, gender) { this.name = name; this.age = age; this.gender = gender; } var foo = {}; Person.apply(foo,[&apos;Jang&apos;, 27, &apos;man&apos;]); console.dir(foo); Object age: 27 gender: “man” name: “Jang” proto: Object 결론적으로 이 코드는 Person(‘Jang’,27,’man’) 함수를 호출하여 this를 foo 객체에 명시적으로 바인딩한 것이다. 이들을 활용하는 것의 장점은 유사 배열 객체에 배열 메서드를 사용하는 경우에 나타난다. function myFunction() { console.dir(arguments); // arguments.shift(); -&gt; error var arg = Array.prototype.slice.apply(arguments); // Array.prototype.slice() 메서드를 호출하고 this는 arguments객체에 할당해라. console.dir(arg); } myFunction(1,2,3); 출력결과 [Arguments] { ‘0’: 1, ‘1’: 2, ‘2’: 3 }[ 1, 2, 3 ] 함수 리턴함수는 항상 리턴값을 반환한다. 라는게 포인트이다. 만약 리턴문이 없다면 undefined값이 리턴된다. 생성자 함수에서 리턴값을 지정하지 않으면 생성된 객체가 리턴된다. 생성자 함수에서 별도의 리턴값을 지정하지 않으면 this에 바인딩된 객체가 리턴되기 때문에 일반적으로 리턴문을 사용하지 않는다.만약 명시적으로 리턴값을 지정한다면 객체 외에 경우에는 리턴값을 무시하지만 객체를 지정할 경우 그 객체가 반환된다. 다음 시간에는 프로토타입 체이닝에 대해서 알아보겠습니다~!","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://rootjang92.github.io/categories/Javascript/"},{"name":"ES5","slug":"Javascript/ES5","permalink":"http://rootjang92.github.io/categories/Javascript/ES5/"}],"tags":[{"name":"Javascript, js, js this, this, prototype chain","slug":"Javascript-js-js-this-this-prototype-chain","permalink":"http://rootjang92.github.io/tags/Javascript-js-js-this-this-prototype-chain/"}]},{"title":"자바스크립트의 함수","slug":"jsfunction","date":"2018-09-09T06:52:11.000Z","updated":"2018-09-10T05:16:30.000Z","comments":true,"path":"2018/09/09/jsfunction/","link":"","permalink":"http://rootjang92.github.io/2018/09/09/jsfunction/","excerpt":"","text":"함수란?함수자바스크립트에서 가장 중요한 것이 무엇이냐고 했을 때 십중팔구는 함수를 이야기 할 것이다. 자바스크립트의 함수는 모듈화, 클로져, 객체 생성, 함수형 프로그래밍 지향에 있어서 정말 중요한 개념이고 잘 이해하여야 한다.(그런 의미에서 나는 아직 멀었다.) 함수의 생성방법함수 생성방법은 객체 생성방법과 비슷하게 3가지가 있다. 함수 선언문, 함수 표현식, Function() 생성자 함수 이 세가지 이다. 함수 리터럴 계속 강조하지만 함수도 결국 객체이다.(일급 객체라서 중요하다!) 그렇기 때문에 함수 리터럴 방식이 존재한다. function multiply(x,y) { return x * y; } 함수 키워드, 함수 명, 매개변수 리스트로 구성되어 있다. 함수 선언문 함수 리터럴과 형태는 같지만 주의할 점은 반드시 함수명이 있어야 한다는 점이다. function multiply(x,y) { return x * y; } console.log(multiply(3,4)); 출력결과 12 함수 표현식 함수 표현식은 함수 리터럴로 함수를 생성하여 생성된 함수를 변수에 할당하는 형태이다. var mul = function (x,y) { return x * y; } console.log(mul(3,4)); 출력결과 12 이렇게 이름이 없는 함수 형태를 익명함수라고 부른다. 즉 변수 mul을 통해 함수를 할당한 것을 익명 함수를 이용한 함수 표현식이라고 한다.위 예제는 기명 함수 표현식으로도 가능하다. 다만 함수 표현식에서 사용된 함수 이름은 외부 코드에서의 참조가 불가능하다. 이를 활용해서 팩토리얼 함수를 만들어 보도록 하자. var factorial = function factorial(n) { if ( n &lt;= 1) { return 1; } return n * factorial(n-1); } console.log(factorial(3)); console.log(factorial(1)); 출력결과 61 이는 재귀 호출을 이용한 방법으로 함수를 선언한 후 함수 내부에서 재귀호출하여 함수를 처리하였다. Function() 생성자 함수 자바스크립트의 함수도 결국 Function()이라는 내장 생성 함수에서 생성된 것이다. (축약 표현일 뿐이다.) var add = new Function(&apos;x&apos;, &apos;y&apos;, &apos;return x + y&apos;); console.log(add(3,4)); 출력결과 7 함수 호이스팅자바스크립트의 권위자 인 더글라스 크락포드는 함수 생성에서 함수 표현식만을 사용할 것을 권하고 있는 데 그 이유가 바로 호이스팅 때문이다. // 함수 호이스팅으로 인한 호출 가능. var res = square(5); function square(number) { return number * number; } // TypeError var res = square(5); var square = function(number) { return number * number; } 함수 표현식은 변수 호이스팅이 발생하기 때문에 함수 호이스팅 처럼 변수생성, 초기화, 할당이 한 번에 일어나는 것이 아니라 변수 호이스팅 처럼 생성과 초기화만 동시에 일어난다.결론적으로 함수 호출 전에는 반드시 함수를 선언하여야 한다. 함수 = 객체자바스크립트의 함수는 결국 객체이기 떄문에 일반 객체처럼 프로퍼티들을 가질 수 있다. 그렇기 때문에 위에서 설명한 것처럼 리터럴에 의한 생성, 변수나 배열 요소, 객체 프로퍼티 할당 가능, 함수의 인자로 전달 가능, 함수의 리털값으로 사용 가능, 동적으로 프로퍼티 생성 및 할당 가능 등 객체와 똑같이 적용된다. 위에 나열한 기능이 모두 가능하기 때문에 함수를 일급 객체라고 부르는 것이다. 변수나 프로퍼티에 할당. 함수도 변수나 프로퍼티에 할당할 수 있다. var foo = 100; var bar = function() { return 100; }; console.log(bar()); var obj = {}; obj.baz = function () { return 200; }; console.log(obj.baz()); 출력결과 100200 함수 인자로 전달. 다른 함수의 인자로 전달 가능하다. var foo = function(func) { func(); }; foo(function() { console.log(&apos;kkk&apos;); }); 출력결과 kkk 리턴값으로 활용 다른 함수의 리턴값으로도 활용할 수 있다. var a = function() { return function() { console.log(&apos;apple&apos;) }; }; var b = a(); b(); 출력결과 apple 변수 b에 함수 a를 호출하면 리턴값으로 전달되는 함수가 b 변수에 저장되어 apple이 출력된다. 기본 프로퍼티 정말 중요하다. 함수는 객체다. (일급객체) 또한 함수 객체만의 프로퍼티를 가지고 있다. 크롬 검사도구에서 함수를 살펴보면 arguments,caller, length 등과 같은 프로퍼티가 보인다는 것을 알 수 있다. (console.dir로 호출해 보시길)또한 객체이기 때문에 prototype을 갖는다. 함수 객체의 프로토타입은 Function.prototype 객체이다. prototype과 [[prototype]] 이 둘은 많이 헷갈릴 수 있는 개념이다. 하지만 둘은 엄연히 다른 개념이다. 물론 두 프로퍼티가 모두 프로토타입 객체를 가리킨다. 하지만 보는 관점에서 차이가 있다. [[prototype]]객체 입장에서 자신의 부모 역할을 수행하는 프로토타입 객체를 가리킨다. prototype함수가 생성자일 때 함수를 통해 생성된 객체의 부모 역할을 하는 개체를 가리킨다. 그래서 함수를 생성할 때 만들어지고 constructor 프로퍼티 하나만 있는 객체를 말한다. 함수 형태 콜백 함수익명 함수가 사용되는 대표적인 용도가 콜백함수이다. 콜백 함수는 어떤 이벤트가 발생했을 때 시스템에서 호출되는 함수이다.대표적인 예로 이벤트 핸들러 처리가 있다. 즉시 실행 함수Immediate function은 정의와 동시에 출력되는 함수이다. (function (name) { console.log(&apos;welcome -&gt; &apos; + name); })(‘Jang’); 출력결과 welcome -&gt; Jang 즉시시행함수는 바로 시행되지만 다시 호출할 수 없기 때문에 한 번만 실행하는 초기화 실행 같은 코드에 적합하다.(추후에 즉시실행함수에 대해 한 번 다뤄보도록 하겠습니다.) 내부 함수자바스크립트 함수는 내부에서도 함수를 정의할 수 있다. 이를 내부함수라고 한다. function parent() { var a = 100; var b = 200; function child() { var b = 300; console.log(a); console.log(b); } child(); } parent(); child(); 출력결과 100300ReferenceError: child is not defined 100이 출력되는 이유는 스코프 체이닝에 의해서 child함수의 부모인 parent 함수에서 변수 a의 값을 찾았기 때문에 가능한 것이다.또한 내부 함수는 자신을 둘러싼 외부 함수에서 접근이 가능하지만 그 내부에서만 호출이 가능하기 때문에 레퍼런스 에러가 발생했다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://rootjang92.github.io/categories/Javascript/"},{"name":"ES5","slug":"Javascript/ES5","permalink":"http://rootjang92.github.io/categories/Javascript/ES5/"}],"tags":[{"name":"js, javascript, javascript function, 자바스크립트 함수","slug":"js-javascript-javascript-function-자바스크립트-함수","permalink":"http://rootjang92.github.io/tags/js-javascript-javascript-function-자바스크립트-함수/"}]},{"title":"Form 태그에 대하여","slug":"htmlform","date":"2018-09-09T06:15:24.000Z","updated":"2018-09-09T06:51:32.000Z","comments":true,"path":"2018/09/09/htmlform/","link":"","permalink":"http://rootjang92.github.io/2018/09/09/htmlform/","excerpt":"","text":"HTML 폼 태그에 대하여폼 태그란 특정 형식에 사용자가 무언가를 입력하는 형태로 이루어져 있다. 로그인이나 회원가입 창이 그 예이다.웬만한 페이지에서는 형식에 구해받지 않고 이런 폼 태그를 볼 수 있다. 우리가 많이 사용하는 SNS에서도 회원가입을 하기 위해서 입력하는 정보들도 폼이다. 로그인을 예로 들면 우리가 클라리언트에서 정보를 입력하여 서버로 보내면 그 서버에서 DB를 확인하여 다시 보내주는 형태로 반응한다. 그 방법에는 여러가지가 있는데 흔히 ASP, PHP, JSP등을 사용할 수도 있고 최근 라이브러리나 프레임워크를 사용하면서 axios나 rxjs등의 여러가지 형태로도 가능하다. 폼태그&lt;form [속성=&quot;속성값&quot;]&gt;&lt;/form&gt; 폼 택의 기본적인 형태는 이렇다. 하지만 그 속성은 정말 다양하게 존재한다. method서버 쪽에 넘겨줄 방법을 지정하는 속성이다. 보통 get, post를 사용하는 데 get은 url자체에 담아서 넘겨줘 데이터 용량에 제한이 있지만 우리가 보통 사용하는 post 방식은 표준 입력으로 제한이 없고 정보가 노출되지 않는다. name폼의 이름을 지정한다. action서버 상의 프로그램을 지정한다. target스크립트 파일을 현재창에 띄울 지 다른 위치에서 열지 지정한다. autocomplete자동완성 속성이다. 우리가 검색창에서 어떤 검색어를 입력할 때 자동완성 되는 경험을 해본 적이 있을 것이다. 기본값은 on으로 지정되어 있다. label 태그&lt;label [속성=&quot;속성값&quot;]&gt;&lt;/label&gt; label 태그는 폼 요소에 레이블을 붙이기 위한 태그이다. 직접 텍스트를 입력할 수도 있고 for 속성을 사용하여 지정할 수도 있다. 또한 라벨 태그를 input 태그에 checkbox나 radio 버튼과 연결하면 텍스트를 클릭해도 항목이 클릭되게 만들 수도 있다. fieldset과 legend 태그이 두 태그는 폼 요소를 그룹으로 묶을 때 사용한다. 이 태그를 사용하면 하나의 그룹으로 묶고 외곽선을 그려준다. input 태그쉽게 말해서 우리가 입력할 수 있는 텍스트 상자나 로그인 버튼 등을 만들어 내는 태그가 바로 input 태그이다. &lt;input type=&quot;유형&quot; [속성=&quot;속성값&quot;]&gt; 위 예제에서 봤듯이 input태그에서 id 속성을 사용하면 label 태그를 통해 속성을 붙이기도 하고 css에서도 사용할 수 있다. input태그 속성 다음 시간에는 input 태그의 사용법에 대해서 예제와 함께 살펴보도록 하겠습니다. (찡긋)","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"HTML","slug":"HTML-CSS/HTML","permalink":"http://rootjang92.github.io/categories/HTML-CSS/HTML/"}],"tags":[{"name":"HTML, html, html form, form tag","slug":"HTML-html-html-form-form-tag","permalink":"http://rootjang92.github.io/tags/HTML-html-html-form-form-tag/"}]},{"title":"프로토타입과 배열 그리고 연산자","slug":"jsprototype","date":"2018-09-05T07:27:24.000Z","updated":"2018-09-05T08:48:34.000Z","comments":true,"path":"2018/09/05/jsprototype/","link":"","permalink":"http://rootjang92.github.io/2018/09/05/jsprototype/","excerpt":"","text":"프로토타입자바스크립트의 모든 객체는 자신의 부모 역할을 하는 객체와 연결되어 있다. 이를 통해 자바스크립트에서는 상속 개념을 구현할 수 있다. 이를 프로토타입 객체라고 한다. var foo = { name: &apos;Jang&apos;, age: 27 }; console.log(foo.toString()); console.dir(foo); 코드를 한 번 살펴보자. 사실상 1번 콘솔로그에서 toString이라는 메서드가 없어 오류가 발생해야 하지만 정상적으로 작동한다.즉, foo 객체의 부모 역할을 하는 프로토타입에 toString() 메서드가 이미 정의되어 있기 때문에 호출이 가능한 것이다. 출력결과 [object Object]{ name: ‘Jang’, age: 27 } 즉 모든 객체는 자신의 프로토타입을 가리키는 [[Prototype]]이라는 숨겨진 프로퍼티를 가진다. (크롬 브라우저의 _proto_)여기서 foo 객체는 자신의 부모 객체를 _proto_라는 내부 프로퍼티로 연결하고 있다.자세한 내용은 프로토타입 체이닝에서 더 다루겠지만, 결론적으로 객체 리터럴로 생성한 객체의 경우 Object.prototype 객체가 프로토타입 객체이다. 배열 배열 리터럴배열 리터럴은 ‘[]’를 사용해서 배열을 만든다. var colorArr = [‘orange’, ‘red’, ‘yellow’, ‘green’]; console.log(colorArr[0]); console.log(colorArr[1]); 출력결과 orangered 배열은 인덱스 값으로 접근할 수 있다. 배열 내 인덱스는 0부터 시작한다. 즉 첫번째 값의 인덱스는 0인 것이다. 배열 요소 생성배열도 다른 객체와 마찬가지로 동적으로 배열 원소를 동적으로 추가할 수 있다. var empty = []; console.log(empty); empty[0] = 100; empty[3] = ‘four’; console.log(empty); console.log(empty.length); 출력 결과 [][ 100, undefined x 2, four ]4 자바스크립트의 배열은 인덱스 순서와 상관없이 할당이 가능하다. 값이 없다면 undefined가 뜬다.또한 중요한 점은 자바스크립트가 배열의 크기를 배열 인덱스 중 가장 큰 값을 기준으로 정한다.는 것이다.또한 length 프로퍼티를 이용하여 배열의 길이를 구할 수 있다. 배열의 길이 값은 가장 큰 인덱스에 +1을 한 값이다.(인덱스의 시작이 0 이기 때문이다.) length길이값은 위에서 설명했지만, 중요한 것은 길이값을 명시적으로 변경할 수 있고 그 길이를 초과하는 값은 삭제된다는 점이다.위 예제에서 empty의 length값은 4이지만 length값을 2로 설정하면, 100과 undefined를 제외한 뒤의 값은 삭제된다. 배열과 객체배열과 객체는 모두 객체이지만 몇 가지 차이점이 있다. 우선 length 프로퍼티는 배열에만 존재한다. 두 번째로는 프로토타입의 차이이다.일반 객체는 push와 같은 표준 배열 메서드를 사용할 수 없는데 둘의 프로토타입 체이닝에 의한 부모 프로토타입 객체가 서로 다르기 때문이다. 객체 - _proto_ - Object.prototype배열 - _proto_ - Array.prototype - _proto_ - Object.prototype 배열의 프로퍼티 열거객체는 for in 문으로 객체를 열거할 수 있는데 배열은 for in문을 사용하면 불필요한 프로퍼티가 출력될 수 있으므로 for문을 사용하는 것이 좋다. var arr = [&apos;zero&apos;, &apos;one&apos;, &apos;two&apos;]; console.log(arr.length); arr[3] = &apos;red&apos;; console.log(arr.length); for (var i = 0; i &lt; arr.length; i++) { console.log(i, arr[i]); } 출력 결과 34for문 결과값0 ‘zero’1 ‘one’2 ‘two’3 ‘red’ 배열 요소 삭제배열도 객체이므로 delete 연산자를 사용할 수 있지만, 이는 해당 요소를 undefined처리할 뿐이다. 그래서 배열에서는 splice()배열 메서드를 사용한다. splice() 배열 메서드splice(start, deleteCount, item…) start : 배열에서 시작 위치, deleteCount : 삭제할 요소의 수 item : 삭제할 위치에 추가할 요소ㅡ var arr = [&apos;zero&apos;, &apos;one&apos;, &apos;two&apos;, &apos;three&apos;]; arr.splice(2,1); // 1 console.log(arr); console.log(arr.length); 즉 1의 의미는 arr배열의 2번째부터 1개 요소를 삭제하겠다는 의미이다. 즉 arr 요소에서 ‘two’가 삭제되는 것이다. 출력 결과 [ ‘zero’, ‘one’, ‘three’ ]3 Array() 생성자 함수배열은 배열 리터럴로 생성하지만 배열 리터럴도 결국 Array()생성자 함수로 배열을 생성하는 것을 단수화한 것이다.생성자 함수로 배열을 생성할 때에는 new 연산자를 사용하여야 한다. var foo = new Array(3); console.log(foo); console.log(foo.length); var bar = new Array(1,2,3); console.log(bar); console.log(bar.length); 호출할 때 인자가 1개이면 호출된 인자를 lenth로 갖는 빈 배열을 생성하고 그 외에는 호출된 인자를 요소로 같는다. 출력 결과 [ undefined x 3]3[1,2,3]3 유사 배열 객체length 프로퍼티는 배열의 동작에 있어서 정말 중요하다. 그런데 일반 객체에서도 length를 사용할 수 있는 경우가 있으니 이를 유사 배열객체라고 한다. var arr = [&apos;bar&apos;]; var obj = { name: &apos;Jang&apos;, length : 1}; arr.push(&apos;baz&apos;); console.log(arr); Array.prototype.push.apply(obj, [&apos;baz&apos;]); console.log(obj); 원래의 경우라면 변수 obj에는 push()메서드를 사용할 수 없으나, apply() 메서드를 사용하면 객체라도 표준 배열 메서드를 사용할 수 있다.후에 더 자세히 살펴볼 것이다. (call, apply 메서드) 출력 결과 [ ‘bar’, ‘baz’ ]{ ‘1’: ‘baz’, name: ‘Jang’, length: 2 } 기본 타입과 표준 메서드기본 타입의 경우 어떻게 표준 메서드를 호출하는가? 자바스크립트에서는 기본값을 객체로 변화한 다음 각 타입의 표준 메서드를 불러온다. 연산자 연산자 +연산자는 더하기 연산과 문자열 연결 연산을 수행한다. 두 연산자가 모두 숫자인 경우에는 더하기 연산을 실시한다. typeof 연산자 피연산자의 타입을 문자열 형태로 리턴하는 연산자이다. 유의할 점은 null의 경우 object로 표시된다는 점(자바스크립트 개발단 오류)함수는 function이라는 점에 유의하여야 한다. 동등연산자와 일치연산자. 동등연사자의 경우(==) 피연사자의 타입이 다를 경우 이를 변경하여 비교하고 일치연산자의 경우(===) 타입을 변경하지 않는다. console.log(1 == &apos;1&apos;) // true console.log(1 === &apos;1&apos;) // false !! 연산자 !!연산자는 피연산자를 불리언값으로 변환한다. 값이 0이나 없다면 false, 그 외의 빈 객체, 배열, 문자열 등은 true로 표시된다. 다음 시간에는 함수와 프로토타입 체이닝에 대해서 알아보겠습니다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://rootjang92.github.io/categories/Javascript/"},{"name":"ES5","slug":"Javascript/ES5","permalink":"http://rootjang92.github.io/categories/Javascript/ES5/"}],"tags":[{"name":"Javascript, js, es5, ES5, prototype, js prototype","slug":"Javascript-js-es5-ES5-prototype-js-prototype","permalink":"http://rootjang92.github.io/tags/Javascript-js-es5-ES5-prototype-js-prototype/"}]},{"title":"이미지와 하이퍼텍스트링크","slug":"htmlimage","date":"2018-09-05T01:37:02.000Z","updated":"2018-09-05T07:26:34.000Z","comments":true,"path":"2018/09/05/htmlimage/","link":"","permalink":"http://rootjang92.github.io/2018/09/05/htmlimage/","excerpt":"","text":"이미지와 하이퍼텍스트 링크웹에서 사용되는 이미지 파일 형식은?웹 페이지는 기본적으로 설명은 텍스트, 메뉴나 로고 등은 이미지로 처리 한다. 웹 페이지의 경우 크기가 작고 화질이 좋은 파일 형식을 사용하여야 하는데 웹에서 사용할 수 있는 파일 형식은 GIF, JPG/JPEG, PNG 파일이 있다. 이미지 파일 형식 img 태그HTML에서 이미지를 삽입하는 태그는 태그이다. 이 때 src 속성을 사용하여 해당 이미지의 주소를 넣는다. img 태그에는 src속성과 alt속성이 있는데 src는 해당 이미지의 주소, alt는 설명이 들어간다.다시 돌아가 파일 경로에 대해 살펴보자. 내 컴퓨터에 있는 이미지를 사용한다면 그에 맞는 파일명, 다른 폴더에 있는 경우 하위 폴더와 함께 적어주면 된다. ‘/‘는 하위폴더를 나타낸다.(한단계 위는 ‘..’을 사용한다.) 웹 상의 이미지 또한 링크 주소를 받아 붙여넣을 수 있다. 해당 사이트가 닫히지 않는 이상 사용할 수 있다. 단 이 경우 저작권에 주의하여야 한다. alt는 이미지를 설명하는 대체 텍스트를 달 때 사용하는 속성이다. 이를 사용할 경우 시각 장애인에게 화면 낭독기가 이미지를 설명해 줄 수 있다. width, height 속성은 너비와 높이를 조정하는 속성이다. img의 기타 속성들 figure, figcaption : 설명 속성 태그 이미지에 설명을 함께 붙이고 싶을 때 사용하는 태그이다. figure태그는 설명 글을 붙일 대상을 지정합니다. 예를 들어 figure태그 안에 img태그와 figcaption태그를 넣게 되면 이미지 밑에 캡션이 달리게 됩니다. 링크텍스트를 클릭하면 연결된 주소로 즉시 이동하게 하는 기능이 링크이다. a태그와 href 속성. 사실상 링크에서 가장 중요한 두 요소이다. a태그를 이용하여 링크를 걸고 href 속성에 주소를 넣는다. 그 외에 속성으로는target(링크한 내용이 표실될 위치, 현재 창 혹은 새 창), download(링크 다운로드), rel(관계 알리기), hreflang(링크한 문서 언어 설정), type(파일 유형) SVG 이미지최근 웹 브라우저에서 svg 파일을 지원하면서 아이콘이나 로고에 많이 사용되고 있다. 이미지를 확대, 축소해도 깨끗한 상태로 유지되는 것이 바로 벡터 이미지이고 그 확장자명이 svg이다. 다음 시간에는 폼 태그에 대해 다루겠습니다.","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"HTML","slug":"HTML-CSS/HTML","permalink":"http://rootjang92.github.io/categories/HTML-CSS/HTML/"}],"tags":[{"name":"HTML, html, HTML basic syntax, HTML hyperlink, html link","slug":"HTML-html-HTML-basic-syntax-HTML-hyperlink-html-link","permalink":"http://rootjang92.github.io/tags/HTML-html-HTML-basic-syntax-HTML-hyperlink-html-link/"}]},{"title":"Object","slug":"jsobject","date":"2018-09-04T01:38:52.000Z","updated":"2018-09-05T01:36:37.000Z","comments":true,"path":"2018/09/04/jsobject/","link":"","permalink":"http://rootjang92.github.io/2018/09/04/jsobject/","excerpt":"","text":"객체 프로퍼티와 참조 그리고 프로토타입객체 프로퍼티 읽기와 쓰기 그리고 갱신우선 프로퍼티에 접근하는 방법을 알아야 하는데 그 방법에는 대괄호 표기법과 마침표 표기법 두가지가 있다. 예제var foo = { name : &apos;Jang&apos;, major : &apos;Computer science&apos; }; // 객체 프로퍼티 읽기 console.log(foo.name); console.log(foo[&apos;name&apos;]); console.log(foo.nickname); foo.major = &apos;electronics Business&apos;; console.log(foo.major); console.log(foo[&apos;major&apos;]); foo.age = 27; console.log(foo.age); foo[&apos;full-name&apos;] = &apos;Jang Geun-ho&apos;; console.log(foo[&apos;full-name&apos;]); console.log(foo.full); 출력 결과 JangJangundefinedelectronics Businesselectronics Business27Jang Geun-houndefined 마침표 표기법은 객체 다음에 마침표를 찍고 원하는 속성값을 적으면 된다. 대괄호 표기법은 객체의 프로퍼티를 문자열 형태로 만들어 대괄호 안에 넣으면 된다. 만약 문자화하지 않으면 값은 undefined가 나타난다. 또한 대괊호 표기법을 이용하여 기존 프로퍼티값을 갱신할 수 있다. 예제에서 살펴봤던 foo[‘major’]의 형태처럼 말이다.JS의 특징 중 하나가 프로퍼티의 동적 생성인데 보시다시피 foo.age라는 프로퍼티는 아직 존재하지 않지만 이걸 동적으로 생성하여 27이라는 숫자값을 할당해준다. 즉 기존에 있는 값은 갱신되고 없는 프로퍼터의 경우 동적 생성된 후 값이 할당된다는 의미이다. 주의할 점은 연산자가 포함되있는 경우라면 대괄호 표기법을 사용하여야 한다는 것이다.또한 객체 프로퍼티는 delete 연산자를 이용해 삭제할 수 있다. 단 delete 연산자는 프로퍼티만 삭제한다. 예제2var foo = { name : &apos;Jang&apos;, major : &apos;Computer science&apos; }; var prop; for (prop in foo) { console.log(prop, foo[prop]); } 출력결과 name Jangmajor Computer science for in 문을 이용해서 foo라는 개체에 루프를 돌렸다. prop 변수에 foo 객체의 프로퍼티가 하나씩 할당되면서 대괄호 표기법을 사용해 모든 요소가 출력된다. 참조 타입의 특성객체는 JS에서 참조 타입이라고 부른다. 객체의 연산은 참조값으로 처리가 되기 때문이다. var A = { val : 40 }; var B = A console.log(A.val); console.log(B.val); B.val = 50; console.log(A.val); console.log(B.val); A, B두 객체를 객체 리터럴 방식으로 생성해 보았다. 이 때 각 콘솔 로그의 값은 어떻게 찍힐까? 출력 결과 40405050 변수 A와 B는 동일한 객체를 가리키는 참조값을 가지기 때문에 B의 val 값을 50으로 변경하면 변수 A의 값도 변한다.즉 A는 실제로 객체를 참조하는 값을 저장하는 것이지 실제 객체를 나타내지는 않는다는 점이다.A 객체는 참조 변수 A가 가리키는 객체! 객체 비교JS에서의 동등 연산자(==)는 객체의 프로퍼티 값이 아니라 참조값을 비교한다. var a = 100; var b = 100; var objA = { value: 100 }; var objB = { value: 100 }; var objC = objB console.log(a == b); console.log(objA == objB); console.log(objB == objC); 출력 결과를 예상해보자. 당연히 모두 true를 예상했겠지만(처음에는 저도…) 답은… 출력결과 truefalsetrue 변수 objA와 objB는 다른 참조값을 가진다. a,b처럼 기본 타입의 경우는 단순히 값을 비교하지만 객체의 경우 참조값을 비교하기 때문에 각각 다른 값을 참조하고 있는 두 변수는 동등 연산자를 사용했을 때 false가 나오는 것이다. 함수 호출 방식.기본 타입과 참조 타입은 함수 호출 방식이 다르다. 기본타입call by value(값에 의한 호출) : 기본 타입의 값을 인자로 넘길 경우 호출된 함수의 매개변수로 복사된 값이 전달된다.그렇기 때문에 함수 내 매개변수로 값을 변경해도 실제로 변수의 값은 변하지 않는다. 참조타입call by reference(참조에 의한 호출) : 함수 호출 시 인자로 넘긴 객체의 참조값이 그대로 함수로 전달된다. 그렇기 때문에 함수 내부에서 참조값을 변경하면 실제 객체의 값도 변경된다. var a = 100; var objA = { value: 100 }; function changeArg(num, obj) { num = 200; obj.value = 200; console.log(num); console.log(obj); } changeArg(a, objA); console.log(a); console.log(objA); 출력 결과 200{ value: 200 }100{ value: 200 } 함수를 호출하면서 기본 타입인 변수 a의 값은 변화하지 않았지만, 객체 타입인 objA의 값은 변화하였다. 참고자료 다음 시간에는 프로토타입과 배열에 대해 살펴보겠습니다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://rootjang92.github.io/categories/Javascript/"},{"name":"ES5","slug":"Javascript/ES5","permalink":"http://rootjang92.github.io/categories/Javascript/ES5/"}],"tags":[{"name":"Javascript, js, es5, ES5, object, js object","slug":"Javascript-js-es5-ES5-object-js-object","permalink":"http://rootjang92.github.io/tags/Javascript-js-es5-ES5-object-js-object/"}]},{"title":"목록을 생성하는 HTML 태그","slug":"htmllist","date":"2018-09-04T01:12:31.000Z","updated":"2018-09-04T08:14:53.000Z","comments":true,"path":"2018/09/04/htmllist/","link":"","permalink":"http://rootjang92.github.io/2018/09/04/htmllist/","excerpt":"","text":"목록을 생성하는 태그HTML 문서를 작성할 때 많이 쓰이는 태그 중 하나가 바로 목록을 생성하는 태그다. 웹 표준이 정의화된 후에는 이미지나 텍스트에 구애받지 않고 어떤 것이든 목록화 시킬 수 있다. 특히 CSS를 적용한다면 메뉴나 본문 내용 등으로 사용할 수 있으니 table 태그가 거의 안쓰이는 이유가 되기도 했다. ul태그, li태그이 두 태그는 ‘순서 없는’ 목록을 만들 때 사용되는 태그이다. ul태그 안에 li태그를 사용하여 목록화 시킨다. 예제 ol태그, li태그ol 태그는 순서가 필요한 목록을 만들 때 사용한다. ol은 타입을 지정할 수 있는데 1은 숫자를 나타내며 기본값으로 설정되어 있다.그 외에 a(영소문자),A(영대문자),i(로마숫자 소문자),I(로마숫자 대문자)로 이루어져 있다. CSS로도 대체 가능하다. 에제 dl,dt,dd 태그자주 쓰이는 태그는 아니지만 설명 목록을 만들 때 주로 쓰이는 태그이다. 경험이 적어서 그런건진 몰라도 이 태그 쓰는 사이트를 본 기억이 드물다. 위키트리에서는 쓰일 수도 있겠다… 여튼 dl태그로 묶고 dt 태그에 제목을 dd 태그에 설명을 표시한다. 지금까지 배운 자료를 가지고 본인만의 간단한 프로필 웹 페이지를 만들어 보는 것도 좋을 것 같다. 참고할 만한 사이트.HTML 온라인 검사기 이 사이트는 파일을 업로드하면 자동으로 HTML 문서 상 오류가 있는 지 검사해주는 사이트다. 웹 페이지를 제작할 때 꽤 유용하다.","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"HTML","slug":"HTML-CSS/HTML","permalink":"http://rootjang92.github.io/categories/HTML-CSS/HTML/"}],"tags":[{"name":"HTML, html, HTML basic syntax, htmltag, ul, li","slug":"HTML-html-HTML-basic-syntax-htmltag-ul-li","permalink":"http://rootjang92.github.io/tags/HTML-html-HTML-basic-syntax-htmltag-ul-li/"}]},{"title":"자바스크립트 데이터 타입과 연산자.","slug":"jsdatatype","date":"2018-09-03T09:04:58.000Z","updated":"2018-09-04T08:05:26.000Z","comments":true,"path":"2018/09/03/jsdatatype/","link":"","permalink":"http://rootjang92.github.io/2018/09/03/jsdatatype/","excerpt":"","text":"자바스크립트 데이터 타입자바스크립트의 데이터 타입에는 기본 타입과 참조 타입이 있다. 기본타입은 숫자, 문자열, boolean, undefined, null 값이 있고참조형에는 객체(배열, 함수, 정규 표현식)이 있다. 자바스크립트 기본 타입기본 타입에는 Nmber, String, Boolean, null, undefined가 있다.이들 타입의 특징은 그 자체가 하나의 값을 나타낸다는 것이다. 자바스크립트는 느슨한 타입의 언어이기 때문에 변수를 선언할 때 타입을 미리 지정하지 않고 var(es5)라는 키워드로 변수를 선언하여 어떠한 값이라도 데이터를 저장할 수 있다. var intNum = 10; var floatNum = 0.1; var singleQuoteStr = &apos;single quote string&apos;; var boolVar = true; var emptyVar; var nullVar = null; console.log(typeof intNum, typeof floatNum, typeof singleQuoteStr, typeof boolVar, typeof emptyVar, typeof nullVar); 출력 결과 number number string boolean undefined object 숫자다른 언어와 달리 JS에서는 하나의 숫자형만 존재한다. (모든 숫자를 64비트 부동 소수점 형태로 저장한다.)또한 모든 숫자를 실수로 처리하므로 나눗셈 연산에 주의하여야 한다. var num = 5 / 2; console.log(num); console.log(Math.floor(num)); 출력 결과 2.52 Math.floor 메서드는 정수 부분만 구하는 JS의 메서드이다. 문자열문자열은 작은 따옴표나 큰 따옴표를 이용해서 생성한다. 또한 JS의 문자열은 문자 배열처럼 인덱스를 이용할 수 있다. 또한 한 번 생선된 문자열은 수정이 불가능 하다. var str = &apos;easy&apos;; console.log(str[0], str[1], str[2], str[3]); str[0] = &apos;E&apos;; console.log(str); 출력 결과 e a s yeasy boolean값JS에서 사용하는 true, false 값이다. null과 undefined두 타입 모두 ‘값이 비어 있다.’를 나타내기 위해 사용된다. 값이 할당되지 않은 변수는 undefined이며 이는 변수 자체의 값이 undefined이다. (타입이자 값이다.) 여기 주의할 점은 null의 타입이 object라는 것인데 이 때문에 타입 변수인자를 확인할 때에는 일치 연산자를 사용하여야 한다. (===) var nullVar = null; console.log(typeof nullVar === null); console.log(nullVar === null); 출력 결과 falsetrue JS 객체 타입JS에서 기본 타입을 제외한 모든 것은 객체이다. 배열, 함수, 정규표현식 들도 마찬가지이다. 객체는 단순히 이름(key):값(value)를 저장하는 형태이다. 기본 타입은 하나의 값마늘 가지는 데에 반해 겍체는 여러 개의 프로퍼티를 포함할 수 있다. 그래서 기본 타입을 포함하거나 다른 객체를 가리킬 수도 있다. 또한 프로퍼티의 성질에 따라 함수로 포함시킬 수도 있으며 이러한 프로퍼티를 메서드라고 부른다. JS 객체 생성 방법.객체 생성 방법에는 3가지가 있다. 그 방법들에 대해 알아보자 Object() 생성자 함수.JS에서는 객체를 생성할 때 내장 Object() 생성자 함수를 제공한다. 예제를 통해 살펴보자. var foo = new Object(); // foo property make up foo.name = &apos;Jang&apos;; foo.age = 27; foo.gender = &apos;male&apos;; console.log(typeof foo); console.log(foo); 출력 결과 object{ name: ‘Jang’, age: 27, gender: ‘male’ } Object() 생성자 함수를 통해 객체를 생성하였고 그 타입은 object이고 변수 foo에 3가지 프로퍼티가 추가되었음을 알 수 있다. 객체 리터럴 방식.리터럴이란 표기법을 의미한다. 즉 간단한 표기법으로 객체를 생성하는 방식이다. var foo = { name : &apos;Jang&apos;, age : 27, gender : &apos;male&apos; }; console.log(typeof foo); console.log(foo); 출력 결과 object{ name: ‘Jang’, age: 27, gender: ‘male’ } 생성자 함수 이용.객체를 함수를 통해서도 생성할 수 있다. 생성자 함수라고 하는데 다음에 더 자세히 다루도록 하겠다. 다음 시간에는 객체 프로퍼티 표기법과 참조타입의 특성에 대해 살펴보겠습니다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://rootjang92.github.io/categories/Javascript/"},{"name":"ES5","slug":"Javascript/ES5","permalink":"http://rootjang92.github.io/categories/Javascript/ES5/"}],"tags":[{"name":"Javascript, js, es5, ES5, data, datatype","slug":"Javascript-js-es5-ES5-data-datatype","permalink":"http://rootjang92.github.io/tags/Javascript-js-es5-ES5-data-datatype/"}]},{"title":"HTML 텍스트 관련된 태그들","slug":"htmltext","date":"2018-09-03T08:02:35.000Z","updated":"2018-09-04T08:15:00.000Z","comments":true,"path":"2018/09/03/htmltext/","link":"","permalink":"http://rootjang92.github.io/2018/09/03/htmltext/","excerpt":"","text":"HTML 텍스트 관련 태그들.HTML 문서를 작성할 때 가장 많이 쓰이는 태그는 무엇일까?? 바로 텍스트 관련 태그들이다.p, strong, table,em,ul,li 태그 등 꽤 많은 태그가 쓰이는 데 그 중에서 정말 자주 쓰이는 태그만 알아보자.araboza h 관련 태그HTML 문서에서 제목을 붙이고 싶을 때는 h관련 태그(제목 텍스트)를 쓰면 된다. h 태그를 사용하면 글씨가 크고 굵어진다.h1 ~ h6까지 사용 가능하다. p 태그쉽게 말하면 단락 만들기 태그이다. 단락은 앞뒤에 줄바꿈이 있는 덩어리를 말한다. br 태그줄바꿈 태그이다. 이 태그 없이 줄바꿈을 하더라도 줄이 바뀌지 않는다. (텍스트만 사용 시) hr 태그수평줄을 삽입하는 태그이다. 보통 css로 만들기 때문에 딱히 쓰이진 않지만… 실습용으로 blockquote 태그다른 사이트에서 가져온 글을 인용할 때 사용하는 태그이다. (마크다운에도 비슷한 문법이 있다.) 예제 pre 태그입력한 그대로 입력되게 해주는 태그다. 하지만 웹 표준성에 맞추기 위해 사용을 자제하는 것이 좋다. strong, b태그와 em, i 태그strong, b 태그는 텍스트를 굵게 표시하기 위해 사용된다. 둘의 차이점은 단순히 굵게 표시할떈 b태그, 강조되었다는 것을 알리기 위해선 strong 태그를 사용한다. em, i 태그는 이탤릭체로 표시되게 하는 태그이다. 둘의 차이는 단순히 표시만 하는 것은 em, 의미를 알리기 위해선 i 태그르 사용한다는 것이다. blockquote와 q 태그두 태그 모두 인용문을 사용하는 태그이지만 둘의 차이는 블록 베레이냐 인라인 레벨이냐 이다.blocakquote는 블록 레벨에 태그이기 때문에 인용 내용이 줄이 바뀌어 나타나지만, q태그는 인라인 태그이기 때문에 한 줄로 표시된다. span 태그줄 바꿈 없이 단락 안에서 텍스트를 묶을 때 사용하는 태그이다. 큰 의미는 없다. 다음 시간에는 목록만들기와 테이블 만들기를 알아보도록 하겠습니다.","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"HTML","slug":"HTML-CSS/HTML","permalink":"http://rootjang92.github.io/categories/HTML-CSS/HTML/"}],"tags":[{"name":"HTML, html, HTML basic syntax, htmltag","slug":"HTML-html-HTML-basic-syntax-htmltag","permalink":"http://rootjang92.github.io/tags/HTML-html-HTML-basic-syntax-htmltag/"}]},{"title":"Javascript 기본 개요","slug":"jsbasic","date":"2018-09-02T01:46:18.000Z","updated":"2018-09-02T02:01:24.000Z","comments":true,"path":"2018/09/02/jsbasic/","link":"","permalink":"http://rootjang92.github.io/2018/09/02/jsbasic/","excerpt":"","text":"자바스크립트 기본 개요자바스크립트는 웹 브라우저에서 동작하는 스크립트 언어이다. 처음에는 웹 페이지 제작에 보조적 역할에 한정되어 있었다.하지만 여러가지 연구와 prototype 라이브러리 개발 등 많은 발전이 있으면서 서버에서 담당하던 역할이 웹 브라우저로 옮겨졌고 결국 자바스크립트는 그 변화의 중심적인 언어가 되었다. (인사이드 자바스크립트 저:송형주, 고현준 참조) 현재 github에서 가장 많이 사용되고 있는 언어는 자바스크립트이고 Node.js의 개발로 서버 개발 또한 가능해지며 사용자가 늘고 있다. 자바스크립트는 현재 웹 개발은 물론 Node.js, express, socket.io 등을 활용한 서버 개발, 애플리케이션 개발도 가능해졌기 때문에 웹 기반 플랫폼에선 없어서는 안될 언어가 되었다. 자바스크립트 핵심 개념자바스크립트에서는 꼭 알아야 할 몇가지 핵심 개념이 있는데 앞으로 블로그를 운영하면서 차차 살펴보도록 하겠다. 객체(Object) 자바스크립트(이하 JS)의 거의 모든 것은 객체라고 할 정도로 중요한 개념이다. 자바스크립트의 기본 데이터 타입을 제외하곤 모든 것이 객체이다.하지만 null과 undefined를 제외한 모든 것을 객체처럼 다룰 수 있기 때문에 이 2가지를 제외하곤 모두 객체라고 할 수 있다. 함수 JS에선 함수도 객체이다. 함수는 특히 중요하기 떄문에 일급 객체(First class object)로 취급된다. 프로토타입 모든 객체는 프로토타입을 가진다. 분량이 상당히 많을 것으로 예상되기 때문에 뒤에서 자세히 다루겠지만, 쉽게 말해서 해당 개체를 생성한 생성자를 가리킨다고 보면 된다. 이 프로토타입으로 인해 겍체지향에 상속을 구현할 수 있게 되었다. 실행 컨텍스트와 클로저 JS는 자신만의 방법으로 실행 컨텍스트를 만들고 그 안에서 유효범위(Scope)를 갖는다. 또한 그 과정에서 클로저를 구현할 수 있다. 객체지향 프로그래밍 JS는 클래스를 지원하지 않지만(ES6에서는 함수의 형태로 만들어졌다.) 상속과 캡슐화 등의 객체지향 프로그래밍을 따라가고 있다. JS와 함수형 프로그래밍 ‘모듈화’하면 함수형 프로그래밍! JS의 일급 객체인 함수와 클로저를 활용하여 함수형 프로그래밍이 가능하게 한다. 단점 굉장히 유연한 언어의 단점은 디버깅이 힘들다는 점, 느슨한 타입 체크로 인한 컴파일 에러(런타임 에러로 이어진다.)","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://rootjang92.github.io/categories/Javascript/"},{"name":"ES5","slug":"Javascript/ES5","permalink":"http://rootjang92.github.io/categories/Javascript/ES5/"}],"tags":[{"name":"Javascript, js, es5, ES5","slug":"Javascript-js-es5-ES5","permalink":"http://rootjang92.github.io/tags/Javascript-js-es5-ES5/"}]},{"title":"HTML 기본 문서 구조","slug":"htmlbasic","date":"2018-09-02T01:03:39.000Z","updated":"2018-09-02T01:44:33.000Z","comments":true,"path":"2018/09/02/htmlbasic/","link":"","permalink":"http://rootjang92.github.io/2018/09/02/htmlbasic/","excerpt":"","text":"HTML 기본 문서 구조1. 태그HTML은 웹 문서에 마크업을 하는 언어이다. 그 때 마크업을 사용하는 약속된 표기법이 태그 이다. 태그는 &lt;&gt;를 사용한다.꺽쇠 사이에 들어가는 부분이 바로 tag 부분이다. 소문자로 쓴다.(권장사항)대,소문자를 구분하진 않지만 HTML5 표준 명세에는 소문자를 권장하고 있다. 여는 태그와 닫는 태그닫는 태그가 없는 경우도 있지만 닫는 태그가 필요한 태그에는 반드시 태그를 닫아주어야 한다. 들여쓰기.쉽게 눈으로 확인하고 문서의 구조를 파악하기가 쉬워진다. tab키를 사용한다. 속성을 파악해야 한다.태그 안에는 사용할 수 있는 속성값이 있다. 예를 들어 img 태그에는 src(주소값), width, height 등의 속성이 있다. 처음 만들어 보는 HTML 문서 문서 구조 살펴보기.&lt;!DOCTYPE html&gt; HTML5로 작성된 웹 문서라는 뜻이다. HTML4에서는 엄격모드, 호환 모드 등 꽤 복잡했지만 이젠 단 한줄이면 된다. &lt;html&gt; ~ &lt;/html&gt; 웹 문서의 시작과 끝이라고 보면 된다. 이 태그에는 lang이라는 속성에 언어를 설정해 줘야 하는데 특정 언어로 검색할 때 그 대상이 될 수 있다. &lt;head&gt; ~ &lt;/head&gt; 웹 문서를 해석하기 위해 필요한 정보들을 입력하는 곳이다. &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;내가 처음 만드는 HTML 문서&lt;/title&gt; head 태그 안에는 meta태그와 title태그가 보통 표시 되는데 화면에 보이는 것은 title 태그이다. meta 태그는 실제 문서 내용이 아닌 문서를 해석하기 위해 사용되는 태그이다. title태그에 문서 제목을 입력하는 이유는 웹 표준성과 관련되어 있다. 간혹 시각 장애를 가지고 계시는 분들이 인터넷을 이용할 때 보조 기기를 이용하는데, 제목을 듣고 이 사이트가 어떤 사이트 인지 알 수 있어야 하기 떄문이다. meta 태그 안에는 문자 인코딩 방법이나 키워드 등을 지정한다. &lt;body&gt; ~ &lt;/body&gt; 웹 문서의 실질적인 내용(화면에 나오는 내용)이 나타내는 태그이다. 대부분의 태그는 이 태그 안에 들어간다. 사이트를 이용하기 위해선 서버단에서 호스팅 서버를 준비해서 FTP 프로그램을 이용해 배포해야 한다.","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"HTML","slug":"HTML-CSS/HTML","permalink":"http://rootjang92.github.io/categories/HTML-CSS/HTML/"}],"tags":[{"name":"HTML, html, HTML basic syntax, html tag","slug":"HTML-html-HTML-basic-syntax-html-tag","permalink":"http://rootjang92.github.io/tags/HTML-html-HTML-basic-syntax-html-tag/"}]},{"title":"HTML이란?","slug":"html1","date":"2018-09-01T06:27:45.000Z","updated":"2018-09-01T07:13:00.000Z","comments":true,"path":"2018/09/01/html1/","link":"","permalink":"http://rootjang92.github.io/2018/09/01/html1/","excerpt":"","text":"HTML이란 무엇인가?우리가 흔히 보는 웹사이트의 기본은 HTML 이다. 흔히 ‘웹 문서’를 작성한다고 말하는데 이를 보는 프로그램이 바로 ‘Web browser’이다.HTML은 HyperText Markup Language의 줄임말로서 하이퍼텍스트를 마크업한는 언어다. 하이퍼 텍스트란?웹 사이트에서 링크를 클릭해 다른 문서나 사이트로 즉시 이동할 수 있는 기능. &lt;&gt;로 묶인 것은 HTML 태그라고 하고 이렇게 태그를 붙이는 것이 마크업이다. 이 꺽쇠안의 내용은 웹 브라우저 화면에 나타나지 않는다. 네이버로 들어가 [페이지 소스 보기], 혹은 검사(chrome)을 하여 documents를 살펴보자.HTML소스 엿보기 웹 표준이란?우리가 현재 사용하고 있는 HTML5를 웹 표준 기술이라고 하는데 왜 웹 표준이 필요할까?바로 ‘표준’이 필요하기 떄문입니다. 세상에는 많은 브라우저들이 있기 때문에 예를 들어 IE에서는 맞지 않고 크롬에만 맞는 사이트를 구현한다면 사용자들이 자유롭게 이용할 수 없다. 따라서 HTML5로 문서를 만드는 것은 웹 표준을 지키는 문서를 만드는 것이다. 최신 웹 표준에 맞는 웹사이트를 제작할 수 있다. 앱 화면의 기초를 디자인한다. Interactive한 사이트를 만들 수 있다. 소스를 이해하여 웹 사이트나 블로그를 쉽게 수정할 수 있다. 이로서 HTML5를 왜 사용하는 지에 대해 알아보았습니다. 다음 시간에는 HTML의 기본 문서 구조에 대해 알아보겠습니다. 이 글은 DO it! HTML5 + CSS3 웹 표준의 정석이라는 책을 인용하였습니다. thumbnail 출처 : http://knulab.com/archives/1060","categories":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"http://rootjang92.github.io/categories/HTML-CSS/"},{"name":"HTML","slug":"HTML-CSS/HTML","permalink":"http://rootjang92.github.io/categories/HTML-CSS/HTML/"}],"tags":[{"name":"HTML, html","slug":"HTML-html","permalink":"http://rootjang92.github.io/tags/HTML-html/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-30T06:10:05.000Z","updated":"2018-08-30T06:10:05.000Z","comments":true,"path":"2018/08/30/hello-world/","link":"","permalink":"http://rootjang92.github.io/2018/08/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}